<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.Tracing.TraceEvent</name>
    </assembly>
    <members>
        <member name="T:FastSerialization.StreamLabel">
            <summary>
            A StreamLabel is a 32 bit integer that represents a position in a IStreamReader or
            IStreamWriter. During writing it is generated by the IStreamWriter.GetLabel method an
            consumed by the IStreamWriter.WriteLabel method. On reading you can use
            IStreamReader.Current and and IStreamReader. 
            </summary>
        </member>
        <member name="F:FastSerialization.StreamLabel.Invalid">
            <summary>
            Represents a stream label that is not a valid value
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamWriter">
            <summary>
            IStreamWriter is meant to be a very simple streaming protocol. You can write integral types,
            strings, and labels to the stream itself.  
            
            IStreamWrite can be thought of a simplified System.IO.BinaryWriter, or maybe the writer
            part of a System.IO.Stream with a few helpers for primitive types.
            
            See also IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Byte)">
            <summary>
            Write a byte to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Int16)">
            <summary>
            Write a short to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Int32)">
            <summary>
            Write an int to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Int64)">
            <summary>
            Write a long to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(FastSerialization.StreamLabel)">
            <summary>
            Write a StreamLabel (a pointer to another part of the stream) to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.String)">
            <summary>
            Write a string to a stream (supports null values).  
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.GetLabel">
            <summary>
            Get the stream label for the current position (points at whatever is written next
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.IStreamWriter.WriteSuffixLabel(FastSerialization.StreamLabel)">
            <summary>
            Write a SuffixLabel it must be the last thing written to the stream.   The stream 
            guarantees that this value can be efficiently read at any time (probably by seeking
            back from the end of the stream)).   The idea is that when you generate a 'tableOfContents'
            you can only do this after processing the data (and probably writing it out), If you
            remember where you write this table of contents and then write a suffix label to it
            as the last thing in the stream using this API, you guarantee that the reader can 
            efficiently seek to the end, read the value, and then goto that position.  (See
            IStreamReader.GotoSuffixLabel for more)
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamReader">
            IStreamReader is meant to be a very simple streaming protocol. You can read integral types,
            strings, and labels to the stream itself.  You can also goto labels you have read from the stream. 
            
            IStreamReader can be thought of a simplified System.IO.BinaryReder, or maybe the reader
            part of a System.IO.Stream with a few helpers for primitive types.
            
            See also IStreamWriter
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadByte">
            <summary>
            Read a byte from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadInt16">
            <summary>
            Read a short from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadInt32">
            <summary>
            Read an int from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadInt64">
            <summary>
            Read a long from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadString">
            <summary>
            Read a string from the stream.   Can represent null strings 
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadLabel">
            <summary>
            Read a StreamLabel (pointer to some other part of the stream) from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.Goto(FastSerialization.StreamLabel)">
            <summary>
            Goto a location in the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.GotoSuffixLabel">
            <summary>
            Sometimes information is only known after writing the entire stream.  This information can be put
            on the end of the stream, but there needs to be a way of finding it relative to the end, rather
            than from the beginning.   A IStreamReader, however, does not actually let you go 'backwards' easily
            because it does not guarantee the size what it writes out (it might compress).  
            
            The solution is the concept of a 'suffixLabel' which is location in the stream where you can always 
            efficiently get to.
            
            It is written with a special API (WriteSuffixLabel that must be the last thing written.   It is 
            expected that it simply write an uncompressed StreamLabel.   It can then be used by using the
            GotoSTreamLabel() method below.   This goes to this well know position in the stream.   We expect
            this is implemented by seeking to the end of the stream, reading the uncompressed streamLabel, 
            and then seeking to that position.  
            </summary>
        </member>
        <member name="P:FastSerialization.IStreamReader.Current">
            <summary>
            Returns the current position in the stream.  
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamWriterExentions">
            <summary>
            Support for higher level operations on IStreamWriter and IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriterExentions.Write(FastSerialization.IStreamWriter,System.Guid)">
            <summary>
            Writes a Guid to stream 'writer' as sequence of 8 bytes
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriterExentions.ReadGuid(FastSerialization.IStreamReader)">
            <summary>
            Reads a Guid to stream 'reader' as sequence of 8 bytes and returns it
            </summary>
        </member>
        <member name="T:FastSerialization.ForwardReference">
            <summary>
            Like a StreamLabel, a ForwardReference represents a pointer to a location in the stream.  
            However unlike a StreamLabel, the exact value in the stream does not need to be known at the
            time the forward references is written.  Instead the ID is written, and later that ID is 
            associated with the target location (using DefineForwardReference).   
            </summary>
        </member>
        <member name="F:FastSerialization.ForwardReference.Invalid">
            <summary>
            Returned when no appropriate ForwardReference exists.  
            </summary>
        </member>
        <member name="T:FastSerialization.Serializer">
            <summary>
            #SerializerIntroduction see also #StreamLayout
            
            The Serializer class is a general purpose object graph serializer helper. While it does not have
            any knowledge of the serialization format of individual object, it does impose conventions on how to
            serialize support information like the header (which holds versioning information), a trailer (which
            holds deferred pointer information), and how types are versioned. However these conventions are
            intended to be very generic and thus this class can be used for essentially any serialization need.
            
            Goals:
                * Allows full range of serialization, including subclassing and cyclic object graphs.
                * Can be serialized and deserialized efficiently sequentially (no seeks MANDATED on read or
                    write). This allows the serializer to be used over pipes and other non-seekable devices).
                * Pay for play (thus very efficient in simple cases (no subclassing or cyclic graphs).
                * Ideally self-describing, and debuggable (output as XML if desired?)
            
            Versioning:
                * We want the ability for new formats to accept old versions if objects wish to support old
                    formats
                * Also wish to allow new formats to be read by OLD version if the new format is just an
                    'extension' (data added to end of objects). This makes making new versions almost pain-free.
                    
            Concepts:
                * No-seek requirement
                
                    The serialized form should be such that it can be deserialized efficiently in a serial fashion
                    (no seeks). This means all information needed to deserialize has to be 'just in time' (can't
                    be some table at the end). Pragmatically this means that type information (needed to create
                    instances), has to be output on first use, so it is available for the deserializer.
                    
                * Laziness requirement
                
                    While is should be possible to read the serialized for sequentially, we should also not force
                    it. It should be possible to have a large file that represents a persisted structure that can
                    be lazily brought into memory on demand. This means that all information needed to
                    deserialize must also be 'randomly available' and not depend on reading from the beginning.
                    Pragmatically this means that type information, and forward forwardReference information needs to
                    have a table in a well known Location at the end so that it can be found without having to
                    search the file sequentially.
                
                * Versioning requirement
                    
                    To allow OLD code to access NEW formats, it must be the case that the serialized form of
                    every instance knows how to 'skip' past any new data (even if it does not know its exact
                    size). To support this, objects have 'begin' and 'end' tags, which allows the deserializer to
                    skip the next object.
                    
                * Polymorphism requirement
                
                    Because the user of a filed may not know the exact instance stored there, in general objects
                    need to store the exact type of the instance. Thus they need to store a type identifier, this
                    can be folded into the 'begin' tag.
                    
                * Arbitrary object graph (circularity) requirement (Forward references)
                
                    The serializer needs to be able to serialize arbitrary object graphs, including those with
                    cycles in them. While you can do this without forward references, the system is more flexible
                    if it has the concept of a forward reference. Thus whenever a object reference is required, a
                    'forward forwardReference' can be given instead. What gets serialized is simply an unique forward
                    reference index (index into an array), and at some later time that index is given its true
                    value. This can either happen with the target object is serialized (see
                    Serializer.Tags.ForwardDefintion) or at the end of the serialization in a forward
                    reference table (which allows forward references to be resolved without scanning then entire
                    file.
                    
                * Contract between objects IFastSerializable.ToStream:
                
                    The heart of the serialization and deserialization process the IFastSerializable
                    interface, which implements just two methods: ToStream (for serializing an object), and
                    FromStream (for deserializing and object). This interfaces is the mechanism by which objects
                    tell the serializer what data to store for an individual instance. However this core is not
                    enough. An object that implements IFastSerializable must also implement a default
                    constructor (constructor with no args), so that that deserializer can create the object (and
                    then call FromStream to populated it).
                    
                    The ToStream method is only responsible for serializing the data in the object, and by itself
                    is not sufficient to serialize an interconnected, polymorphic graph of objects. It needs
                    help from the Serializer and Deserialize to do this. Serializer takes on the
                    responsibility to deal with persisting type information (so that Deserialize can create
                    the correct type before IFastSerializable.FromStream is called). It is also the
                    serializer's responsibility to provide the mechanism for dealing with circular object graphs
                    and forward references.
                
                * Layout of a serialized object: A serialized object has the following basic format
                
                    * If the object is the definition of a previous forward references, then the definition must
                        begin with a Serializer.Tags.ForwardDefintion tag followed by a forward forwardReference
                        index which is being defined.
                    * Serializer.Tags.BeginObject tag
                    * A reference to the SerializationType for the object. This reference CANNOT be a
                        forward forwardReference because its value is needed during the deserialization process before
                        forward references are resolved.
                    * All the data that that objects 'IFastSerializable.ToStream method wrote. This is the
                        heart of the deserialized data, and the object itself has a lot of control over this
                        format.
                    * Serializer.Tags.EndObject tag. This marks the end of the object. It quickly finds bugs
                        in ToStream FromStream mismatches, and also allows for V1 deserializers to skip past
                        additional fields added since V1.
                    
                * Serializing Object references:
                  When an object forwardReference is serialized, any of the following may follow in the stream
                  
                    * Serializer.Tags.NullReference used to encode a null object forwardReference.
                    * Serializer.Tags.BeginObject or Serializer.Tags.ForwardDefintion, which indicates
                        that this the first time the target object has been referenced, and the target is being
                        serialized on the spot.
                    * Serializer.Tags.ObjectReference which indicates that the target object has already
                        been serialized and what follows is the StreamLabel of where the definition is.
                    * Serializer.Tags.ForwardReference followed by a new forward forwardReference index. This
                        indicates that the object is not yet serialized, but the serializer has chosen not to
                        immediately serialize the object. Ultimately this object will be defined, but has not
                        happened yet.
                       
                * Serializing Types:
                  Types are simply objects of type SerializationType which contain enough information about
                  the type for the Deserializer to do its work (it full name and version number).   They are
                  serialized just like all other types.  The only thing special about it is that references to
                  types after the BeginObject tag must not be forward references.  
             
            #StreamLayout:
                The structure of the file as a whole is simply a list of objects.  The first and last objects in
                the file are part of the serialization infrastructure.  
                
            Layout Synopsis
                * Signature representing Serializer format
                * EntryObject (most of the rest of the file)
                    * BeginObject tag
                    * Type for This object (which is a object of type SerializationType)
                        * BeginObject tag
                        * Type for SerializationType  POSITION1
                            * BeginObject tag
                            * Type for SerializationType
                                 * ObjectReference tag           // This is how our recursion ends.  
                                 * StreamLabel for POSITION1
                            * Version Field for SerializationType
                            * Minimum Version Field for SerializationType
                            * FullName string for SerializationType                
                            * EndObject tag
                        * Version field for EntryObject's type
                        * Minimum Version field for EntryObject's type
                        * FullName string for EntryObject's type
                        * EndObject tag
                    * Field1  
                    * Field2 
                    * V2_Field (this should be tagged so that it can be skipped by V1 deserializers.  
                    * EndObject tag
                * ForwardReferenceTable pseudo-object
                    * Count of forward references
                    * StreamLabel for forward ref 0
                    * StreamLabel for forward ref 1.
                    * ...
                * SerializationTrailer pseudo-object
                    * StreamLabel ForwardReferenceTable
                * StreamLabel to SerializationTrailer
                * End of stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(System.String,FastSerialization.IFastSerializable)">
            <summary>
            Create a serializer writes 'entryObject' to a file.  
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(System.IO.Stream,FastSerialization.IFastSerializable)">
            <summary>
            TODO FIX NOW, do we want the serializer to close the stream?
            Create a serializer that writes 'entryObject' to a System.IO.Stream.   The serializer will close the stream when it closes.  
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(FastSerialization.IStreamWriter,FastSerialization.IFastSerializable)">
            <summary>
            Create a serializer that writes 'entryObject' another IStreamWriter 
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Boolean)">
            <summary>
            Write a bool to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Byte)">
            <summary>
            Write a byte to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Int16)">
            <summary>
            Write a short to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Int32)">
            <summary>
            Write an int to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Int64)">
            <summary>
            Write a long to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Guid)">
            <summary>
            Write a Guid to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.String)">
            <summary>
            Write a string to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Single)">
            <summary>
            Write a float to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Double)">
            <summary>
            Write a double to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(FastSerialization.StreamLabel)">
            <summary>
            Write a StreamLabel (pointer to some other part of the stream whose location is current known) to the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(FastSerialization.ForwardReference)">
            <summary>
            Write a ForwardReference (pointer to some other part of the stream that whose location is not currently known) to the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(FastSerialization.IFastSerializable)">
            <summary>
            If the object is potentially aliased (multiple references to it), you should write it with this method.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteDefered(FastSerialization.IFastSerializable)">
            <summary>
            To tune working set (or disk seeks), or to make the dump of the format more readable, it is
            valuable to have control over which of several references to an object will actually cause it to
            be serialized (by default the first encountered does it).
            
            WriteDefered allows you to write just a forwardReference to an object with the expectation that
            somewhere later in the serialization process the object will be serialized. If no call to
            WriteObject() occurs, then the object is serialized automatically before the stream is closed
            (thus dangling references are impossible).        
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WritePrivate(FastSerialization.IFastSerializable)">
            <summary>
            This is an optimized version of WriteObjectReference that can be used in some cases.
            
            If the object is not aliased (it has an 'owner' and only that owner has references to it (which
            implies its lifetime is strictly less than its owners), then the serialization system does not
            need to put the object in the 'interning' table. This saves a space (entries in the intern table
            as well as 'SyncEntry' overhead of creating hash codes for object) as well as time (to create
            that bookkeeping) for each object that is treated as private (which can add up if because it is
            common that many objects are private).  The private instances are also marked in the serialized
            format so on reading there is a similar bookkeeping savings. 
            
            The ultimate bits written by WritePrivateObject are the same as WriteObject.
            
            TODO Need a DEBUG mode where we detect if others besides the owner reference the object.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.GetForwardReference">
            <summary>
            Create a ForwardReference.   At some point before the end of the serialization, DefineForwardReference must be called on this value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.Serializer.DefineForwardReference(FastSerialization.ForwardReference)">
            <summary>
            Define the ForwardReference forwardReference to point at the current write location.  
            </summary>
            <param name="forwardReference"></param>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Boolean)">
            <summary>
            Write a byte preceded by a tag that indicates its a byte.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Byte)">
            <summary>
            Write a byte preceded by a tag that indicates its a byte.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Int16)">
            <summary>
            Write a byte preceded by a tag that indicates its a short.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Int32)">
            <summary>
            Write a byte preceded by a tag that indicates its a int.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Int64)">
            <summary>
            Write a byte preceded by a tag that indicates its a long.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.String)">
            <summary>
            Write a byte preceded by a tag that indicates its a string.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(FastSerialization.IFastSerializable)">
            <summary>
            Write a byte preceded by a tag that indicates its a object.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTaggedEnd">
            <summary>
            Writes an end tag (which is different from all others).   This is useful 
            when you have a deferred region of tagged items.  
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Close">
            <summary>
            Completes the writing of the stream. 
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Log(System.String)">
            <summary>
            To help debug any serialization issues, you can write data to a side file called 'log.serialize.xml'
            which can track exactly what serialization operations occurred.  
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Dispose">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="P:FastSerialization.Serializer.Writer">
            <summary>
            Retrieve the underlying stream we are writing to.  Generally the Write* methods are enough. 
            </summary>
        </member>
        <member name="T:FastSerialization.Deserializer">
            <summary>
            Deserializer is a helper class that holds all the information needed to deserialize an object
            graph as a whole (things like the table of objects already deserialized, and the list of types in
            the object graph.  
            
            see #SerializerIntroduction for more
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.#ctor(System.String)">
            <summary>
            Create a Deserializer that reads its data from a given file
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.#ctor(System.IO.Stream,System.String)">
            <summary>
            Create a Deserializer that reads its data from a given System.IO.Stream.   The stream will be closed when the Deserializer is done with it.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.#ctor(FastSerialization.IStreamReader,System.String)">
            <summary>
            Create a Deserializer that reads its data from a given IStreamReader.   The stream will be closed when the Deserializer is done with it.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.GetEntryTypeName">
            <summary>
            Returns the full name of the type of the entry object without actually creating it.
            Will return null on failure.  
            </summary>  
        </member>
        <member name="M:FastSerialization.Deserializer.GetEntryObject``1(``0@)">
            <summary>
            GetEntryObject is the main deserialization entry point.  The serialization stream always has an object that represents the stream as
            a whole, called the entry object and this returns it and places it in 'ret'
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.GetEntryObject">
            <summary>
            GetEntryObject is the main deserialization entry point.  The serialization stream always has an object that represents the stream as
            a whole, called the entry object and this returns it and returns it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Boolean@)">
            <summary>
            Read a bool from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Byte@)">
            <summary>
            Read a byte from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Int16@)">
            <summary>
            Read a short from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Int32@)">
            <summary>
            Read an int from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Int64@)">
            <summary>
            Read a long from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Guid@)">
            <summary>
            Read a Guid from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Single@)">
            <summary>
            Read a float from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Double@)">
            <summary>
            Read a double from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.String@)">
            <summary>
            Read a string from the stream.  Can represent null
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(FastSerialization.StreamLabel@)">
            <summary>
            d) from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read``1(``0@)">
            <summary>
            Read a IFastSerializable object from the stream and place it in ret
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadObject">
            <summary>
            Read a IFastSerializable object from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadBool">
            <summary>
            Read a bool from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadByte">
            <summary>
            Read a byte from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadInt16">
            <summary>
            Read a short from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadInt">
            <summary>
            Read an int from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadInt64">
            <summary>
            Read a long from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadFloat">
            <summary>
            Read a float from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadDouble">
            <summary>
            Read a double from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadString">
            <summary>
            Read in a string value and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadLabel">
            <summary>
            Read in a StreamLabel (a pointer to some other part of the stream) and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadForwardReference">
            <summary>
            Read in a ForwardReference (a pointer to some other part of the stream which was not known at the tie it was written) and return it
            Use ResolveForwardReference to convert the ForwardReference to a StreamLabel
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ResolveForwardReference(FastSerialization.ForwardReference,System.Boolean)">
            <summary>
            Given a forward reference find the StreamLabel (location in the stream) that it points at).  
            Normally this call preserves the current read location, but if you do don't care you can 
            set preserveCurrent as an optimization to make it more efficient.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.RegisterFactory(System.Type,System.Func{FastSerialization.IFastSerializable})">
            <summary>
            For every IFastSerializable object being deserialized, the Deserializer needs to create 'empty' objects 
            that 'FromStream' is invoked on.  The Deserializer gets these 'empty' objects by calling a 'factory'
            delegate for that type.   Thus all types being deserialized must have a factory.   
            
            RegisterFactory registers such a factory for particular 'type'.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.RegisterDefaultFactory(System.Func{System.Type,FastSerialization.IFastSerializable})">
            <summary>
            For every IFastSerializable object being deserialized, the Deserializer needs to create 'empty' objects 
            that 'FromStream' is invoked on.  The Deserializer gets these 'empty' objects by calling a 'factory'
            delegate for that type.   Thus all types being deserialized must have a factory.   
            
            RegisterDefaultFactory registers a factory that is passed a type parameter and returns a new IFastSerialable object. 
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Boolean@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged bool, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Byte@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged byte, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Int16@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged short, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Int32@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged int, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Int64@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged long, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.String@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged string, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged``1(``0@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged FastSerializable, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTaggedObject">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged FastSerializable, return it, otherwise leave the cursor unchanged and return null
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Goto(FastSerialization.StreamLabel)">
            <summary>
            Set the read position to the given StreamLabel
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Goto(FastSerialization.ForwardReference)">
            <summary>
            Set the read position to the given ForwardReference
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Dispose">
            <summary>
            Close the IStreamReader and free resources associated with the Deserializer
            </summary>
        </member>
        <member name="F:FastSerialization.Deserializer.deferForwardReferences">
            <summary>
            When we encounter a forward reference, we can either go to the forward reference table immediately and resolve it 
            (deferForwardReferences == false), or simply remember that that position needs to be fixed up and continue with
            the deserialization.   This later approach allows 'no seek' deserialization.   This variable which scheme we do. 
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.VersionBeingRead">
            <summary>
            Meant to be called from FromStream.  It returns the version number of the 
            type being deserialized.   It can be used so that new code can recognizes that it
            is reading an old file format and adjust what it reads.   
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.MinimumReaderVersionBeingRead">
            <summary>
            Meant to be called from FromStream.  It returns the version number of the MinimumReaderVersion
            of the type that was serialized.   
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.Name">
            <summary>
            The filename if read from a file or the stream name if read from a stream
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.TypeResolver">
            <summary>
            If set this function is set, then it is called whenever a type name from the serialization
            data is encountered.  It is your you then need to look that up.  If it is not present 
            it uses Type.GetType(string) which only checks the current assembly and mscorlib. 
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.Current">
            <summary>
            Returns the current read position in the stream. 
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.Reader">
            <summary>
            Fetch the underlying IStreamReader that the deserializer reads data from 
            </summary>
        </member>
        <member name="T:FastSerialization.DeferedRegion">
            <summary>
            #DeferedRegionOverview. 
            
            A DeferedRegion help make 'lazy' objects. You will have a DeferedRegion for each block of object you
            wish to independently decide whether to deserialize lazily (typically you have one per object however
            in the limit you can have one per field, it is up to you).
            
            When you call DeferedRegion.Write you give it a delegate that will write all the deferred fields.
            The Write operation will place a forward reference in the stream that skips all the fields written,
            then the fields themselves, then define the forward reference. This allows readers to skip the
            deferred fields.
            
            When you call DeferedRegion.Read  you also give it a delegate that reads all the deferred fields.
            However when 'Read' instead of reading the fields it
            
                * remembers the deserializer, stream position, and reading delegate.
                * it uses the forward reference to skip the region.
                
            When DeferedRegion.FinishRead is called, it first checks if the region was already restored. 
            If not it used the information to read in the deferred region and returns.  Thus this FinishRead
            should be called before any deferred field is used.  
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.Write(FastSerialization.Serializer,System.Action)">
            <summary>
            see #DeferedRegionOverview.  
            TODO more 
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.Read(FastSerialization.Deserializer,System.Action)">
            <summary>
            See overview in DeferedRegion class comment.  
            This call indicates that the 'fromStream' delegate  can deserialize a region of the object, which
            was serialized with the DeferedRegion.Write method.   The read skips the data for the region (thus
            no objects associated with the region are created in memory) but the deferred object remembers 
            'fromStream' and will call it when 'FinishRead()' is called. 
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.FinishRead(System.Boolean)">
            <summary>
            FinishRead indicates that you need to deserialize the lazy region you defined with the 'Read' method.
            If the region has already been deserialized, nothing is done.   Otherwise when you call this
            method the current position in the stream is put back to where it was when Read was called and the
            'fromStream' delegate registered in 'Read' is called to perform the deserialization.    
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.FinishReadHelper(System.Boolean)">
            <summary>
            This helper is just here to insure that FinishRead gets inlined 
            </summary>
        </member>
        <member name="P:FastSerialization.DeferedRegion.IsFinished">
            <summary>
            Returns true if the FinsihRead() has already been called. 
            </summary>
        </member>
        <member name="P:FastSerialization.DeferedRegion.Deserializer">
            <summary>
            Get the deserializer assoicated with this DeferredRegion
            </summary>
        </member>
        <member name="P:FastSerialization.DeferedRegion.StartPosition">
            <summary>
            Get the stream position when Read was called
            </summary>
        </member>
        <member name="T:FastSerialization.IFastSerializable">
            <summary>
            A type can opt into being serializable by implementing IFastSerializable and a default constructor
            (constructor that takes not arguments).
            
            Conceptually all clients of IFastSerializable also implement IFastSerializableVersion
            however the serializer will assume a default implementation of IFastSerializableVersion (that
            Returns version 1 and assumes all versions are allowed to deserialize it.  
            </summary>
        </member>
        <member name="M:FastSerialization.IFastSerializable.ToStream(FastSerialization.Serializer)">
            <summary>
            Given a Serializer, write yourself to the output stream. Conceptually this routine is NOT
            responsible for serializing its type information but only its field values. However it is
            conceptually responsible for the full transitive closure of its fields.
            
            * For primitive fields, the choice is easy, simply call Serializer.Write
            * For object fields there is a choice
                * If is is only references by the enclosing object (eg and therefore field's lifetime is
                    identical to referencing object), then the Serialize.WritePrivateObject can be
                    used.  This skips placing the object in the interning table (that insures it is written
                    exactly once).  
                * Otherwise call Serialize.WriteObject
            * For value type fields (or collections of structs), you serialize the component fields.  
            * For collections, typically you serialize an integer inclusiveCountRet followed by each object. 
            </summary>
        </member>
        <member name="M:FastSerialization.IFastSerializable.FromStream(FastSerialization.Deserializer)">
            <summary>
            
            Given a reader, and a 'this' instance, made by calling the default constructor, create a fully
            initialized instance of the object from the reader stream.  The deserializer provides the extra
            state needed to do this for cyclic object graphs.  
            
            Note that it is legal for the instance to cache the deserializer and thus be 'lazy' about when
            the actual deserialization happens (thus large persisted strucuture on the disk might stay on the
            disk).  
            
            Typically the FromStream implementation is an exact mirror of the ToStream implementation, where
            there is a Read() for every Write(). 
            </summary>
        </member>
        <member name="T:FastSerialization.IFastSerializableVersion">
            <summary>
            Objects implement IFastSerializableVersion to indicate what the current version is for writing
            and which readers can read the current version.   If this interface is not implemented a default is
            provided (assuming version 1 for writing and MinimumVersion = 0).  
            
            By default Serializer.WriteObject will place marks when the object ends and always skip to the
            end even if the FromStream did not read all the object data.   This allows considerable versioning
            flexibility.  Simply by placing the new data at the end of the existing serialization, new versions
            of the type can be read by OLD deserializers (new fields will have the value determined by the
            default constructor (typically 0 or null).  This makes is relatively easy to keep MinimumVersion = 0
            (the ideal case).  
            </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.Version">
            <summary>
            This is the version number for the serialization CODE (that is the app decoding the format)
            It should be incremented whenever a change is made to IFastSerializable.ToStream and the format 
            is publicly disseminated.  It must not vary from instance to instance.  This is pretty straightforward.   
            It defaults to 0
            </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.MinimumVersionCanRead">
             <summary>
             At some point typically you give up allowing new versions of the read to read old wire formats
             This is the Minimum version of the serialized data that this reader can deserialize.   Trying
             to read wire formats strictly smaller (older) than this will fail.   Setting this to the current
             version indicates that you don't care about ever reading data generated with an older version
             of the code.  
             
             If you set this to something other than your current version, you are obligated to insure that
             your FromStream() method can handle all formats >= than this number. 
            
             You can achieve this if you simply use the 'WriteTagged' and 'ReadTagged' APIs in your 'ToStream' 
             and 'FromStream' after your V1 AND you always add new fields to the end of your class.   
             This is the best practice.   Thus  
             
                 void IFastSerializable.ToStream(Serializer serializer)
                 {
                     serializer.Write(Ver_1_Field1);
                     serializer.Write(Ver_1_Field2);
                     // ...
                     serializer.WriteTagged(Ver_2_Field1);   
                     serializer.WriteTagged(Ver_2_Field2);
                     // ...
                     serializer.WriteTagged(Ver_3_Field1);
                 }
             
                 void IFastSerializable.FromStream(Deserializer deserializer)
                 {
                     deserializer.Read(out Ver_1_Field1);
                     deserializer.Read(out Ver_1_Field2);
                     // ...
                     deserializer.TryReadTagged(ref Ver_2_Field1);  // If data no present (old format) then Ver_2_Field1 not set.
                     deserializer.TryReadTagged(ref Ver_2_Field2);  // ditto...
                     // ...
                     deserializer.TryReadTagged(ref Ver_3_Field1);    
                 } 
             
             Tagging outputs a byte tag in addition to the field itself.   If that is a problem you can also use the
             VersionBeingRead to find out what format is being read and write code that explicitly handles it.  
             Note however that this only gets you Backward compatibility (new readers can read the old format, but old readers 
             will still not be able to read the new format), which is why this is not the preferred method.  
             
                 void IFastSerializable.FromStream(Deserializer deserializer)
                 {
                     // We assume that MinVersionCanRead == 4
                     // Deserialize things that are common to all versions (4 and earlier) 
                     
                     if (deserializer.VersionBeingRead >= 5)
                     {
                         deserializer.Read(AVersion5Field);
                         if (deserializer.VersionBeingRead >= 5)
                             deserializer.ReadTagged(AVersion6Field);    
                     }
                 }
             </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.MinimumReaderVersion">
            <summary>
            This is the minimum version of a READER that can read this format.   If you don't support forward
            compatibility (old readers reading data generated by new readers) then this should be set to 
            the current version.  
            
            If you set this to something besides the current version you are obligated to insure that your
            ToStream() method ONLY adds fields at the end, AND that all of those added fields use the WriteTagged()
            operations (which tags the data in a way that old readers can skip even if they don't know what it is)
            In addition your FromStream() method must read these with the ReadTagged() deserializer APIs.  
            
            See the comment in front of MinimumVersionCanRead for an example of using the WriteTagged() and ReadTagged() 
            methods. 
            </summary>
        </member>
        <member name="T:FastSerialization.SerializationException">
            <summary>
            Thrown when the deserializer detects an error. 
            </summary>
        </member>
        <member name="M:FastSerialization.SerializationException.#ctor(System.String)">
            <summary>
            Thown when a error occurs in serialization.  
            </summary>
        </member>
        <member name="P:FastSerialization.SerializationType.Version">
            <summary>
            This is the version represents the version of both the reading
            code and the version for the format for this type in serialized form.  
            See IFastSerializableVersion for more.  
            </summary>
        </member>
        <member name="P:FastSerialization.SerializationType.MinimumReaderVersion">
            <summary>
            The version the the smallest (oldest) reader code that can read 
            this file format.  Readers strictly less than this are rejected.  
            This allows support for forward compatbility.   
            See IFastSerializableVersion for more.  
            </summary>
        </member>
        <member name="T:System.Collections.Generic.GrowableArray`1">
            <summary>
            A cheap version of List(T). The idea is to make it as cheap as if you did it 'by hand' using an array and
            an int which represents the logical charCount. It is a struct to avoid an extra pointer dereference, so this
            is really meant to be embedded in other structures.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.#ctor(System.Int32)">
            <summary>
            Create a growable array with the given initial size it will grow as needed.  There is also the
            default constructor that assumes initialSize of 0 (and does not actually allocate the array. 
            </summary>
            <param name="initialSize"></param>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Clear">
            <summary>
            Remove all elements in the array. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Add(`0)">
            <summary>
            Add an item at the end of the array, growing as necessary. 
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items 'items' to the end of the array, growing as necessary. 
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Insert(System.Int32,`0)">
            <summary>
            Insert 'item' directly at 'index', shifting all items >= index up.  'index' can be code:Count in
            which case the item is appended to the end.  Larger indexes are not allowed. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Remove 'count' elements starting at 'index'
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Set(System.Int32,`0)">
            <summary>
            Sets the 'index' element to 'value' growing the array if necessary (filling in default values if necessary).  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Get(System.Int32)">
            <summary>
            Gets the value at 'index'.   Never fails, will return 'default' if out of range.  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Pop">
            <summary>
            Remove the last element added and return it.   Will throw if there are no elements. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Trim(System.Int32)">
            <summary>
            Trims the size of the array so that no more than 'maxWaste' slots are wasted.   Useful when
            you know that the array has stopped growing.  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.ToString">
            <summary>
            A string representing the array.   Only intended for debugging.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.BinarySearch``1(``0,System.Int32@,System.Collections.Generic.GrowableArray{`0}.Comparison{``0})">
            <summary>
            Sets 'index' to the the smallest index such that all elements with index > 'idx' are > key.  If
            index does not match any elements a new element should always be placed AFTER index.  Note that this
            means that index may be -1 if the new element belongs in the first position.  
            
            Returns true if the return index matched exactly (success)
            
            TODO FIX NOW harmonize with List.BinarySearch
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Sort(System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sort the range starting at 'index' of length 'count' using 'comparision' in assending order
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Sort(System.Comparison{`0})">
            <summary>
            Sort the whole array using 'comparison' in ascending order
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Foreach``1(System.Func{`0,``0})">
            <summary>
            Executes 'func' for each element in the GrowableArray and returns a GrowableArray 
            for the result.  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Search``1(``0,System.Int32,System.Collections.Generic.GrowableArray{`0}.Comparison{``0},System.Int32@)">
            <summary>
            Perform a linear search starting at 'startIndex'.  If found return true and the index in 'index'.
            It is legal that 'startIndex' is greater than the charCount, in which case, the search returns false
            immediately.   This allows a nice loop to find all items matching a pattern. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.GetEnumerator">
            <summary>
            Implementation of foreach protocol
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Item(System.Int32)">
            <summary>
            Fetch the element at the given index.  Will throw an IndexOutOfRange exception otherwise
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Count">
            <summary>
            The number of elements in the array
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Empty">
            <summary>
            Returns true if there are no elements in the array. 
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Top">
            <summary>
            Returns the last element added  Will throw if there are no elements. 
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.UnderlyingArray">
            <summary>
            Returns the underlying array.  Should not be used most of the time!
            </summary>
        </member>
        <member name="T:System.Collections.Generic.GrowableArray`1.Comparison`1">
            <summary>
            Should return -1 if x is less than elem.  
            TODO FIX NOW use Func instead.  
            </summary>
        </member>
        <member name="T:System.Collections.Generic.GrowableArray`1.GrowableArrayEnumerator">
            <summary>
            Enumerator for foreach interface
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.GrowableArrayEnumerator.MoveNext">
            <summary>
            implementation of IEnumerable interface
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.GrowableArrayEnumerator.Current">
            <summary>
            implementation of IEnumerable interface
            </summary>
        </member>
        <member name="T:FastSerialization.MemoryStreamReader">
            <summary>
            A MemoryStreamReader is an implementation of the IStreamReader interface that works over a given byte[] array.  
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.#ctor(System.Byte[])">
            <summary>
            Create a IStreamReader (reads binary data) from a given byte buffer
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a IStreamReader (reads binary data) from a given subregion of a byte buffer 
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.Skip(System.Int32)">
            <summary>
            Convenince function for skipping a a certain number of bytes in the stream.  
            </summary>
            <param name="byteCount"></param>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadByte">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadInt16">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadInt32">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadInt64">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadString">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadLabel">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.Goto(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.GotoSuffixLabel">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.Dispose">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="P:FastSerialization.MemoryStreamReader.Length">
            <summary>
            The total length of bytes that this reader can read.  
            </summary>
        </member>
        <member name="P:FastSerialization.MemoryStreamReader.Current">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="T:FastSerialization.MemoryStreamWriter">
            <summary>
            A StreamWriter is an implementation of the IStreamWriter interface that generates a byte[] array. 
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.#ctor(System.Int32)">
            <summary>
            Create IStreamWriter that writes its data to an internal byte[] buffer.  It will grow as needed. 
            Call 'GetReader' to get a IStreamReader for the written bytes. 
            
            Call 'GetBytes' call to get the raw array.  Only the first 'Length' bytes are valid
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.GetReader">
            <summary>
            Returns a IStreamReader that will read the written bytes.  You cannot write additional bytes to the stream after making this call. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.GetBytes">
            <summary>
            The the array that holds the serialized data.   
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Clear">
            <summary>
            Clears any data that was previously written.  
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Byte)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Int16)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Int32)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Int64)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.String)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.GetLabel">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.WriteSuffixLabel(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Dispose">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="P:FastSerialization.MemoryStreamWriter.Length">
            <summary>
            The number of bytes written so far.  
            </summary>
        </member>
        <member name="T:FastSerialization.IOStreamStreamReader">
            <summary>
            A IOStreamStreamReader hooks a MemoryStreamReader up to an input System.IO.Stream.  
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.#ctor(System.String)">
            <summary>
            Create a new IOStreamStreamReader from the given file.  
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Create a new IOStreamStreamReader from the given System.IO.Stream.   Optionally you can specify the size of the read buffer
            The stream will be closed by the IOStreamStreamReader when it is closed.  
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Close">
            <summary>
            close the file or underlying stream and clean up 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Goto(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Fill(System.Int32)">
            <summary>
            Fill the buffer, making sure at least 'minimum' byte are available to read.  Throw an exception
            if there are not that many bytes.  
            </summary>
            <param name="minimum"></param>
        </member>
        <member name="P:FastSerialization.IOStreamStreamReader.Current">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamReader.Length">
            <summary>
            Implementation of MemoryStreamReader
            </summary>
        </member>
        <member name="T:FastSerialization.PinnedStreamReader">
            <summary>
            A PinnedStreamReader is an IOStream reader that will pin its read buffer.
            This allows it it support a 'GetPointer' API efficiently.   The 
            GetPointer API lets you access data from the stream as raw byte 
            blobs without having to copy the data.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.#ctor(System.String,System.Int32)">
            <summary>
            Create a new PinnedStreamReader that gets its data from a given file.  You can optionally set the size of the read buffer.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Create a new PinnedStreamReader that gets its data from a given System.IO.Stream.  You can optionally set the size of the read buffer.  
            The stream will be closed by the PinnedStreamReader when it is closed.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.Clone">
            <summary>
            Clone the PinnnedStreamReader so that it reads from the same stream as this one.   They will share the same
            System.IO.Stream, but each will lock and seek when accessing that stream so they can both safely share it.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.GetPointer(FastSerialization.StreamLabel,System.Int32)">
            <summary>
            Get a byte* pointer to the input buffer at 'Position' in the IReadStream that is at least 'length' bytes long.  
            (thus ptr to ptr+len is valid).   Note that length cannot be larger than the buffer size passed to the reader
            when it was constructed.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.GetPointer(System.Int32)">
            <summary>
            Get a byte* pointer to the input buffer at the current read position is at least 'length' bytes long.  
            (thus ptr to ptr+len is valid).   Note that length cannot be larger than the buffer size passed to the reader
            when it was constructed.  
            </summary>
        </member>
        <member name="T:FastSerialization.IOStreamStreamWriter">
            <summary>
            A IOStreamStreamWriter hooks a MemoryStreamWriter up to an output System.IO.Stream
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.#ctor(System.String)">
            <summary>
            Create a IOStreamStreamWriter that writes its data to a given file that it creates
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Create a IOStreamStreamWriter that writes its data to a System.IO.Stream
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Flush">
            <summary>
            Flush any written data to the underlying System.IO.Stream
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Close">
            <summary>
            Insures the bytes in the stream are written to the stream and cleans up resources.  
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.GetLabel">
            <summary>
            Implementation of the IStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Clear">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.GetReader">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.GetBytes">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamWriter.RawStream">
            <summary>
            Access the underlying System.IO.Stream.   You should avoid using this if at all possible.  
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamWriter.Length">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.DirectoryUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system directories. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Copy(System.String,System.String)">
            <summary>
            SafeCopy sourceDirectory to directoryToVersion recursively. The target directory does
            no need to exist
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Copy(System.String,System.String,System.IO.SearchOption)">
            <summary>
            SafeCopy all files from sourceDirectory to directoryToVersion.  If searchOptions == AllDirectories
            then the copy is recursive, otherwise it is just one level.  The target directory does not
            need to exist. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Clean(System.String)">
            <summary>
            Clean is sort of a 'safe' recursive delete of a directory.  It either deletes the
            files or moves them to '*.deleting' names.  It deletes directories that are completely
            empty.  Thus it will do a recursive delete when that is possible.  There will only 
            be *.deleting files after this returns.  It returns the number of files and directories
            that could not be deleted.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.DeleteOldest(System.String,System.Int32)">
            <summary>
            Removes the oldest directories directly under 'directoryPath' so that 
            only 'numberToKeep' are left. 
            </summary>
            <param variable="directoryPath">Directory to removed old files from.</param>
            <param variable="numberToKeep">The number of files to keep.</param>
            <returns> true if there were no errors deleting files</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.GetFiles(System.String,System.String,System.IO.SearchOption)">
             <summary>
             DirectoryUtilities.GetFiles is basicaly the same as Directory.GetFiles 
             however it returns IEnumerator, which means that it lazy.  This is very important 
             for large directory trees.  A searchPattern can be specified (Windows wildcard conventions)
             that can be used to filter the set of archiveFile names returned. 
             
             Suggested Usage
             
                 foreach(string fileName in DirectoryUtilities.GetFiles("c:\", "*.txt")){
                     Console.WriteLine(fileName);
                 }
            
             </summary>
             <param variable="directoryPath">The base directory to enumerate</param>
             <param variable="searchPattern">A pattern to filter the names (windows filename wildcards * ?)</param>
             <param variable="searchOptions">Indicate if the search is recursive or not.  </param>
             <returns>The enumerator for all archiveFile names in the directory (recursively). </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.GetFiles(System.String,System.String)">
            <summary>
            Returns a lazy enumerable for every path in 'directoryName' that matchs 'searchPattern' (default is *)MO
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.FileUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system files. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ReadAllLines(System.String)">
            <summary>
            GetLines works much like File.ReadAllLines, however instead of returning a
            array of lines, it returns a IEnumerable so that the archiveFile is not read all
            at once.  This allows 'foreach' syntax to be used on very large files.  
            
            Suggested Usage
            
                foreach(string lineNumber in FileUtilities.GetLines("largeFile.txt")){
                    Console.WriteLine(lineNumber);
                }
            </summary>
            <param variable="fileName">The base directory to enumerate.</param>
            <returns>The enumerator for all lines in the archiveFile.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ExpandWildcards(System.String[],System.IO.SearchOption)">
            <summary>
            Given archiveFile specifications possibly with wildcards in them
            Returns an enumerator that returns each expanded archiveFile name in turn. 
            
            If searchOpt is AllDirectories it does a recursive match. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceDelete(System.String)">
            <summary>
            Delete works much like File.Delete, except that it will succeed if the
            archiveFile does not exist, and will rename the archiveFile so that even if the archiveFile 
            is locked the original archiveFile variable will be made available.  
            
            It renames the  archiveFile with a '[num].deleting'.  These files might be left 
            behind.  
            
            It returns true if it was completely successful.  If there is a *.deleting
            archiveFile left behind, it returns false. 
            </summary>
            <param variable="fileName">The variable of the archiveFile to delete</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.TryDelete(System.String)">
            <summary>
            Try to delete 'fileName' catching any exception.  Returns true if successful.   It will delete read-only files.  
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceCopy(System.String,System.String)">
            <summary>
            SafeCopy sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceMove(System.String,System.String)">
            <summary>
            Moves sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.Equals(System.String,System.String)">
            <summary>
            Returns true if the two file have exactly the same content (as a stream of bytes). 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.PathUtil">
            <summary>
            Utilities associated with file name paths. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.PathUtil.PathRelativeTo(System.String,System.String)">
            <summary>
            Given a path and a superdirectory path relativeToDirectory compute the relative path (the path from) relativeToDirectory
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.StreamUtilities">
            <summary>
            General utilities associated with streams. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.StreamUtilities.CopyFromFile(System.String,System.IO.Stream)">
            <summary>
            Open the 'fromFilePath' and write its contents to 'toStream'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.StreamUtilities.CopyToFile(System.IO.Stream,System.String)">
            <summary>
            Open the 'toFilePath' for writing and write the contents of 'fromStream' to it
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.StreamUtilities.CopyStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            CopyStream simply copies 'fromStream' to 'toStream'
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.XmlUtilities">
            <summary>
            The important thing about these general utilities is that they have only dependencies on mscorlib and
            System (they can be used from anywhere).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.OpenXmlElement(System.String)">
            <summary>
            Given an XML element, remove the closing operator for it, so you can add new child elements to it by concatination. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlEscape(System.Object,System.Boolean)">
            <summary>
            Given an object 'obj' do ToString() on it, and then transform it so that all speical XML characters are escaped and return the result. 
            If 'quote' is true also surround the resulting object with double quotes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuote(System.Object)">
            <summary>
            A shortcut for XmlEscape(obj, true) (that is ToString the object, escape XML chars, and then surround with double quotes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuote(System.Int32)">
            <summary>
            Create a doubly quoted string for the decimal integer value
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.UInt32)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.UInt64)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.Int32)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.Int64)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ActivityComputer">
            <summary>
            An ActivityComputer is a state machine that track information about Activities.  In particular, it can
            compute a activity aware call stack. (GetCallStack).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource,Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.GCReferenceComputer)">
            <summary>
            Construct a new ActivityComputer that will process events from 'eventLog' and output activity - aware stacks to 'outputStackSource'. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCurrentActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Fetches the current activity for 'thread'  at the present time (the current event being dispatched).  
            Never returns null because there is always and activity (it may be the thread task).  
            This is arguably the main thing that this computer keeps track of.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetActivityRepresentingThread(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Gets the default activity for a thread (the activity a thread is doing when the thread starts).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCallStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.TraceEvent,System.Func{Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex},System.Boolean)">
            <summary>
            Returns a activity-aware call stackIndex associated with'ouputStackSource' for the call stack associated with 'data'.
            Such activity-aware call stacks have pseudo-frame every time on thread causes another task to run code (because the  
            creator 'caused' the target code).
            
            If 'topFrames' is non-null, then this function is called with a Thread and is expected to return a CallStack index that
            represents the thread-and-process nodes of the stack.   This allows the returned stack to be have pseudo-frames 
            at the root of the stack.  Typically this is used to represent the 'request' or other 'global' context.   If it is not
            present the thread and process are used to form these nodes.  
            
            This needs to be a function mapping threads to the stack base rather than just the stack base  because in the presence 
            of activities the thread at the 'base' whose 'top' you want may not be the one that 'data' started with, so the caller 
            needs to be prepared to answer the question about any thread.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCallStackForActivity(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity,System.Func{Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex})">
            <summary>
            Returns a StackSource call stack associated with outputStackSource for the activity 'activity'   (that is the call stack at the 
            the time this activity was first created.   This stack will have it 'top' defined by topFrames (by default just the thread and process frames)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity)">
            <summary>
            This is not a call stack but rather the chain of ACTIVITIES (tasks), and can be formed even when call stacks   
            
            Returns a Stack Source stack associated with outputStackSource where each frame is a task starting with 'activity' and
            going back until the activity has no parent (e.g. the Thread's default activity).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ActivityComputer.NoCache">
            <summary>
            If set, we don't assume that the top top frames are an attribute of the TOP THREAD  (if they vary based on
            the current activity, then you can't cache.   Setting this disables caching.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.IsThreadParkedInThreadPool(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Returns true if the call stack is in the thread pool parked (not running user code)  
            This means that the thread CAN'T be running an active activity and we can kill it.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.OnCreated(Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind)">
            <summary>
            Creation handles ANY creation of a task.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.OnStop(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Activity can be null, which means we could not figure out the activity we are stopping.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetTPLRawID(Microsoft.Diagnostics.Tracing.TraceEvent,System.Int32,Microsoft.Diagnostics.Tracing.ActivityComputer.IDType)">
            <summary>
            Get a trace wide ID for a TPL event.   TPL tasks might be 'Scheduled' in the sense
            that it might run independently on another thread.  Tasks that do 'BeginWait and 'EndWait'
            are not scheduled.  The same ID might have both operating simultaneously (if you wait
            on a scheduled task).  Thus you need an independent ID for both.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCallStackWithActivityFrames(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity,System.Func{Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex})">
            <summary>
            if 'activity' has not creator (it is top-level), then return baseStack (near execution) followed by 'top' representing the thread-process frames.
            
            otherwise, find the fragment of 'baseStack' up to the point to enters the threadpool (the user code) and splice it to the stack of the creator
            of the activity and return that.  (thus returning your full user-stack).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.TrimETWFrames(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Trims off frames that call ETW logic and return.   If the pattern is not matched, we return  callStackIndex
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.IsRecursiveTask(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            If the stack from 'startStack' (closest to execution) through 'stopStack' is the same as 'baseStack' return a non-invalid frame 
            indicating that it is recursive and should be dropped.  The frame index returned is the name of the task on 'baseStack' that
            begins the recursion (so you can update it if necessary)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.SpliceStack(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Create a stack which is executing at 'startStack' and finds the region until 'stopStack', appending that (in order) to 'baseStack'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.FindThreadPoolTransition(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Returns the point in 'callStackIndex' where the CLR thread pool transitions from 
            a thread pool worker to the work being done by the threadpool.  
            
            Basically we find the closest to execution (furthest from thread-start) call to a 'Run' method
            that shows we are running an independent task.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.UpdateTaskMarkerFrame(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.String)">
            <summary>
            taskMarkerFrame must be a frame of the form STARTING TASK on Thread NN NN NN ..
            and newTaskID is NNN.   If newTaskID is in that set, then do nothing.  Otherwise update
            that frame node to include NNN.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.ResolveWellKnownSymbols">
            <summary>
            Used by TrimETWFrames and FindThreadPoolTransition to find particular frame names and place the information in 'm_methodFlags'
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ActivityComputer.m_methodFlags">
            <summary>
            We look for various well known methods inside the Task library.   This array maps method indexes 
            and returns a bitvector of 'kinds' of methods (Run, Schedule, ScheduleHelper).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ActivityComputer.Log">
            <summary>
            Returns the TraceLog that is associated with the computer (at construction time)
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.Create">
            <summary>
            Fires when an activity is first created (scheduled).   The activity exists, and has an ID, but has not run yet. 
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.Start">
            <summary>
            First when an activity starts to run (using a thread).  It fires after the start has logically happened.  
            so you are logically in the started activity.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.Stop">
            <summary>
            Fires when the activity ends (no longer using a thread).  It fires just BEFORE the task actually dies 
            (that is you ask the activity of the event being passed to 'Stop' it will still give the passed
            activity as the answer).   The first TraceActivity is the activity that was stopped, the second
            is the activity that exists afer the stop completes.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.AfterStop">
            <summary>
            Like OnStop but gets called AFTER the stop has completed (thus the current thread's activity has been updated)
            The activity may be null, which indicates a failure to look up the activity being stopped (and thus the
            thread's activity will be set to null).  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.AwaitUnblocks">
            <summary>
            AwaitUnblocks is a specialized form of the 'Start' event that fires when a task starts because
            an AWAIT has ended.   The start event also fires on awaits end and comes AFTER the AwaitUnblocks
            event has been delivered.    
            
            Not every AWAIT end causes a callback.  Because an AWAIT begin happens for every FRAME you only
            want a callback for the FIRST task (activity) created by parent of this activity.  This is what
            this callback does.  
            
            AwaitUnblocks are often treated differently because you want to consider the time between the begin 
            (Activity Created) and awaitUnbock to be accounted for as on the critical path, whereas for 'normal' 
            tasks you normally don't think that time is interesting.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ActivityComputer.Item(Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex)">
            <summary>
            Maps an activity index back to its activity.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache">
            <summary>
            This cache remembers Activity * CallStackIndex pairs and the result.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap">
            <summary>
            A very simple IDictionary-like interface for remembering values in GetCallStack()
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource">
            <summary>
            Like a TraceEventStackSource a MutableTraceEventStackSource allows you incorporate the stacks associated with
            a TraceEvent as a sample in the StackSource.   However in addition it allows you to create new frames for these
            stacks on the fly as well as add samples that did not exist in the original TraceEvent stream.   This gives you
            a lot of flexibility to add additional data to the original stream of TraceEvents.   
            
            Like TraceEventStackSource MutableTraceEventStackSource supports the GetFrameCodeAddress() method that  allows
            you to map from the StackSourceFrameIndex back its TraceLog code address (that lets you get at the source code and
            line number for that frame).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource">
            <summary>
            TraceEventStackSource is an implementation of a StackSource for ETW information (TraceLog)
            It takes a TraceEvents (which is a list of TraceEvents you get get from a TraceLog) and 
            implements that StackSource protocol for them.  (thus any code needing a StackSource 
            can then work on it.  
            
            The key to the implementation is how StackSourceFrameIndex and StackSourceCallStackIndex 
            (part of the StackSource protocol) are mapped to the Indexes in TraceLog.   Here is
            the mapping.
            
            TraceEventStackSource create the following meaning for the StackSourceCallStackIndex
            
            * The call stacks ID consists of the following ranges concatenated together. 
                * a small set of fixed Pseudo stacks (Start marks the end of these)
                * CallStackIndex
                * ThreadIndex
                * ProcessIndex
                * BrokenStacks (One per thread)
                * Stacks for threads without explicit stacks (Limited to 1K)
                    
            TraceEventStackSource create the following meaning for the StackSourceFrameIndex
            
            The frame ID consists of the following ranges concatenated together. 
                * a small fixed number of Pseudo frame (Broken, and Unknown)
                * MaxCodeAddressIndex - something with a TraceCodeAddress. 
                * ThreadIndex         - ETW stacks don't have a thread or process node, so we add them.
                * ProcessIndex
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSource">
            <summary>
            A stack source is a logically a list of StackSourceSamples.  Each sample has a metric and stack (hence the name StackSource)
            The stacks are represented as indexes that the  StackSourceStacks base class can resolve into frame names and stack chains.  
            The result is very efficient (no string processing) way of processing the conceptual list of stack samples.  
            </summary>    
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks">
            <summary>
            Samples have stacks (lists of frames, each frame contains a name) associated with them.  This interface allows you to get 
            at this information.  We don't use normal objects to represent these but rather give each stack (and frame) a unique
            (dense) index.   This has a number of advantages over using objects to represent the stack.
            
                * Indexes are very serialization friendly, and this data will be presisted.  Thus indexes are the natural form for data on disk. 
                * It allows the data to be read from the serialized format (disk) lazily in a very straightfoward fashion, keeping only the
                    hottest elements in memory.  
                * Users of this API can associate additional data with the call stacks or frames trivially and efficiently simply by
                    having an array indexed by the stack or frame index.   
                    
            So effectively a StackSourceStacks is simply a set of 'Get' methods that allow you to look up information given a Stack or
            frame index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Given a call stack, return the call stack of the caller.   This function can return StackSourceCallStackIndex.Discard
            which means that this sample should be discarded.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            For efficiency, m_frames are assumed have a integer ID instead of a string name that
            is unique to the frame.  Note that it is expected that GetFrameIndex(x) == GetFrameId(y) 
            then GetFrameName(x) == GetFrameName(y).   The converse does NOT have to be true (you 
            can reused the same name for distinct m_frames, however this can be confusing to your
            users, so be careful.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetNumberOfFoldedFrames(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            FilterStackSources can combine more than one frame into a given frame.  It is useful to know
            how many times this happened.   Returning 0 means no combining happened.  This metric does
            not include grouping, but only folding.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Get the frame name from the FrameIndex.   If 'verboseName' is true then full module path is included.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.StackDepth(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Computes the depth (number of callers), associated with callStackIndex.  This routine is O(n) and mostly useful for debugging.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.ToString(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample,System.Text.StringBuilder)">
            <summary>
            Returns an XML string representation of a 'sample'.  For debugging. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.ToString(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Returns an XML string representation of a 'callStackIndex'.  For debugging. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.CallStackIndexLimit">
            <summary>
            all StackSourceCallStackIndex are guaranteed to be less than this.  Allocate an array of this size to associate side information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.CallFrameIndexLimit">
            <summary>
            all StackSourceFrameIndex are guaranteed to be less than this.  Allocate an array of this size to associate side information
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ProduceSamples(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Call 'callback' on every sample in the StackSource.   Will be done linearly and only
            one callback will be active simultaneously.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Call 'callback' on every sample in the StackSource.   Will be done linearly and only
            one callback will be active simultaneously.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ParallelForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample},System.Int32)">
            <summary>
            Also called 'callback' on every sample in the StackSource however there may be more than
            one callback running simultaneously.    Thus 'callback' must be thread-safe and the order
            of the samples should not matter.   If desiredParallelism == 0 (the default) then the 
            implementation will choose a good value of parallelism. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            If this source supports fetching the samples by index, this is how you get it.  Like ForEach the sample that
            is returned is not allowed to be modified.   Also the returned sample will become invalid the next time GetSampleIndex
            is called (we reuse the StackSourceSample on each call)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.GetReferences(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,Microsoft.Diagnostics.Tracing.Stacks.RefDirection,System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex})">
            <summary>
            Only used if IsGraphSource==true.   If 'direction' is 'From' Calls 'callback' for node that is referred to FROM nodeIndex.
            If 'direction' is 'To' then it calls 'callback' for every node that refers TO nodeIndex.  This API returns references 
            that are not necessarily a tree (they can for DAGs or have cycles).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.Dump(System.String)">
            <summary>
            Dump the stack source to a file as XML.   Used for debugging.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.Dump(System.IO.TextWriter)">
            <summary>
            Dump the stack source to a TextWriter as XML.   Used for debugging.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SamplesImmutable">
            <summary>
            If this is overridden to return true, then during the 'Foeach' callback you can save references
            to the samples you are given because they will not be overridden by the stack source.  If this is
            false you must make a copy of the sample if you with to remember it.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.BaseStackSource">
            <summary>
            If this stack source is a source that simply groups another source, get the base source.  It will return
            itself if there is no base source.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SampleIndexLimit">
            <summary>
            Returns the limit on stack samples indexes (all index are strictly less than this).  Returns 0 if unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Returns a time which is greater than or equal the timestamp of any sample in the StackSource.   Returns 0 if unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ScenarioCount">
            <summary>
            In addition to Time and Metric a sample can have a Scneario number associated with it.   ScenarioCount 
            returns the number of such scnearios.   Returning 0 implies no scenario support.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SamplingRate">
            <summary>
            StackSources can optionally support a sampling rate.   If the source supports it it will return
            non-null for the current sampling rate (1 if it is doing nothing).    Sampling is a way of speeding
            things up.  If you sample at a rate of 10, it means that only one out of every 10 samples is actually
            produced by 'ForEach'.   Note that it is expected that when the sampling rate is set the 
            source will correspondingly adjust the CountMultiplier, so that the total will look like no sampling
            is occuring 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.IsGraphSource">
            <summary>
            If each 'callstack' is really a node in a graph (like MemoryGraphStackSource)
            Then return true.  If this returns true 'GetRefs' works. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceEvents)">
            <summary>
            Creates a new TraceEventStackSource given a list of events 'events' from a TraceLog
            </summary>
            <param name="events"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.LookupWarmSymbols(System.Int32,Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Looks up symbols for all modules that have an inclusive count >= minCount. 
            stackSource, if given, can be used to be the filter.  If null, 'this' is used.
            If stackSource is given, it needs to use the same indexes for frames as 'this'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetFrameCodeAddress(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Given a frame index, return the corresponding code address for it.  This is useful for looking up line number information. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetSourceLine(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Symbols.SymbolReader)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetModulesForStack(Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ModuleList[],Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Returns a list of modules for the stack 'stackIdx'.  It also updates the interning table stackModuleLists, so 
            that the entry cooresponding to stackIdx remembers the answer.  This can speed up processing alot since many
            stacks have the same prefixes to root.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.m_pseudoStacksTable">
            <summary>
            This maps pseudo-stacks to their index (thus it is the inverse of m_pseudoStack; 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetPseudoStack(Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex,Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a thread and a call stack that does not have a stack, make up a pseudo stack for it consisting of the code address, 
            the broken node, the thread and process.   Will return -1 if it can't allocate another Pseudo-stack.
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.TraceLog">
            <summary>
            Returns the TraceLog file that is associated with this stack source.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ShowUnknownAddresses">
            <summary>
            Normally addresses without symbolic names are listed as ?, however sometimes it is useful 
            to see the actuall address as a hexidecimal number.  Setting this will do that.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.CallStackIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ModuleList">
            <summary>
            A ModuleList is a linked list of modules.  It is only used in GetModulesForStack and LookupWarmSymbols
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Create a new MutableTraceEventStackSource that can represent stacks comming from any events in the given TraceLog with a stack.  
            You use the 'AddSample' and 'DoneAddingSamples' to specify exactly which stacks you want in your source.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.AddSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            After creating a MultableTraceEventStackSource, you add the samples you want using this AddSample API (you can reuse 'sample' 
            used as an argument to this routine.   It makes a copy.  The samples do NOT need to be added in time order (the MultableTraceEventStackSource
            will sort them).   When you done DoneAddingSamples must be called before using the
            the MutableTraceEventStackSource as a stack source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.DoneAddingSamples">
            <summary>
            After calling 'AddSample' to add the samples that should belong to the source, DoneAddingSamples() should be called to
            to complete the construction of the stack source.   Only then can the reading API associated with the stack source be called. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStackForProcess(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess)">
            <summary>
            Returns a StackSourceCallStackIndex representing just one entry that represents the process 'process'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStackForThread(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Returns a StackSourceCallStackIndex representing just two entries that represent 'thread' which has a parent of its process.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStackThread(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Returns a StackSourceCallStackIndex representing the call stack from the TraceLog represented by the CallStackIndex 'callStackIndex'.  
            If that stack is invalid, use 'thread' to at least return a call stack for the thread.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStack(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Returns a StackSourceCallStackIndex representing the call stack from the TraceLog represented by the CallStackIndex 'callStackIndex'.  
            Use the TraceEvent 'data' to find the stack if callStackIndex is invalid.  
            TODO data should be removed (or callstack derived from it) 
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStack(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap)">
            <summary>
            Find the StackSourceCallStackIndex for the TraceEvent call stack index 'callStackIndex' which has a top of its 
            stack (above the stack, where the thread and process would normally go) as 'top'.  If callStackMap is non-null 
            it is used as an interning table for CallStackIndex -> StackSourceCallStackIndex.  This can speed up the 
            transformation dramatically.   It will still work if it is null.  
            </summary>
            
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Create a frame name from a TraceLog code address.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetModuleIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.m_Interner">
            <summary>
            private
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.m_emptyModuleIdx">
            <summary>
            private
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.Interner">
            <summary>
            The Interner is the class that allows you to make new indexes out of strings and other bits.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.SampleIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.SamplesImmutable">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap">
            <summary>
            A very simple IDictionary-like interface for remembering values in GetCallStack()
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap.Get(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Fetches an value given a key
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap.Put(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Sets a key-value pair
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache.CurrentActivityIndex">
            <summary>
            Remembers the current Activity for 'Get' and 'Put' operations.   Needs to be set before Get or Put is called.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache.Get(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Gets the cache entry for the CurrnetActivityIndex with the call stack 'fromStackIndex'  returns Invalid if
            there is no entry.   
            
            This is not passed the CurrentActivityIndex, so it can implement the CallStackMap interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache.Put(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            updates the cache entry for the CurrnetActivityIndex with the call stack 'fromStackIndex'  with the value 
            'toStackIndex'
            
            This is not passed the CurrentActivityIndex, so it can implement the CallStackMap interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.GCReferenceID">
            <summary>
            A small number that you can get from the GetReferenceForGCAddress that is
            invariant as the GC address moves around during GCs.   Because this index
            is small it can be used to store information about the GC reference in a
            side growable array.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.GCReferenceID.Dead">
            <summary>
            Indicates that the address is no longer alive.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.GCReferenceComputer">
            <summary>
            This computer will keep track of GC references as they change over time 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.GCReferenceComputer.#ctor(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Create a new GCRefernece computer from the stream of events 'source'.   When 'source' is processed
            you can call 'GetReferenceForGCAddress' to get stable ids for GC references.  
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.GCReferenceComputer.GetReferenceForGCAddress(System.UInt64)">
            <summary>
            Get a stable ID for a GcAddress.  This ID can be compared for object identity.
            This only works at the current point in time when scanning the source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.GCReferenceComputer.DisposeGCReference(Microsoft.Diagnostics.Tracing.GCReferenceID)">
            <summary>
            If you no longer need to track the GC reference, call this function to remove the tracking.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ServerRequestComputer">
            <summary>
            Calculates stacks grouping them by the server request (e.g. ASP.NET) request they are for)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ServerRequestComputer.#ctor(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Create a new ServerRequest Computer.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ServerRequestComputer.GetCurrentRequest(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            The server request that we currently processing
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ServerRequest">
            <summary>
            A ServerRequest contains all the information we know about a server request (e.g. ASP.NET request)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ServerRequest.Url">
            <summary>
            Any URL associated with the request
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ServerRequest.ID">
            <summary>
            If the request has a GUID associated with it to uniquely identify it, this is it
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ServerRequest.StartTime">
            <summary>
            The time that the request started (or the earliest that we know about it)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivityComputer">
            <summary>
            Calculates start-stop activities (computes duration),  It uses the 'standard' mechanism of using 
            ActivityIDs to corelate the start and stop (and any other events between the start and stop, 
            and use the RelatedActivityID on START events to indicate the creator of the activity, so you can
            form nested start-stop activities.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource,Microsoft.Diagnostics.Tracing.ActivityComputer)">
            <summary>
            Create a new ServerRequest Computer.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetCurrentStartStopActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            The current start-stop activity on the given thread.   
            If present 'context' is used to look up the current activityID and try to use that to repair missing Starts.  
            Basically if we can't figure out what StartStop activity the thread from just the threadID we can use the activityID 
            from the 'context' event to find it as a backup.     
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetStartStopActivityForActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceActivity)">
            <summary>
            Gets the current Start-Stop activity for a given TraceActivity.  
            </summary>
            <param name="curActivity"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetCurrentStartStopActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,System.Boolean)">
            <summary>
            Returns a stack index representing the nesting of Start-Stop activities for the thread 'curThread' at the current time
            (At this point of the current event for the computer).   The stack starts with a frame for the process of the thread, then 
            has all the start-stop activity frames, then a frame representing 'topThread' which may not be the same as 'thread' since
            'topThread' is the thread that spawned the first task, not the currently executing thread.  
            
            Normally this stack is for the current time, but if 'getAtCreationTime' is true, it will compute the
            stack at the time that the current activity was CREATED rather than the current time.  This works 
            better for await time
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetStartStopActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.StartStopActivity,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess)">
            <summary>
            Gets a stack that represents the nesting of the Start-Stop tasks.  curActivity can be null, in which case just he process node is returned.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.Start">
            <summary>
            If set, called AFTER a Start-Stop activity starts, called with the activity and the event that caused the start. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.Stop">
            <summary>
            If set, called BEFORE a Start-Stop activity stops, called with the activity and the event that caused the start. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.IsActivityPath(System.Guid)">
            <summary>
            Returns true if 'guid' follow the EventSouce style activity IDs. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.ActivityPathString(System.Guid)">
            <summary>
            returns a string representation for the activity path.  If the GUID is not an activity path then it returns
            the normal string representation for a GUID. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.DoStopIfNecessary">
            <summary>
            We don't do a stop all processing associated with the stop event is done.  Thus if we are not 'on'
            the stop event, then you can do any deferred processing.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.FixAndProcessWindowsASP(Microsoft.Diagnostics.Tracing.TraceEvent,System.Collections.Generic.KeyValuePair{System.Guid,System.Guid}[])">
            <summary>
            fix ASP.NET receiving events  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetActiveStartStopActivityTable(System.Guid,System.Int32)">
            <summary>
            Look up a start-stop activity by its ID.   Note that the 'activityID' needs to be unique for that instance 
            within a process.  (across ALL start-stop activities, which means it may need components that encode its 
            provider and task).   We pass the process ID as well so that it will be unique in the whole trace.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.NumberListCodes">
            <summary>
            The encoding for a list of numbers used to make Activity  Guids.   Basically
            we operate on nibbles (which are nice because they show up as hex digits).  The
            list is ended with a end nibble (0) and depending on the nibble value (Below)
            the value is either encoded into nibble itself or it can spill over into the
            bytes that follow.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivityIndex">
            <summary>
            An dense number that defines the identity of a StartStopActivity.  Used to create side arrays 
            for StartStopActivity info.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StartStopActivityIndex.Illegal">
            <summary>
            An illegal index, sutable for a sentinal.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivity">
            <summary>
            A StartStop reresents an activity between a start and stop event as generated by EvetSource.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivity.GetActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Returns a stack on the outputStackSource which has a frame for each activity that
            caused this activity, as well as the root of the given 'rootStack' (often a stack representing the process).    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivity.ToString">
            <summary>
            override.   Gives the name and start time.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivity.RememberStop(Microsoft.Diagnostics.Tracing.EventIndex,System.Double,Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex)">
            <summary>
            We don't update the state for the stop at the time of the stop, but at the next call to any of the StartStopActivityComputer APIs.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.Index">
            <summary>
            The index (small dense numbers suitabilty for array indexing) for this activity. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.Name">
            <summary>
            The name of the activity (The Task name for the start-stop event as well as the activity ID)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ExtraInfo">
            <summary>
            If the activity has additional information associated with it (e.g. a URL), put it here.  Can be null.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.TaskName">
            <summary>
            The Task name (the name prefix that is common to both the start and stop event)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ProcessID">
            <summary>
            The processID associated with this activity
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ActivityID">
            <summary>
            The Activity ID (as a GUID) that matches the start and stop together. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ActivityPathString">
            <summary>
            The path of creators that created this activity.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.Creator">
            <summary>
            The start-stop activity that created this activity (thus it makes a tree)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.StartEventIndex">
            <summary>
            The TraceLog event Index, of the start event (you can get addition info)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.StopEventIndex">
            <summary>
            The TraceLog event Index, of the stop event (you can get addition info)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.StartTimeRelativeMSec">
            <summary>
            The time in MSec from the start of the trace when the start event happened. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.DurationMSec">
            <summary>
            The duration of activity in MSec (diff between stop and start)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.IsStopped">
            <summary>
            This activity has completed (the Stop event has been received).  Thus Duration is valid.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TcpIpComputer">
            <summary>
            A TcpIpComputer keeps track of TCP/IP connections so that you can correlate individual reads and
            writes with the connection info (like the IP address of each end), as well as data packets being
            sent (if you have packet capture turned on).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TcpIpComputer.#ctor(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Create a new GCRefernece computer from the stream of events 'source'.   When 'source' is processed
            you can call 'GetReferenceForGCAddress' to get stable ids for GC references.  
            </summary>
            <param name="source"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer">
            <summary>
            A ThreadTimeComputer does a simple simulation of what each thread is doing to create stack events that represent 
            CPU, blocked time, disk and Network activity.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Symbols.SymbolReader)">
            <summary>
            Create a new ThreadTimeComputer
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.UseTasks">
            <summary>
            If set we compute thread time using Tasks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.BlockedTimeOnly">
            <summary>
            If set we compute blocked time 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.ExcludeReadyThread">
            <summary>
            If set we don't show ready thread information 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GroupByAspNetRequest">
            <summary>
            If set we group by ASP.NET Request
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.MiniumReadiedTimeMSec">
            <summary>
            If we spend less then this amount of time waiting for the CPU, don't bother showing it.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GroupByStartStopActivity">
            <summary>
            LIke the GroupByAspNetRequest but use start-stop activities instead of ASP.NET Requests as the grouping construct. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GenerateThreadTimeStacks(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource)">
            <summary>
            Generate the thread time stacks, outputting to 'stackSource'.  
            </summary>
            <param name="outputStackSource"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.UpdateThreadToWorkOnStartStopActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.StartStopActivity,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Updates it so that 'thread' is now working on newStartStop, which can be null which means that it is not working on any 
            start-stop task. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.OnSampledProfile(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            This can actually be called with any event that has a stack.   Basically it will log a CPU sample whose
            size is the time between the last such call and the current one.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetCallStack(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Get the call stack for 'data'  Note that you thread must be data.Thread().   We pass it just to save the lookup.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetTopFramesForActivityComputerCase(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,System.Boolean)">
            <summary>
            Returns a function that figures out the top (closest to stack root) frames for an event.  Often
            this returns null which means 'use the normal thread-process frames'. 
            Normally this stack is for the current time, but if 'getAtCreationTime' is true, it will compute the
            stack at the time that the current activity was CREATED rather than the current time.  This works 
            better for await time.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetAspNetGuid(Microsoft.Diagnostics.Tracing.Etlx.TraceActivity)">
            <summary>
            Given and activity, return the ASP.NET Guid associated with it (or Guid.Empty if there is not one). 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetAspNetFromProcessFrameThroughThreadFrameStack(System.Guid,Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Computes the ASP.NET Pseudo frames from the process frame through the thread frame (which includes all 
            the pseudo-frames for the ASP.NET groupings. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.TransferAspNetRequestToThread(System.Guid,Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex,System.String)">
            <summary>
            Indicates that the aspNet request represented by aspNetGuid is now being  handled by the thread with index 
            newThreadIndex.  Thus any old threads handling this request are 'cleared' and replaced with 'newThreadIndex'
            If 'newThreadIndex == Invalid then the entry for aspNetGuid is removed.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GenerateReadyThreadNodes(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,System.Double,System.Int32)">
            <summary>
            Generate a stack that from the root looks like 'stackIndex followed by 'READIED BY TID(XXXX)' 
            followed by frames of 'readyThreadCallStack' (suffixed by READIED_BY)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_unknownTimeStartMsec">
            <summary>
            Used to create UNKNOWN frames for start-stop activities.   This is indexed by StartStopActivityIndex.
            and for each start-stop activity indicates when unknown time starts.   However if that activity still
            has known activities associated with it then the number will be negative, and its value is the 
            ref-count of known activities (thus when it falls to 0, it we set it to the start of unknown time. 
            This is indexed by the TOP-MOST start-stop activity.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_threadToStartStopActivity">
            <summary>
            maps thread ID to the current TOP-MOST start-stop activity running on that thread.   Used to updated m_unknownTimeStartMsec 
            to figure out when to put in UNKNOWN_ASYNC nodes.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_startStopActivityToAsyncUnknownSamples">
            <summary>
            Sadly, with AWAIT nodes might come into existance AFTER we would have normally identified 
            a region as having no thread/await working on it.  Thus you have to be able to 'undo' ASYNC_UNKONWN
            nodes.   We solve this by remembering all of our ASYNC_UNKNOWN nodes on a list (basically provisional)
            and only add them when the start-stop activity dies (when we know there can't be another AWAIT.  
            Note that we only care about TOP-MOST activities.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_IRPToThread">
            <summary>
            m_IRPToThread maps the I/O request to the thread that initiated it.  This way we can associate
            the disk read size and file with the thread that asked for it.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_threadIDUsingProc">
            <summary>
            Maps processor number to the OS threadID of the thread that is using it.   Allows you 
            to determine how (CPU) idle the machine is.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_numIdleProcs">
            <summary>
            Using m_threadIDUsingProc, we compute how many processor are current doing nothing 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.ThreadState">
            <summary>
            Represents all the information that we need to track for each thread.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.NetworkInfo">
            <summary>
             NetworkInfo remembers useful information to tag blocked time that seems to be network related. 
             It is the value of the m_lastPacketForProcess table mapping threads to network information. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.AspNetRequestInfo">
            <summary>
            AspNetRequestInfo remembers everything we care about associate with an single ASP.NET request.  
            It is the value of the m_aspNetRequestInfo table. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.NewThreadTimeComputer.Log">
            <summary>
            Returns the TraceLog that is associated with the computer (at construction time)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource">
            <summary>
            ETWReloggerTraceEventSource is designed to be able to write ETW files using an existing ETW input stream (either a file, files or real time session) as a basis. 
            The relogger capabilities only exist on Windows 8 OSes and beyond.  
            
            The right way to think about this class is that it is just like ETWTraceEventSource, but it also has a output file associated with it, and WriteEvent APIs that
            can be used to either copy events from the event stream (the common case), or inject new events (high level stats).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventDispatcher">
            <summary>
            A TraceEventDispatcher is a TraceEventSource that supports a callback model for dispatching events.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventSource">
            <summary>
            TraceEventSource is an abstract base class that represents the output of a ETW session (e.g. a ETL file 
            or ETLX file or a real time stream).   This base class is NOT responsible for actually processing
            the events, but contains methods for properties associated with the session
            like its start and end time, filename, and characteristics of the machine it was collected on.
            <para>This class has two main subclasses:</para>
            <para>* <see cref="T:Microsoft.Diagnostics.Tracing.TraceEventDispatcher"/> which implements a 'push' (callback) model and is the only mode for ETL files.  
            ETWTraceEventSource is the most interesting subclass of TraceEventDispatcher.</para>
            <para>* see TraceLog which implements both a 'push' (callback) as well as pull (foreach) model but only works on ETLX files.</para>
            <para>This is the end.</para>
            <para>The normal user pattern is to create a TraceEventSource, create TraceEventParsers attached to the TraceEventSource, and then subscribe
            event callbacks using the TraceEventParsers</para>
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ITraceParserServices">
            <summary>
            TraceEventSource has two roles.  The first is the obvious one of providing some properties
            like 'SessionStartTime' for clients.  The other role is provide an interface for TraceEventParsers
            to 'hook' to so that events can be decoded.  ITraceParserServices is the API service for this
            second role.  It provides the methods that parsers register templates for subclasses of 
            the TraceEvent class that know how to parse particular events.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.RegisterEventTemplate(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            RegisterEventTemplate is the mechanism a particular event payload description 'template' 
            (a subclass of TraceEvent) is injected into the event processing stream. Once registered, an
            event is 'parsed' simply by setting the 'rawData' field in the event. It is up to the template
            then to take this raw data an present it in a useful way to the user (via properties). Note that
            parsing is thus 'lazy' in no processing of the raw data is not done at event dispatch time but
            only when the properties of an event are accessed.
            
            Ownership of the template transfers when this call is made.   The source will modify this and
            assumes it has exclusive use (thus you should clone the template if necessary).  
            <para>
            Another important aspect is that templates are reused by TraceEventSource aggressively. The
            expectation is that no memory needs to be allocated during a normal dispatch 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.UnregisterEventTemplate(System.Delegate,System.Int32,System.Guid)">
            <summary>
            UnregisterEventTemplate undoes the action of RegisterEventTemplate.   Logically you would 
            pass the template to unregister, but typically you don't have that at unregistration time.
            To avoid forcing clients to remember the templates they registered, UnregisterEventTemplate
            takes three things that will uniquely identify the template to unregister.   These are
            the eventID, and provider ID and the Action (callback) for the template.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.RegisterParser(Microsoft.Diagnostics.Tracing.TraceEventParser)">
            <summary>
            It is expected that when a subclass of TraceEventParser is created, it calls this
            method on the source.  This allows the source to do any Parser-specific initialization.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.RegisterUnhandledEvent(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.Boolean})">
            <summary>
            Indicates that this callback should be called on any unhandled event.   The callback
            returns true if the lookup should be retried after calling this (that is there is
            the unhandled event was found).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.TaskNameForGuid(System.Guid)">
            <summary>
            Looks if any provider has registered an event with task with 'taskGuid'. Will return null if
            there is no registered event.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.ProviderNameForGuid(System.Guid)">
            <summary>
            Looks if any provider has registered with the given GUID OR has registered any task that matches
            the GUID. Will return null if there is no registered event.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.Dispose">
            <summary>
            Closes any files and cleans up any resources associated with this TraceEventSource
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.QPCTimeToRelMSec(System.Int64)">
            <summary>
            Converts the Query Performance Counter (QPC) ticks to a number of milliseconds from the start of the trace.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.RelativeMSecToQPC(System.Double)">
            <summary>
            Converts a Relative MSec time to the Query Performance Counter (QPC) ticks 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.UTCDateTimeToQPC(System.DateTime)">
            <summary>
            Converts a DateTime to the Query Performance Counter (QPC) ticks 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.QPCTimeToDateTimeUTC(System.Int64)">
            <summary>
            Converts the Query Performance Counter (QPC) ticks to a DateTime  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.LastChanceGetThreadID(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Some events (like HardFault) do not have a thread ID or a process ID, but they MIGHT have a Stack
            If they do try to get the ThreadID for the event from that.  Return -1 if not successful.   
            This is intended to be overridden by the TraceLog class that has this additional information. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Kernel">
            <summary>
            For convenience, we provide a property returns a KernelTraceEventParser that knows 
            how to parse all the Kernel events into callbacks.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Clr">
            <summary>
            For convenience, we provide a property returns a ClrTraceEventParser that knows 
            how to parse all the Common Language Runtime (CLR .NET) events into callbacks.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Dynamic">
            <summary>
            For convenience, we provide a property returns a DynamicTraceEventParser that knows 
            how to parse all event providers that dynamically log their schemas into the event streams.
            In particular, it knows how to parse any events from a System.Diagnostics.Tracing.EventSources. 
            
            Note that the DynamicTraceEventParser has subsumed the functionality of RegisteredTraceEventParser
            so any registered providers are also looked up here.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Registered">
            <summary>
            For convenience, we provide a property returns a RegisteredTraceEventParser that knows 
            how to parse all providers that are registered with the operating system.
            
            Because the DynamicTraceEventParser has will parse all providers that that RegisteredTraceEventParser
            will parse, this function is obsolete, you should use Dynamic instead.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionStartTime">
            <summary>
            The time when session started logging. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionEndTime">
            <summary>
            The time that the session stopped logging.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionEndTimeRelativeMSec">
            <summary>
            The Session End time expressed as milliseconds from the start of the session
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionDuration">
            <summary>
            The difference between SessionEndTime and SessionStartTime;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Size">
            <summary>
            The size of the trace, if it is known.  Will return 0 if it is not known.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.PointerSize">
            <summary>
            Returns the size of a pointer on the machine where events were collected (4 for 32 bit or 8 for 64 bit)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.EventsLost">
            <summary>
            The number of events that were dropped (e.g. because the incoming event rate was too fast)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.NumberOfProcessors">
            <summary>
            The number of processors on the machine doing the logging. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.CpuSpeedMHz">
            <summary>
            Cpu speed of the machine doing the logging. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.OSVersion">
            <summary>
            The version of the windows operating system on the machine doing the logging.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.IsRealTime">
            <summary>
            Returns true if this is a real time session.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.UserData">
            <summary>
            TraceEventSource supports attaching arbitrary user data to the source.  This property returns a key-value bag of these attached values.  
            <para>
            One convention that has been established is that TraceEventParsers that need additional state to parse their events should
            store them in UserData under the key 'parsers\(ParserName)' 
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.QPCFreq">
            <summary>
            This is the high frequency tick clock on the processor (what QueryPerformanceCounter uses).  
            You should not need 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Process">
            <summary>
            Once a client has subscribed to the events of interest, calling Process actually causes
            the callbacks to happen.   
            <para>
            Subclasses implementing this method should call 'OnCompleted' 
            before returning.  
            </para>
            </summary>
            <returns>false If StopProcessing was called</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.StopProcessing">
            <summary>
            Calling StopProcessing in a callback when 'Process()' is running will indicate that processing
            should be stopped immediately and that the Process() method should return.  
            
            Note that this stop request will not be honored until the next event from the source.   Thus
            for real time sessions there is an indeterminate delay before the stop will complete.   
            If you need to force the stop you should instead call Dispose() on the session associated with 
            the real time session.  This will cause the source to be shut down and thus also stop processing
            (Process() will return) but is guaranteed to complete in a timely manner.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.OnCompleted">
            <summary>
            Called when processing is complete.  You can call this more than once if your not sure if it has already been called.  
            however we do guard against races.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.DistinctCallbackCount">
            <summary>
             Number of different events that have callbacks associated with them 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.CallbackCount">
            <summary>
            Total number of callbacks that are registered.  Even if they are for the same event.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Dispatch(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            This is the routine that is called back when any event arrives.  Basically it looks up the GUID
            and the opcode associated with the event and finds right subclass of TraceEvent that
            knows how to decode the packet, and calls its virtual TraceEvent.Dispatch method.  Note
            that TraceEvent does NOT have a copy of the data, but rather just a pointer to it. 
            This data is ONLY valid during the callback. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Lookup(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD*)">
            <summary>
            Lookup up the event based on its ProviderID (GUID) and EventId (Classic use the TaskId and the
            Opcode field for lookup, but use these same fields (see ETWTraceEventSource.RawDispatchClassic)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Dispose(System.Boolean)">
            <summary>
            Dispose pattern. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Finalize">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Insert(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Inserts 'template' into the hash table, using 'providerGuid' and and 'eventID' as the key. 
            For Vista ETW events 'providerGuid' must match the provider GUID and the 'eventID' the ID filed.
            For PreVist ETW events 'providerGuid must match the task GUID the 'eventID' is the Opcode
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.GenTaskGuidFromProviderGuid(System.Guid,System.UInt16)">
            <summary>
            A helper for creating a set of related guids (knowing the providerGuid can can deduce the
            'taskNumber' member of this group.  All we do is add the taskNumber to GUID as a number.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.UnhandledEvents">
            <summary>
            Subscribers to UnhandledEvent are called if no other hander has processed the event.   It is
            generally used in DEBUG builds to validate that events are getting to the source at all.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.AllEvents">
            <summary>
            Subscribers to EveryEvent are called on every event in the trace.   Normally you don't want
            to subscribe to this but rather use a TraceEvenParser (which knows how to decode the payloads)
            and subscribe to particular events through that.   For example Using TraceEventSource.Dynamic.All 
            or TraceEventSource.Dynamic.All is more likely to be what you are looking for.   AllEvents is only
            an event callback of last resort, that only gives you the 'raw' data (common fields but no
            payload).  
            <para>
            This is called AFTER any event-specific handlers.
            </para>
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.UnhandledEvent">
            <summary>
            Subscribers to UnhandledEvent are called if no other hander has processed the event.   It is
            generally used in DEBUG builds to validate that events are getting to the source at all.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.EveryEvent">
            <summary>
            Subscribers to EveryEvent are called on every event in the trace.   Normally you don't want
            to subscribe to this but rather use a TraceEvenParser and subscribe to particular events
            through that.   
            <para>
            This is called AFTER any event-specific handlers.
            </para>
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Completed">
            <summary>
            Subscribers of Completed will be called after processing is complete (right before TraceEventDispatcher.Process returns.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.#ctor(System.String,System.String)">
            <summary>
            Create an ETWReloggerTraceEventSource that can takes its input from the family of etl files inputFileName
            and can write them to the ETL file outputFileName (.kernel*.etl, .user*.etl .clr*.etl)
            
            This is a shortcut for  ETWReloggerTraceEventSource(inputFileName, TraceEventSourceType.MergeAll, outputFileStream)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.#ctor(System.String,Microsoft.Diagnostics.Tracing.TraceEventSourceType,System.String)">
            <summary>
            Create an ETWReloggerTraceEventSource that can takes its input from a variety of sources (either a single file,
            a set of files, or a real time ETW session (based on 'type'), and can write these events to a new ETW output
            file 'outputFileName. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.WriteEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Writes an event from the input stream to the output stream of events. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.ConnectEventSource(System.Diagnostics.Tracing.EventSource)">
            <summary>
            Connect the given EventSource so any events logged from it will go to the output stream of events.   
            Once connected, you may only write events from this EventSource while processing the input stream
            (that is during the callback of an input stream event), because the context for the EventSource event
            (e.g. timestamp, proesssID, threadID ...) will be derived from the current event being processed by
            the input stream.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.Process">
            <summary>
            implementing TraceEventDispatcher
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.Dispose(System.Boolean)">
            <summary>
            Implements TraceEventDispatcher.Dispose
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.StopProcessing">
            <summary>
            Implements TraceEventDispatcher.StopProcessing
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.OutputUsesCompressedFormat">
            <summary>
            The output file can use a compressed form or not.  Compressed forms can only be read on Win8 and beyond.   Defaults to true.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.EventsLost">
            <summary>
            implementing TraceEventDispatcher
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.ReloggerEventListener">
            <summary>
            This is used by the ConnectEventSource to route events from the EventSource to the relogger. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.ReloggerCallbacks">
            <summary>
            This is the class the Win32 APIs call back on.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventHandler">
            <summary>
            An EventCounterStatisticsChangedEventHandler is a callback one can write to respond to the event when event counter statistics arrives.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventCounterHandler">
            <summary>
            An EventCounterHandler is the mechanism to obtain EventCounter statistics
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventCounterHandler.AddCounterStatisticsChangedEventHandler(System.String,System.String,Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventHandler)">
            <summary>
            Adds the counter statistics changed event handler.
            Four modes of operations are possible with this:
            counterName is null and statisticsName is null, in this case, you will get a callback for every event counter statistics
            counterName is NOT null and statisticsName is null, in this case, you will get a callback for every event counter statistics that matches the counter name
            counterName is null and statisticsName is NOT null, in this case, you will get a callback for every event counter statistics that matches the statistics name
            counterName is NOT null and statisticsName is NOT null, in this case, you will get a callback for every event counter statistics that matches both the counter name and the statistics name
            </summary>
            <param name="counterName">Name of the counter.</param>
            <param name="statisticsName">Name of the statistics.</param>
            <param name="counterStatisticsChangedEventHandler">The counter statistics changed event handler.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventCounterHandler.TryGetEventCounterValue(System.String,System.String,System.Single@)">
            <summary>
            Try to get the event counter value.
            </summary>
            <param name="counterName">Name of the counter.</param>
            <param name="statisticsName">Name of the statistics.</param>
            <param name="statisticsValue">The statistics value.</param>
            <returns>True if the operation succeed.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventArgs">
            <summary>
            Event Counter Statistics Changed Event Args
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventArgs.#ctor(System.String,System.String,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventArgs"/> class.
            </summary>
            <param name="counterName">Name of the counter.</param>
            <param name="statisticsName">Name of the statistics.</param>
            <param name="statisticsValue">The statistics value.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventArgs.CounterName">
            <summary>
            Gets the name of the counter.
            </summary>
            <value>
            The name of the counter.
            </value>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventArgs.StatisticsName">
            <summary>
            Gets the name of the statistics.
            </summary>
            <value>
            The name of the statistics.
            </value>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventCounterStatisticsChangedEventArgs.StatisticsValue">
            <summary>
            Gets the statistics value.
            </summary>
            <value>
            The statistics value.
            </value>
        </member>
        <member name="T:NativeDlls">
            <summary>
            Finds native DLLS next to the managed DLL that uses them.   
            </summary>
        </member>
        <member name="M:NativeDlls.LoadNative(System.String)">
            <summary>
            Loads a native DLL with a filename-extention of 'simpleName' by adding the path of the currently executing assembly
            
            </summary>
            <param name="simpleName"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventParser">
            <summary>
            TraceEventParser Represents a class that knows how to decode particular set of events (typically
            all the events of a single ETW provider).  It is expected that subclasses of TraceEventParser 
            have a constructor that takes a TraceEventSource as an argument that 'attaches' th parser 
            to the TraceEventSource.  TraceEventParsers break into two groups.
            <para>
            * Those that work on a single provider, and thus the provider name is implicit in th parser.  This is the common case.
            The AddCallbackForEvent* methods are meant to be used for these TraceEventParsers</para>
            <para>
            * Those that work on multiple providers.  There are only a handful of these (DynamicTraceEventParser, ...). 
            The AddCallbackForProviderEvent* methods which take 'Provider' parameters are meant to be used for these TraceEventParsers
            </para>
            <para>
            In addition to the AddCallback* methods on TraceEventParser, there are also Observe* extension methods that
            provide callbacks using the IObservable style.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvent``1(System.String,System.Action{``0})">
            <summary>
            A shortcut that adds 'callback' in the provider associated with this parser (ProvderName) and an event name 'eventName'.  'eventName'
            can be null in which case any event that matches 'Action{T}' will call the callback.    
            'eventName is of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'.   
            <para>
            The callback alone is used as the subscription id for unregistration, so the callback delegate should be unique (by delegate comparison)
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvents``1(System.Action{``0})">
            <summary>
            Causes 'callback' to be called for any event in the provider associated with this parser (ProviderName) whose type is compatible with T and 
            whose eventName will pass 'eventNameFilter'.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvents``1(System.Predicate{System.String},System.Action{``0})">
            <summary>
            Causes 'callback' to be called for any event in the provider associated with this parser (ProviderName) whose type is compatible with T and 
            whose eventName will pass 'eventNameFilter'.    The eventNameFilter parameter can be null, in which case all events that are compatible 
            with T will be selected. 
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvents``1(System.Predicate{System.String},System.Object,System.Action{``0})">
            <summary>
            Causes 'callback' to be called for any event in the provider associated with this parser (ProviderName) whose type is compatible with T and 
            whose eventName will pass 'eventNameFilter'.    The eventNameFilter parameter can be null, in which case all events that are compatible 
            with T will be selected.  
            <para>
            A 'subscriptionID' can be passed and this value along with the callback can be used
            to uniquely identify subscription to remove using the 'RemoveCallback' API.   If null is passed, then only the identity of the callback can
            be used to identify the subscription to remove.  
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'. 
            </para>        
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForProviderEvent(System.String,System.String,System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            A shortcut that adds 'callback' for the event in 'providerName' and an event name 'eventName'
            The callback alone is used as the subscription id for unregistration, so the callback delegate should be unique (by delegate comparison)
            
            eventName is of the of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'. 
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForProviderEvents(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Cause 'callback' to be called for any event that this parser recognizes for which the function 'eventsToObserve'
            returns 'AcceptEvent'.   The 'eventsToObserve is given both the provider name (first) and the event name and can return
            'AcceptEvent' 'RejectEvent' or 'RejectProvider' (in which case it may not be called again for that provider).  
            eventsToObserver can be null in which case all events that match the parser recognizes are selected. 
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'. 
            
            <para>
            Thus this method works for parsers that parse more than one provider (e.g. DynamicTraceEventParser).   
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForProviderEvents(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Object,System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Cause 'callback' to be called for any event that this parser recognizes for which the function 'eventsToObserve'
            returns 'AcceptEvent'.   The 'eventsToObserve is given both the provider name (first) and the event name and can return
            'AcceptEvent' 'RejectEvent' or 'RejectProvider' (in which case it may not be called again for that provider).  
            eventsToObserver can be null in which case all events that match the parser recognizes are selected. 
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'.         /// 
            <para>
            Thus this method works for parsers that parse more than one provider (e.g. DynamicTraceEventParser).   
            </para><para>
            A subscriptionID can optionally be passed.  This is used (along with the callback identity) to identify this to the 'RemoveCallback' If you
            don't need to remove the callback or you will do it in bulk, you don't need this parameter.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.RemoveCallback``1(System.Action{``0},System.Object)">
            <summary>
            Remove all subscriptions added with 'AddCallback' (any overload), that is compatible with T, has a callback 'callback' and subscriptionId 'subscriptionId' 
            where 'subscriptionId' was the value that was optionally passed to 'AddCallback' to provide exactly this disambiguation.  
            <para>
            'callback' or 'subscriptionId' can be null, in which case it acts as a wild card.  Thus RemoveCallback{TraceEvent}(null, null) will remove all callbacks 
            that were registered through this parser.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.Boolean)">
            <summary>
            All TraceEventParsers invoke this constructor.  If 'dontRegister' is true it is not registered with the source. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.GetProviderName">
            <summary>
            Normally a TraceEvent parser knows how to parse only one provider.   If this is true
            ProviderName returns the name of this provider.  If the parser knows how to parse 
            more than one provider, this property returns null.     
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.EnumerateTemplates(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Returns a list of all templates currently existing (new ones can come in, but OnNewEventDefintion must be called 
            whenever that happens.   Note that the returned templates MUST be cloned and do not have their source or parser state
            fields set.  These must be set as part of subscription (after you know if you care about them or not).  
            
            eventsToObserver is given the provider name and event name and those events that return AcceptEvent will
            have the 'callback' function called on that template.   eventsToObserver can be null which mean all events.  
            
            The returned template IS READ ONLY!   If you need a read-write copy (typical), clone it first.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.OnNewEventDefintion(Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData,System.Boolean)">
            <summary>
            If the parser can change over time (it can add new definitions),  It needs to support this interface.  See EnumerateDynamicTemplates for details.
            This function should be called any time a new event is now parsable by the parser.   If it is guaranteed that the particular event is 
            definitely being ADDED (it never existed in the past), then you can set 'mayHaveExistedBefore' to false and save some time.  
             
            It returns false if there are no definitions for that particular Provider (and thus you can skip callback if desired).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.Subscribe(Microsoft.Diagnostics.Tracing.TraceEventParser.SubscriptionRequest,Microsoft.Diagnostics.Tracing.TraceEvent,System.Object,System.Boolean)">
            <summary>
            Given a subscription request, and a template that can now be parsed (and its state, which is just TraceEventParser.StateObj) 
            If subscription states that the template should be registered with the source, then do the registration.   
            
            if 'mayHaveExistedBefore' means that this template definition may have been seen before (DynamicTraceEventParsers do this as
            you may get newer versions dynamically registering themselves).   In that case this should be set.  If you can guaranteed that
            a particular template (provider-eventID pair) will only be subscribed at most once you can set this to false.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventParser.source">
            <summary>
            The source that this parser is connected to.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventParser.Source">
            <summary>
            Get the source this TraceEventParser is attached to. 
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventParser.All">
            <summary>
            Subscribe to all the events this parser can parse.  It is shorthand for AddCallback{TraceEvent}(value)/RemoveCallback(value)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventParser.IsStatic">
            <summary>
            A static TraceEventParser is a parser where the set of events that can be subscribed to (and their payload fields) are known at 
            compile time.  There are very few dynamic TraceEventParsers (DynamicTraceEventParser, RegisteredTraceEventParser and WPPTraceEventParser)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventParser.StateObject">
            <summary>
            If the parser needs to persist data along with the events we put it in a separate object.   
            This object and then implement serialization functionality that allows it to be persisted (this is for ETLX support).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventParser.SubscriptionRequest">
            <summary>
            Keeps track of a single 'AddCallback' request so it can be removed later.   It also handles lazy addition of events.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.SubscriptionRequest.#ctor(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Delegate,System.Object)">
            <summary>
            Create a subscription request.  'eventsToObserve takes a provider name (first) and a event name and returns a three valued EventFilterResponse
            value (accept, reject, reject provider)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEvent">
            <summary>
            TraceEvent an abstract class represents the data from one event in the stream of events in a TraceEventSource.   
            The TraceEvent class has all the properties of an event that are common to all ETW events, including TimeStamp
            ProviderGuid, ProcessID etc.   Subclasses of TraceEvent then extend this abstract class to include properties
            specific to a particular payload.   
            <para>
            An important architectural point is that TraceEvent classes are aggressively reused by default.   The TraceEvent that is
            passed to any TraceEventParser callback or in a foreach is ONLY valid for the duration for that callback (or one
            iteration of the foreach).  If you need save a copy of the event data, you must call the Clone() method to make
            a copy.   The IObservable interfaces (TraceEventParser.Observe* methods) however implicitly call Clone() so you
            do not have to call Clone() when processing with IObservables (but these are slower).  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetFormattedMessage(System.IFormatProvider)">
            <summary>
            Creates and returns the value of the 'message' for the event with payload values substituted.
            Payload values are formatted using the given formatProvider. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadValue(System.Int32)">
            <summary>
            Given an index from 0 to PayloadNames.Length-1, return the value for that payload item as an object (boxed if necessary).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadString(System.Int32,System.IFormatProvider)">
            <summary>
            PayloadString is like PayloadValue(index).ToString(), however it can do a better job in some cases.  In particular
            if the payload is a enumeration or a bitfield and the manifest defined the enumeration values, then it will print the string name
            of the enumeration value instead of the integer value.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadIndex(System.String)">
            <summary>
            Returns the index in 'PayloadNames for field 'propertyName'.  Returns something less than 0 if not found. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadByName(System.String)">
            <summary>
            PayloadByName fetches the value of a payload property by the name of the property. 
            <para>It will return null if propertyName is not found.</para>
            <para>This method is not intended to be used in performance critical code.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.EventData">
            <summary>
            Returns an array of bytes representing the event-specific payload associated with the event.  
            <para>Normally this method is not used because some TraceEventParser has built a subclass of
            TraceEvent that parses the payload</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.EventData(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the event data and puts it in 'targetBuffer' at 'targetStartIndex' and returns the resulting buffer.
            If 'targetBuffer is null, it will allocate a buffer of the correct size. 
            <para>Normally this method is not used because some TraceEventParser has built a subclass of
            TraceEvent that parses the payload</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Clone">
            <summary>
            The events passed to the callback functions only last as long as the callback, so if you need to
            keep the information around after that you need to copy it.   This method makes that copy.
            <para>This method is more expensive than copy out all the event data from the TraceEvent instance
            to a type of your construction.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToString">
            <summary>
            Pretty print the event.  It uses XML syntax.. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToString(System.IFormatProvider)">
            <summary>
            Pretty print the event using XML syntax, formatting data using the supplied IFormatProvider
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToXml(System.Text.StringBuilder)">
            <summary>
            Write an XML representation to the stringBuilder sb and return it.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToXml(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>
            Writes an XML representation of the event to a StringBuilder sb, formatting data using the passed format provider. 
            Returns the StringBuilder.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Dump(System.Boolean,System.Boolean)">
            <summary>
            Dumps a very verbose description of the event, including a dump of they payload bytes. It is in
            XML format. This is very useful in debugging (put it in a watch window) when parsers are not
            interpreting payloads properly.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEvent.EventTypeUserData">
            <summary>
            EventTypeUserData is a field users get to use to attach their own data on a per-event-type basis.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.#ctor(System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String)">
            <summary>
            Create a template with the given event meta-data.  Used by TraceParserGen.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipUTF8String(System.Int32)">
            <summary>
            Skip UTF8 string starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the string</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipUnicodeString(System.Int32)">
            <summary>
            Skip Unicode string starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the string</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipUnicodeString(System.Int32,System.Int32)">
            <summary>
            Skip 'stringCount' Unicode strings starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the last string</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipSID(System.Int32)">
            <summary>
            Skip a Security ID (SID) starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the Security ID</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.HostOffset(System.Int32,System.Int32)">
            <summary>
            Trivial helper that allows you to get the Offset of a field independent of 32 vs 64 bit pointer size.
            </summary>
            <param name="offset">The Offset as it would be on a 32 bit system</param>
            <param name="numPointers">The number of pointer-sized fields that came before this field.
            </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.HostSizePtr(System.Int32)">
            <summary>
            Computes the size of 'numPointers' pointers on the machine where the event was collected.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetUTF8StringAt(System.Int32)">
            <summary>
            Given an Offset to a null terminated ASCII string in an event blob, return the string that is
            held there.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetFixedAnsiStringAt(System.Int32,System.Int32)">
            <summary>
            Returns the string represented by a fixed length ASCII string starting at 'offset' of length 'charCount'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetFixedUnicodeStringAt(System.Int32,System.Int32)">
            <summary>
            Given an Offset to a fixed sized string at 'offset', whose buffer size is 'charCount'
            Returns the string value.  A null in the string will terminate the string before the
            end of the buffer. 
            </summary>        
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetIPAddrV6At(System.Int32)">
            <summary>
            Returns the encoding of a Version 6 IP address that has been serialized at 'offset' in the payload bytes.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetGuidAt(System.Int32)">
            <summary>
            Returns the GUID serialized at 'offset' in the payload bytes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetDateTimeAt(System.Int32)">
            <summary>
            Get the DateTime that serialized (as a windows FILETIME) at 'offset' in the payload bytes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetUnicodeStringAt(System.Int32)">
            <summary>
            Given an Offset to a null terminated Unicode string in an payload bytes, return the string that is
            held there.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetByteArrayAt(System.Int32,System.Int32)">
            <summary>
            Give an offset to a byte array of size 'size' in the payload bytes, return a byte[] that contains
            those bytes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetByteAt(System.Int32)">
            <summary>
            Returns a byte value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetInt16At(System.Int32)">
            <summary>
            Returns a short value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetInt32At(System.Int32)">
            <summary>
            Returns an int value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetInt64At(System.Int32)">
            <summary>
            Returns a long value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetIntPtrAt(System.Int32)">
            <summary>
            Get something that is machine word sized for the provider that collected the data, but is an
            integer (and not an address)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetAddressAt(System.Int32)">
            <summary>
            Gets something that is pointer sized for the provider that collected the data.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetSingleAt(System.Int32)">
            <summary>
            Returns an int float (single) that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetDoubleAt(System.Int32)">
            <summary>
            Returns an int double precision floating point value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.Int64)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.UInt64)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.Int64)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.UInt32)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.Object)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Prefix(System.Text.StringBuilder)">
            <summary>
            Prints a standard prefix for a event (includes the time of the event, the process ID and the
            thread ID.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ThreadIDforStacks">
            <summary>
            Because we want the ThreadID to be the ID of the CREATED thread, and the stack 
            associated with the event is the parentThreadID 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SetState(System.Object)">
            <summary>
            If this TraceEvent belongs to a parser that needs state, then this callback will set the state.  
            Currently only used on KernelTraceEventParser.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            A standard way for events to are that certain addresses are addresses in code and ideally have
            symbolic information associated with them.  Returns true if successful.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Compare(Microsoft.Diagnostics.Tracing.EventIndex,Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Used for binary searching of event IDs.    Abstracts the size (currently a int, could go to long) 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Matches(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Returns true if the two traceEvents have the same identity.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Finalize">
            <summary>
            Normally TraceEvent does not have unmanaged data, but if you call 'Clone' it will.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.EventDataAsString">
            <summary>
             If the event data looks like a unicode string, then return it.  This is heuristic.  (See also IsEventWriteString)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Dispatch">
            <summary>
            Each TraceEvent items knows where it should Dispatch to.
            ETWTraceEventSource.Dispatch calls this function to go to the right placed. By default we
            do nothing. Typically a subclass just dispatches to another callback that passes itself to a
            type-specific event callback.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Validate">
            <summary>
            This is a DEBUG-ONLY routine that allows a routine to do consistency checking in a debug build.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.DebugValidate">
            <summary>
            Validate that the events is not trash.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEvent.next">
            <summary>
            TraceEvent knows where to dispatch to. To support many subscriptions to the same event we chain
            them.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEvent.payloadNames">
            <summary>
            The array of names for each property in the payload (in order).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProviderGuid">
            <summary>
            The GUID that uniquely identifies the Provider for this event.  This can return Guid.Empty for classic (Pre-VISTA) ETW providers.  
            </summary>        
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProviderName">
            <summary>
            The name of the provider associated with the event.  It may be of the form Provider(GUID) or UnknownProvider in some cases but is never null.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.EventName">
            <summary>
            A name for the event.  This is simply the concatenation of the task and opcode names (separated by a /).  If the 
            event has no opcode, then the event name is just the task name.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ID">
            <summary>
            Returns the provider-specific integer value that uniquely identifies event within the scope of
            the provider. (Returns 0 for classic (Pre-VISTA) ETW providers).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Task">
            <summary>
            Events for a given provider can be given a group identifier (integer) called a Task that indicates the
            broad area within the provider that the event pertains to (for example the Kernel provider has
            Tasks for Process, Threads, etc).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TaskName">
            <summary>
            The human readable name for the event's task (group of related events) (eg. process, thread,
            image, GC, ...).  May return a string Task(GUID) or Task(TASK_NUM) if no good symbolic name is
            available.  It never returns null.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Opcode">
            <summary>
            An opcode is a numeric identifier (integer) that identifies the particular event within the group of events 
            identified by the event's task.  Often events have opcode 'Info' (0), which is the default.   This value
            is interpreted as having no-opcode (the task is sufficient to identify the event).
            <para>
            Generally the most useful opcodes are the Start and Stop opcodes which are used to indicate the beginning and the
            end of a interval of time.   Many tools will match up start and stop opcodes automatically and compute durations.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.OpcodeName">
            <summary>
            Returns the human-readable string name for the Opcode property. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Level">
            <summary>
            The verbosity of the event (Fatal, Error, ..., Info, Verbose)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Version">
            <summary>
            The version number for this event.  The only compatible change to an event is to add new properties at the end.
            When this is done the version numbers is incremented.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Keywords">
            <summary>
            ETW Event providers can specify a 64 bit bitfield called 'keywords' that define provider-specific groups of 
            events which can be enabled and disabled independently.   
            Each event is given a keywords mask that identifies which groups the event belongs to.   This property returns this mask.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Channel">
            <summary>
            A Channel is a identifier (integer) that defines an 'audience' for the event (admin, operational, ...).   
            Channels are only used for Windows Event Log integration.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TimeStamp">
            <summary>
            The time of the event. You may find TimeStampRelativeMSec more convenient.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TimeStampRelativeMSec">
            <summary>
            Returns a double representing the number of milliseconds since the beginning of the session.     
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ThreadID">
            <summary>
            The thread ID for the thread that logged the event
            <para>This field may return -1 for some events when the thread ID is not known.</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProcessID">
            <summary>
            The process ID of the process which logged the event. 
            <para>This field may return -1 for some events when the process ID is not known.</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProcessName">
            <summary>
            Returns a short name for the process. This the image file name (without the path or extension),
            or if that is not present, then the string 'Process(XXXX)' 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProcessorNumber">
            <summary>
            The processor Number (from 0 to TraceEventSource.NumberOfProcessors) that logged this event. 
            event. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.PointerSize">
            <summary>
            Get the size of a pointer associated with process that logged the event (thus it is 4 for a 32 bit process). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ActivityID">
            <summary>
            Conceptually every ETW event can be given a ActivityID (GUID) that uniquely identifies the logical
            work being carried out (the activity).  This property returns this GUID.   Can return Guid.Empty
            if the thread logging the event has no activity ID associated with it.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.RelatedActivityID">
            <summary>
            ETW supports the ability to take events with another GUID called the related activity that is either
            causes or is caused by the current activity.   This property returns that GUID (or Guid.Empty if the
            event has not related activity.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.FormattedMessage">
            <summary>
            Event Providers can define a 'message' for each event that are meant for human consumption.   
            FormattedMessage returns this string with the values of the payload filled in at the appropriate places.
            <para>It will return null if the event provider did not define a 'message'  for this event</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.EventIndex">
            <summary>
            An EventIndex is a integer that is guaranteed to be unique for this event over the entire log.  Its
            primary purpose is to act as a key that allows side tables to be built up that allow value added
            processing to 'attach' additional data to this particular event unambiguously.  
            <para>This property is only set for ETLX file.  For ETL or real time streams it returns 0</para>
            <para>EventIndex is currently a 4 byte quantity.  This does limit this property to 4Gig of events</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Source">
            <summary>
            The TraceEventSource associated with this event.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.IsClassicProvider">
            <summary>
            Returns true if this event is from a Classic (Pre-VISTA) provider
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadNames">
            <summary>
            Returns the names of all the manifest declared field names for the event.    May be empty if the manifest is not available.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.EventDataLength">
            <summary>
            The size of the event-specific data payload.  (see EventData)
            <para>Normally this property is not used because some TraceEventParser has built a subclass of
            TraceEvent that parses the payload</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.DataStart">
            <summary>
            Returns the raw IntPtr pointer to the data blob associated with the event.  This is the way the
            subclasses of TraceEvent get at the data to display it in a efficient (but unsafe) manner.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Target">
            <summary>
            Returns (or sets) the delegate associated with this event.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TimeStampQPC">
            <summary>
            Returns the Timestamp for the event using Query Performance Counter (QPC) ticks.   
            The start time for the QPC tick counter is unknown
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.IsEventWriteString">
            <summary>
            Was this written with the windows EventWriteString API? (see also EventDataAsString)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords">
            <summary>
             Keywords are passed to TraceEventSession.EnableProvider to enable particular sets of
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GC">
            <summary>
            Logging when garbage collections and finalization happen. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHandle">
            <summary>
            Events when GC handles are set or destroyed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Loader">
            <summary>
            Logging when modules actually get loaded and unloaded. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Jit">
            <summary>
            Logging when Just in time (JIT) compilation occurs. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.NGen">
            <summary>
            Logging when precompiled native (NGEN) images are loaded.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.StartEnumeration">
            <summary>
            Indicates that on attach or module load , a rundown of all existing methods should be done
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.StopEnumeration">
            <summary>
            Indicates that on detach or process shutdown, a rundown of all existing methods should be done
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Security">
            <summary>
            Events associated with validating security restrictions.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.AppDomainResourceManagement">
            <summary>
            Events for logging resource consumption on an app-domain level granularity
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.JitTracing">
            <summary>
            Logging of the internal workings of the Just In Time compiler.  This is fairly verbose.  
            It details decisions about interesting optimization (like inlining and tail call) 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Interop">
            <summary>
            Log information about code thunks that transition between managed and unmanaged code. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Contention">
            <summary>
            Log when lock contention occurs.  (Monitor.Enters actually blocks)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Exception">
            <summary>
            Log exception processing.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Threading">
            <summary>
            Log events associated with the threadpool, and other threading events.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.JittedMethodILToNativeMap">
            <summary>
            Dump the native to IL mapping of any method that is JIT compiled.  (V4.5 runtimes and above).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.OverrideAndSuppressNGenEvents">
            <summary>
            If enabled will suppress the rundown of NGEN events on V4.0 runtime (has no effect on Pre-V4.0 runtimes).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Type">
            <summary>
            Enables the 'BulkType' event
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapDump">
            <summary>
            Enables the events associated with dumping the GC heap
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCSampledObjectAllocationHigh">
            <summary>
            Enables allocation sampling with the 'fast'.  Sample to limit to 100 allocations per second per type.  
            This is good for most detailed performance investigations.   Note that this DOES update the allocation
            path to be slower and only works if the process start with this on. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapSurvivalAndMovement">
            <summary>
            Enables events associate with object movement or survival with each GC.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapCollect">
            <summary>
            Triggers a GC.  Can pass a 64 bit value that will be logged with the GC Start event so you know which GC you actually triggered.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapAndTypeNames">
            <summary>
            Indicates that you want type names looked up and put into the events (not just meta-data tokens).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCSampledObjectAllocationLow">
            <summary>
            Enables allocation sampling with the 'slow' rate, Sample to limit to 5 allocations per second per type.  
            This is reasonable for monitoring.    Note that this DOES update the allocation path to be slower
            and only works if the process start with this on.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCAllObjectAllocation">
            <summary>
            Turns on capturing the stack and type of object allocation made by the .NET Runtime.   This is only
            supported after V4.5.3 (Late 2014)   This can be very verbose and you should seriously using  GCSampledObjectAllocationHigh
            instead (and GCSampledObjectAllocationLow for production scenarios).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.SupressNGen">
            <summary>
            This suppresses NGEN events on V4.0 (where you have NGEN PDBs), but not on V2.0 (which does not know about this 
            bit and also does not have NGEN PDBS).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.PerfTrack">
            <summary>
            TODO document
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Stack">
            <summary>
            Also log the stack trace of events for which this is valuable.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.ThreadTransfer">
            <summary>
            This allows tracing work item transfer events (thread pool enqueue/dequeue/ioenqueue/iodequeue/a.o.)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Debugger">
            <summary>
            .NET Debugger events
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Monitoring">
            <summary>
            Events intended for monitoring on an ongoing basis.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Codesymbols">
            <summary>
            Events that will dump PDBs of dynamically generated assemblies to the ETW stream.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Default">
            <summary>
            Recommend default flags (good compromise on verbosity).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapSnapshot">
            <summary>
            This provides the flags commonly needed to take a heap .NET Heap snapshot with ETW.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkTypeValues 
            points the the data in GCBulkRootEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues">
            <summary>
            This structure just POINTS at the data in the BulkTypeTraceData.  It can only be used as long as
            the BulkTypeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues.TypeID">
            <summary>
            On the desktop this is the Method Table Pointer
            In project N this is the pointer to the EE Type
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues.ModuleID">
            <summary>
            For Desktop this is the Module*
            For project N it is image base for the module that the type lives in?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues.TypeNameID">
            <summary>
            On desktop this is the Meta-data token?
            On project N it is the RVA of the typeID
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned GCBulkRootEdgeValues
            points the the data in GCBulkRootEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootEdgeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkEdgeTraceData.  It can only be used as long as
            the GCBulkEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootConditionalWeakTableElementEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the range at the given zero-based index (index less than Count).   The returned GCBulkRootConditionalWeakTableElementEdgeValues 
            points the the data in GCBulkRootConditionalWeakTableElementEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootConditionalWeakTableElementEdgeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRootConditionalWeakTableElementEdgeTraceData.  It can only be used as long as
            the GCBulkRootConditionalWeakTableElementEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeTraceData.Values(System.Int32)">
            <summary>
            Returns the node at the given zero-based index (idx less than Count).   The returned GCBulkNodeNodes 
            points the the data in GCBulkNodeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeTraceData.UnsafeNodes(System.Int32,Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeUnsafeNodes*)">
            <summary>
            This unsafe interface may go away.   Use the 'Nodes(idx)' instead 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkNodeTraceData.  It can only be used as long as
            the GCBulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the 'idx' th edge.  
            The returned GCBulkEdgeEdges cannot live beyond the TraceEvent that it comes from.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkEdgeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkNodeTraceData.  It can only be used as long as
            the GCBulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkSurvivingObjectRangesTraceData.Values(System.Int32)">
            <summary>
            Returns the range at the given zero-based index (index less than Count).   The returned GCBulkSurvivingObjectRangesValues 
            points the the data in GCBulkSurvivingObjectRangesTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkSurvivingObjectRangesValues">
            <summary>
            This structure just POINTS at the data in the GCBulkEdgeTraceData.  It can only be used as long as
            the GCBulkEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkMovedObjectRangesTraceData.Values(System.Int32)">
            <summary>
            Returns the range at the given zero-based index (index less than Count).   The returned GCBulkSurvivingObjectRangesValues 
            points the the data in GCBulkSurvivingObjectRangesTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkMovedObjectRangesValues">
            <summary>
            This structure just POINTS at the data in the GCBulkEdgeTraceData.  It can only be used as long as
            the GCBulkEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens">
            <summary>
            We keep Heap history for every Generation in 'Gens' 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryTraceData">
             <summary>
             This structure is in the ndp\clr\src\vm\gcrecord.h file. 
             The easiest way to get th layout is to do a 'dt' command on the structure (use x command to search)
            
             dt WKS::gc_generation_data 
             dt WKS::gc_history_per_heap
             
             For Silverlight (X86) 
             
             0:014> dt coreclr!WKS::gc_history_per_heap
                +0x000 gen_data         : [5] WKS::gc_generation_data
                +0x0c8 mem_pressure     : Uint4B
                +0x0cc mechanisms       : [2] Uint4B
                +0x0d4 gen_condemn_reasons : Uint4B
                +0x0d8 heap_index       : Uint4B
             0:014> dt coreclr!WKS::gc_generation_data
                +0x000 size_before      : Uint4B
                +0x004 size_after       : Uint4B
                +0x008 current_size     : Uint4B
                +0x00c previous_size    : Uint4B
                +0x010 fragmentation    : Uint4B
                +0x014 in               : Uint4B
                +0x018 out              : Uint4B
                +0x01c new_allocation   : Uint4B
                +0x020 surv             : Uint4B
                +0x024 growth           : Uint4B
              
             For 4.5 (X86)
             0:000> dt clr!WKS::gc_history_per_heap
                +0x000 gen_data         : [5] WKS::gc_generation_data
                +0x0c8 gen_to_condemn_reasons : WKS::gen_to_condemn_tuning
                +0x0d0 mem_pressure     : Uint4B
                +0x0d4 mechanisms       : [2] Uint4B
                +0x0dc heap_index       : Uint4B
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryTraceData.GenData(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            genNumber is a number from 0 to maxGenData-1.  These are for generation 0, 1, 2, 3 = Large Object Heap
            genNumber = 4 is that second pass for Gen 0.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.SizeBefore">
            <summary>
            Size of the generation before the GC, includes fragmentation
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.SizeAfter">
            <summary>
            Size of the generation after GC.  Includes fragmentation
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.ObjSpaceBefore">
            <summary>
            Size occupied by objects at the beginning of the GC, discounting fragmentation. 
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.Fragmentation">
            <summary>
            This is the fragmenation at the end of the GC.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.ObjSizeAfter">
            <summary>
            Size occupied by objects, discounting fragmentation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeListSpaceBefore">
            <summary>
            This is the free list space (ie, what's threaded onto the free list) at the beginning of the GC.
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeObjSpaceBefore">
            <summary>
            This is the free obj space (ie, what's free but not threaded onto the free list) at the beginning of the GC.
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeListSpaceAfter">
            <summary>
            This is the free list space (ie, what's threaded onto the free list) at the end of the GC.
            Only exits on 4.5 Beta and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeObjSpaceAfter">
            <summary>
            This is the free obj space (ie, what's free but not threaded onto the free list) at the end of the GC.
            Only exits on 4.5 Beta and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.In">
            <summary>
            This is the amount that came into this generation on this GC
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.Out">
            <summary>
            This is the number of bytes survived in this generation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.Budget">
            <summary>
            This is the new budget for the generation
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.SurvRate">
            <summary>
            This is the survival rate
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootCCWTraceData.Values(System.Int32)">
            <summary>
            Returns the CCW at the given zero-based index (index less than Count).   The returned GCBulkRootCCWValues 
            points the the data in GCBulkRootCCWTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootCCWTraceData.ValueSize">
            <summary>
            Computes the size of one GCBulkRootCCWValues structure.  
            TODO FIX NOW Can rip out and make a constant 44 after 6/2014
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootCCWValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRootCCWTraceData.  It can only be used as long as
            the GCBulkRootCCWTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRCWTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned GCBulkRCWValues 
            points the the data in GCBulkRCWTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRCWValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRCWTraceData.  It can only be used as long as
            the GCBulkRCWTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootStaticVarTraceData.Values(System.Int32)">
            <summary>
            Returns 'idx'th static root.   
            The returned GCBulkRootStaticVarStatics cannot live beyond the TraceEvent that it comes from.  
            The implementation is highly tuned for sequential access.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootStaticVarValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRootStaticVarTraceData.  It can only be used as long as
            the GCBulkRootStaticVarTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrStackWalkTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete eventToStack).  
            </summary>
            <param name="index">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrStackWalkTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.ModuleLoadUnloadTraceData.ModuleILFileName">
            <summary>
            This is simply the file name part of the ModuleILPath.  It is a convinience method. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.Threading">
            <summary>
            Log events associated with the threadpool, and other threading events.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.JittedMethodILToNativeMap">
            <summary>
            Dump the native to IL mapping of any method that is JIT compiled.  (V4.5 runtimes and above).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.SupressNGen">
            <summary>
            This supresses NGEN events on V4.0 (where you have NGEN PDBs), but not on V2.0 (which does not know about this 
            bit and also does not have NGEN PDBS).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.PerfTrack">
            <summary>
            TODO document
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.CodeSymbolsRundown">
            <summary>
            Dump PDBs for dynamically generated modules.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.AggregateStackSource">
            <summary>
            A StackSource that aggregates information from other StackSources into a single unified view.
            </summary>
            <remarks>
            Each StackSource has a name associated with it. The stacks for each StackSource will be grouped under
            a pseudo-frame named the same as the source name. Source names are specified on initialization.
            </remarks>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.Diagnostics.Tracing.Stacks.StackSource}})">
            <summary>
            Initialize a new AggregateStackSource.
            </summary>
            <param name="sources">An IEnumerable of KeyValuePairs mapping source names to StackSources.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Enumerate samples with a callback function.
            </summary>
            <param name="callback">The function to call on each sample.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample},System.Boolean[])">
            <summary>
            Enumerate samples for a given set of scenarios with a callback function.
            </summary>
            <param name="callback">The function to call on each sample.</param>
            <param name="scenariosIncluded">An array of length ScenarioCount. If scenariosIncluded[i] == true, include scenario i.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ParallelForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample},System.Boolean[],System.Int32)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Look up a sample by index.
            </summary>
            <param name="sampleIndex">The index of the sample to look up.</param>
            <returns>
            The sample, if it can be found and all sub-sources support indexing; null otherwise.
            </returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Gets the index of the caller of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The caller, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Get the frame index of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The frame index of the call stack, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Gets the name of a frame.
            </summary>
            <param name="frameIndex">The frame to look up.</param>
            <param name="verboseName">Whether to include full module paths.</param>
            <returns>The name of the frame.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ConvertSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample,System.Int32)">
            <summary>
            Convert a StackSourceSample produced by a sub-source into one suitable for the aggregate source.
            </summary>
            <param name="input">The StackSourceSample to convert.</param>
            <param name="storage">A place to but the returned sampled (will become the return value).</param>
            <param name="sourceIdx">The index of the source from which the sample came.</param>
            <returns>The converted sample.</returns>
            <remarks>
            If ConvertSample is called again, all previous samples produced by ConvertSample may no longer be used.
            </remarks>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.m_sourceNames">
            <summary>
            Friendly names of sources.
            </summary>
            <remarks>
            Name 0 is the name of the pseudo-source, which should not be used.
            </remarks>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.m_sources">
            <summary>
            The list of sources.
            </summary>
            <remarks>
            Source 0 is the pseudo-source (identical to m_pseudo).
            </remarks>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.m_firstSampleTime">
            <summary>
            THis is the time of the first sample.  It lets us normalize the time in the sample to be relative to this.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.SamplesImmutable">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.CallStackIndexLimit">
            <summary>
            The total number of call stacks in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.CallFrameIndexLimit">
            <summary>
            The total number of frames in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.SampleIndexLimit">
            <summary>
            The total number of samples in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.ScenarioNames">
            <summary>
            The names for the scenarios.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.ScenarioCount">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource">
            <summary>
            A StackSource to generate the pseudo-frames needed to group scenarios.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.#ctor(System.String[])">
            <summary>
            Initialize a new PseudoStackSource.
            </summary>
            <param name="names">The names of the frames.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetStackForSource(System.Int32)">
            <summary>
            Gets the CallStackIndex of the call stack corresponding to a given source.
            </summary>
            <param name="sourceIdx">The index of the source to look up.</param>
            <returns>The StackSourceCallStackIndex of a stack under which to group all call stacks for that source.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Gets the index of the caller of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The caller, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Get the frame index of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The frame index of the call stack, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Gets the name of a frame.
            </summary>
            <param name="frameIndex">The frame to look up.</param>
            <param name="verboseName">Whether to include full module paths.</param>
            <returns>The name of the frame.</returns>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.names">
            <summary>
            The names of the frames that this source generates.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.CallStackIndexLimit">
            <summary>
            The total number of call stacks in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.CallFrameIndexLimit">
            <summary>
            The total number of frames in this source.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.IndexMapExtensions">
            <summary>
            Extension methods for type-safe IndexMap operations on StackSource*Index enums.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterParams">
            <summary>
            This is just a class that holds data.  It does nothing except support an 'update' events 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.#ctor">
            <summary>
            Constructs a Filter parameter class with all empty properties. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.#ctor(Diagnostics.Tracing.StackSources.FilterParams)">
            <summary>
            Create a Filter Parameters Structure form another one
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.Set(Diagnostics.Tracing.StackSources.FilterParams)">
            <summary>
            Set a Filter Parameters Structure form another one
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.Equals(System.Object)">
            <summary>
             override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.GetHashCode">
            <summary>
             override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.EscapeRegEx(System.String)">
            <summary>
            TODO Document
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.WriteToXml(System.Xml.XmlWriter)">
            <summary>
            Write out the FilterParameters to XML 'writer'
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.ToXml">
            <summary>
            Create an XML representation of FilterParams as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.Name">
            <summary>
            Fetch Name 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.StartTimeRelativeMSec">
            <summary>
            Fetch StartTimeRelativeMSec 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.EndTimeRelativeMSec">
            <summary>
            Fetch EndTimeRelativeMSec 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.MinInclusiveTimePercent">
            <summary>
            Fetch MinInclusiveTimePercent 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.FoldRegExs">
            <summary>
            Fetch FoldRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.IncludeRegExs">
            <summary>
            Fetch IncludeRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.ExcludeRegExs">
            <summary>
            Fetch ExcludeRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.GroupRegExs">
            <summary>
            Fetch GroupRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.TypePriority">
            <summary>
            Fetch TypePriority 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.ScenarioList">
            <summary>
            Fetch ScenarioList 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.Scenarios">
            <summary>
            Fetch Scenarios 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource">
            <summary>
            A FilterStackSouce morphs one stack filters or groups the stacks of one stack source to form a new
            stack source.   It is very powerful mechanism.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.StackInfoCacheSize">
            <summary>
            We cache information about stacks we have previously seen so we can short-circuit work. 
            TODO make dynamic.   
            
            Note when this value is 4096 some memory profiles are VERY sluggish.  Don't make it too
            small unless it is adaptive.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.#ctor(Diagnostics.Tracing.StackSources.FilterParams,Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind)">
            <summary>
            Create a new FilterStackSource.   
            </summary>
            <param name="filterParams">Specifies how to filter or group the stacks</param>
            <param name="stackSource">The input source to morph</param>
            <param name="scalingPolicy">How to scale the data (as time or simply by size of data)</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetNumberOfFoldedFrames(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetReferences(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,Microsoft.Diagnostics.Tracing.Stacks.RefDirection,System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex})">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetStackInfo(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Associated with every frame is a FrameInfo which is the computed answers associated with that frame name.  
            We cache these and so most of the time looking up frame information is just an array lookup.  
            
            FrameInfo contains information that is ONLY dependent on the frame name (not the stack it came from), so
            entry point groups and include patterns can not be completely processed at this point.   Never returns null. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GenerateStackInfo(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Diagnostics.Tracing.StackSources.FilterStackSource.StackInfo)">
            <summary>
            Generate the stack information for 'stack' and place it in stackInfoRet.  Only called by GetStackInfo.    
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetFrameInfo(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Returns the frame information for frameIndex.   Never returns null.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ParseGroups(System.String)">
            <summary>
            Parses a string into the GroupPattern structure that allows it to executed (matched).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.FindGroupNameFromFrameName(System.String,System.Boolean@)">
            <summary>
            Given the name of a frame, look it up in the group patterns and morph it to its group name. 
            If the group that matches is a entryGroup then set 'isEntryGroup'.  Will return null if
            no group matches 'frameName'
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ParseRegExList(System.String)">
            <summary>
            Holds parsed information about patterns for groups includes, excludes or folds.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.IsMatch(System.Text.RegularExpressions.Regex[],System.String)">
            <summary>
            Returns the index in the 'pats' array of the first pattern that matches 'str'.   Returns -1 if no match. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.SameSet(System.Int32[],System.Int32[])">
            <summary>
            returns true if set1 and set1 (as returned from MatchSet) are identical 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ToDotNetRegEx(System.String)">
            <summary>
            Convert a string from my regular expression format (where you only have * and {  } as grouping operators
            and convert them to .NET regular expressions string
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.MatchesNothing">
            <summary>
            Represents a frame that does not match any pattern.  Thus the default of simply returning the frame ID is appropriate
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.Discard">
            <summary>
            Represents a frame that should be discarded.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.Fold">
            <summary>
            Represents a frame that should be folded into its caller.  
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.ScenarioCount">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.CallStackIndexLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.CallFrameIndexLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.BaseStackSource">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.IsGraphSource">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.SampleIndexLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource.GroupPattern">
            <summary>
            This is just the parsed form of a grouping specification Pat->GroupNameTemplate  (it has a pattern regular 
            expression and a group name that can have replacements)  It is a trivial class
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.GroupPattern.IsModuleEntry">
            <summary>
            Experimentally we are going to special case the module entry pattern.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource.FrameInfo">
            <summary>
            FrameInfo is all the information we need to associate with an Frame ID (to figure out what group/pattern it belongs to) 
            This includes what group it belongs to, the include patterns it matches whether to discard or fold it.   It is
            all the processing we can do with JUST the frame ID.  
            
            Note that FrameInfo is reused by multiple stacks, which means that you should NOT update fields in it after initial creation.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.FrameInfo.GroupID">
            <summary>
            This is what we return to the Stack crawler, it encodes either that we should filter the sample,
            fold the frame, form a group, or the frameID that we have chosen to represent the group as a whole.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource.StackInfo">
            <summary>
            Represents all accumulated information about grouping for a particular stack.  Effectively this is the
            'result' of applying the grouping and filtering to a particular stack.   We cache the last 100 or so
            of these because stacks tend to reuse the parts of the stack close the root.     
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.StackInfo.IncPathsMatchedSoFar">
            <summary>
            The include patterns that have been matched by some frame in this stack.  (ultimately we need all bits set).
            Can be null, which means the empty set.  
            </summary>
        </member>
        <member name="T:Utilities.IndexMap">
            <summary>
            A class that maps contiguous indices from various sources from and to a single range of contiguous indices.
            </summary>
            <remarks>
            This is useful for aggregating indices used, for instance, in the interface for StackSource (StackSourceCallStackIndex /
            StackSourceFrameIndex) in AggregateStackSource. This is an easy way, given the incoming StackSource*Index, to find the
            aggregated source to query, and the corresponding StackSource*Index to send to the source.
            </remarks>
            <example>
            With counts [3, 7, 5]:
                                1 1 1 1 1  
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  = Incoming index
            __0__ ______1______ ____2____  = Source number
            0 1 2|0 1 2 3 4 5 6|0 1 2 3 4  = Offset
            </example>
        </member>
        <member name="M:Utilities.IndexMap.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Initialize a new IndexMap with the specified counts.
            </summary>
            <param name="counts">A list mapping an index to its corresponding count.</param>
        </member>
        <member name="M:Utilities.IndexMap.SourceOf(System.Int32)">
            <summary>
            Find the source for an index.
            </summary>
            <param name="aggregate">The aggregate index to look up.</param>
            <returns>The source that <paramref name="aggregate"/> belongs to.</returns>
        </member>
        <member name="M:Utilities.IndexMap.OffsetOf(System.Int32,System.Int32)">
            <summary>
            Find the offset into a given source of a given aggregate index.
            </summary>
            <param name="aggregate">The aggregate index to look up.</param>
            <param name="source">The source to find the offset into.</param>
            <returns>The offset of <paramref name="aggregate"/> into <paramref name="source"/>.</returns>
        </member>
        <member name="M:Utilities.IndexMap.IndexOf(System.Int32,System.Int32)">
            <summary>
            Finds the index for a given source/offset pair.
            </summary>
            <param name="source">The source number of the item.</param>
            <param name="offset">The offset into the corresponding source for the item.</param>
            <returns>The index corresponding to the pair of <paramref name="source"/> and <paramref name="offset"/>.</returns>
        </member>
        <member name="F:Utilities.IndexMap.m_lookup">
            <summary>
            The lookup table to convert indices to source/offset pairs.
            </summary>
            <remarks>
            This contains the cumulative count of indices that occurred before each source.
            The last element is the total number of indices (equal to m_range).
            </remarks>
        </member>
        <member name="F:Utilities.IndexMap.m_range">
            <summary>
            The total number of indices in the map.
            </summary>
        </member>
        <member name="F:Utilities.IndexMap.m_lastSourceLookedUp">
            <summary>
            We remember the last source we looked up and check there first very likely they are next to one another. 
            </summary>
        </member>
        <member name="P:Utilities.IndexMap.Count">
            <summary>
            The total number of indices in the map.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolReader">
            <summary>
            A symbol reader represents something that can FIND pdbs (either on a symbol server or via a symbol path)
            Its job is to find a full path a PDB.  Then you can use OpenSymbolFile to get a SymbolReaderModule and do more. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.#ctor(System.IO.TextWriter,System.String)">
            <summary>
            Opens a new SymbolReader.   All diagnostics messages about symbol lookup go to 'log'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.FindSymbolFilePathForModule(System.String)">
            <summary>
            Finds the symbol file for 'exeFilePath' that exists on the current machine (we open
            it to find the needed info).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.   It will also
            generate NGEN pdbs into the local symbol cache unless SymbolReaderFlags.NoNGenPDB is set.   
            
            Returns null if the pdb can't be found.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.FindSymbolFilePath(System.String,System.Guid,System.Int32,System.String,System.String)">
            <summary>
            Find the complete PDB path, given just the simple name (filename + pdb extension) as well as its 'signature', 
            which uniquely identifies it (on symbol servers).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.  
            
            A Guid of Empty, means 'unknown' and will match the first PDB that matches simple name.  Thus it is unsafe. 
            
            Returns null if the PDB could  not be found
            </summary>
            <param name="pdbFileName">The name of the PDB file (we only use the file name part)</param>
            <param name="pdbIndexGuid">The GUID that is embedded in the DLL in the debug information that allows matching the DLL and the PDB</param>
            <param name="pdbIndexAge">Tools like BBT transform a DLL into another DLL (with the same GUID) the 'pdbAge' is a small integers
            that indicates how many transformations were done</param>
            <param name="dllFilePath">If you know the path to the DLL for this pdb add it here.  That way we can probe next to the DLL
            for the PDB file.</param>
            <param name="fileVersion">This is an optional string that identifies the file version (the 'Version' resource information.  
            It is used only to provided better error messages for the log.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.FindExecutableFilePath(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This API looks up an executable file, by its build-timestamp and size (on a symbol server),  'fileName' should be 
            a simple name (no directory), and you need the buildTimeStamp and sizeOfImage that are found in the PE header.
            
            Returns null if it cannot find anything.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.OpenSymbolFile(System.String)">
            <summary>
            Given the path name to a particular PDB file, load it so that you can resolve symbols in it.  
            </summary>
            <param name="pdblFilePath">The name of the PDB file to open.</param>
            <returns>The SymbolReaderModule that represents the information in the symbol file (PDB)</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.OpenSymbolFile(System.String,System.IO.Stream)">
            <summary>
            Loads symbols from a Stream.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GenerateNGenSymbolsForModule(System.String,System.String)">
            <summary>
            Given a full filename path to an NGEN image, insure that there is an NGEN image for it
            in the symbol cache.  If one already exists, this method simply returns that.   If not
            it is generated and placed in the symbol cache.  When generating the PDB this routine
            attempt to resolve line numbers, which DOES require looking up the PDB for the IL image. 
            Thus routine may do network accesses (to download IL PDBs).  
            
            Note that FindSymbolFilePathForModule calls this, so normally you don't need to call 
            this method directly.  
            
            By default it places the PDB in the SymbolCacheDirectory using normal symbol server 
            cache conventions (PDBNAME\Guid-AGE\Name).   You can override this by specifying
            the outputDirectory parameter.  
            
            <returns>The full path name of the PDB generated for the NGEN image.</returns>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.Dispose">
            <summary>
             Called when you are done with the symbol reader.  Currently does nothing.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.PdbMatches(System.String,System.Guid,System.Int32)">
            <summary>
            Returns true if 'filePath' exists and is a PDB that has pdbGuid and pdbAge.  
            if pdbGuid == Guid.Empty, then the pdbGuid and pdbAge checks are skipped. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GetPhysicalFileFromServer(System.String,System.String,System.String)">
            <summary>
            Fetches a file from the server 'serverPath' with pdb signature path 'pdbSigPath' (concatinate them with a / or \ separator
            to form a complete URL or path name).   It will place the file in 'fullDestPath'   It will return true if successful
            You should probably be using GetFileFromServer
            </summary>
            <param name="serverPath">path to server (e.g. \\symbols\symbols or http://symweb) </param>
            <param name="pdbIndexPath">pdb path with signature (e.g clr.pdb/1E18F3E494DC464B943EA90F23E256432/clr.pdb)</param>
            <param name="fullDestPath">the full path of where to put the file locally </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.CopyStreamToFile(System.IO.Stream,System.String,System.String,System.Boolean@)">
            <summary>
            This just copies a stream to a file path with logging.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GetFileFromServer(System.String,System.String,System.String)">
            <summary>
            Looks up 'fileIndexPath' on the server 'urlForServer' (concatenate to form complete URL) copying the file to 
            'targetPath' and returning targetPath name there (thus it is always a local file).  Unlike  GetPhysicalFileFromServer, 
            GetFileFromServer understands how to deal with compressed files and file.ptr (redirection).  
            </summary>
            <returns>targetPath or null if the file cannot be found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GetClrDirectoryForNGenImage(System.String,System.IO.TextWriter,System.String@)">
            <summary>
            Deduce the path to where CLR.dll (and in particular NGEN.exe live for the NGEN image 'ngenImagepath')
            Returns null if it can't be found.  If the NGEN image is associated with a private runtime return 
            that value in 'privateVerStr'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.CacheFileLocally(System.String,System.Guid,System.Int32)">
            <summary>
            This is an optional routine.  It is already the case that if you find a PDB on a symbol server
            that it will be cached locally, however if you find it on a network path by NOT using a symbol
            server, it will be used in place.  This is annoying, and this routine makes up for this by
            mimicking this behavior.  Basically if pdbPath is not a local file name, it will copy it to
            the local symbol cache and return the local path. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.BypassSystem32FileRedirection(System.String)">
            <summary>
            We may be a 32 bit app which has File system redirection turned on
            Morph System32 to SysNative in that case to bypass file system redirection         
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SymbolPath">
            <summary>
            The symbol path used to look up PDB symbol files.   Set when the reader is initialized.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SourcePath">
            <summary>
            The paths used to look up source files.  defaults to _NT_SOURCE_PATH.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SymbolCacheDirectory">
            <summary>
            Where symbols are downloaded if needed.   Derived from symbol path.  It is the first
            directory on the local machine in a SRV*DIR*LOC spec, and %TEMP%\Symbols otherwise.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SourceCacheDirectory">
            <summary>
            The place where source is downloaded from a source server.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.Options">
            <summary>
            Is this symbol reader limited to just the local machine cache or not?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.CacheUnsafeSymbols">
            <summary>
            Cache even the unsafe pdbs to the SymbolCacheDirectory. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SecurityCheck">
            <summary>
            We call back on this when we find a PDB by probing in 'unsafe' locations (like next to the EXE or in the Built location)
            If this function returns true, we assume that it is OK to use the PDB.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.Log">
            <summary>
            A place to log additional messages 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolModule">
            <summary>
            A symbolReaderModule represents a single PDB.   You get one from SymbolReader.OpenSymbolFile
            It is effecively a managed interface to the Debug Interface Access (DIA) see 
            http://msdn.microsoft.com/en-us/library/x93ctkx8.aspx for more.   I have only exposed what
            I need, and the interface is quite large (and not super pretty).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.FindNameForRva(System.UInt32)">
            <summary>
            Finds a (method) symbolic name for a given relative virtual address of some code.  
            Returns an empty string if a name could not be found. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.FindNameForRva(System.UInt32,System.UInt32@)">
            <summary>
            Finds a (method) symbolic name for a given relative virtual address of some code.  
            Returns an empty string if a name could not be found.  
            symbolStartRva is set to the start of the symbol start 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.SourceLocationForRva(System.UInt32)">
            <summary>
            Fetches the source location (line number and file), given the relative virtual address (RVA)
            of the location in the executable.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.SourceLocationForRva(System.UInt32,System.String@,System.UInt32@,System.Int32@)">
            <summary>
            This overload of SourceLocationForRva like the one that takes only an RVA will return a source location
            if it can.   However this version has additional support for NGEN images.   In the case of NGEN images 
            for .NET V4.6.1 or later), the NGEN images can't convert all the way back to a source location, but they 
            can convert the RVA back to IL artifacts (ilAssemblyName, methodMetadataToken, iloffset).  THese can then
            be used to look up the source line using the IL PDB.  
            
            Thus if the return value from this is null, check to see if the ilAssemblyName is non-null, and if not 
            you can look up the source location using that information.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.SourceLocationForManagedCode(System.UInt32,System.Int32)">
            <summary>
            Managed code is shipped as IL, so RVA to NATIVE mapping can't be placed in the PDB. Instead
            what is placed in the PDB is a mapping from a method's meta-data token and IL offset to source
            line number.  Thus if you have a metadata token and IL offset, you can again get a source location
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.GetSrcSrvStream">
            <summary>
            Gets the 'srcsvc' data stream from the PDB and return it in as a string.   Returns null if it is not present.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.GetMergedAssembliesMap">
            <summary>
            For Project N modules it returns the list of pre merged IL assemblies and the corresponding mapping.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.GetEmbeddedILImage">
            <summary>
            For ProjectN modules, gets the merged IL image embedded in the .PDB (only valid for single-file compilation)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.GetPseudoAssembly">
            <summary>
            For ProjectN modules, gets the pseudo-assembly embedded in the .PDB, if there is one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.GetFuncMDTokenMap">
            <summary>
            For ProjectN modules, gets the binary blob that describes the mapping from RVAs to methods.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolModule.GetTypeMDTokenMap">
            <summary>
            For ProjectN modules, gets the binary blob that describes the mapping from RVAs to types.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolModule.SymbolFilePath">
            <summary>
            The path name to the PDB itself
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolModule.ExePath">
            <summary>
            This is the EXE associated with the Pdb.  It may be null or an invalid path.  It is used
            to help look up source code (it is implicitly part of the Source Path search) 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolModule.GlobalSymbol">
            <summary>
            The symbol representing the module as a whole.  All global symbols are children of this symbol 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolModule.PdbGuid">
            <summary>
            The a unique identifier that is used to relate the DLL and its PDB.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolModule.PdbAge">
            <summary>
            Along with the PdbGuid, there is a small integer 
            call the age is also used to find the PDB (it represents the different 
            post link transformations the DLL has undergone).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolModule.SymbolReader">
            <summary>
            The symbol reader this SymbolModule was created from.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.Symbol">
            <summary>
            Represents a single symbol in a PDB file.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.InSameSection(Microsoft.Diagnostics.Symbols.Symbol,Microsoft.Diagnostics.Symbols.Symbol)">
            <summary>
            Returns true if the two symbols live in the same linker section (e.g. text,  data ...)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.GetChildren">
            <summary>
            Returns the children of the symbol.  Will return null if there are no children.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.GetChildren(Dia2Lib.SymTagEnum)">
            <summary>
            Returns the children of the symbol, with the given tag.  Will return null if there are no children.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.CompareTo(Microsoft.Diagnostics.Symbols.Symbol)">
            <summary>
            Compares the symbol by their relative virtual address (RVA)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.ToString">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.Name">
            <summary>
            The name for the symbol 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.RVA">
            <summary>
            The relative virtual address (offset from the image base when loaded in memory) of the symbol
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.Tag">
            <summary>
            The Tag is the kind of symbol it is (See SymTagEnum for more)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.Length">
            <summary>
            The length of the memory that the symbol represents.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.Id">
            <summary>
            A small integer identifier tat is unique for that symbol in the DLL. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.UndecoratedName">
            <summary>
            Decorated names are names that most closely resemble the source code (have overloading).  
            However when the linker does not directly support all the expressiveness of the
            source language names are encoded to represent this.   This return this encoded name. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolReaderOptions">
            <summary>
            SymbolReaderFlags indicates preferences on how aggressively symbols should be looked up.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Symbols.SymbolReaderOptions.None">
            <summary>
            No options this is the common case, where you want to look up everything you can. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Symbols.SymbolReaderOptions.CacheOnly">
            <summary>
            Only fetch the PDB if it lives in the symbolCacheDirectory (is local an is generated).  
            This will generate NGEN pdbs unless the NoNGenPDBs flag is set. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Symbols.SymbolReaderOptions.NoNGenSymbolCreation">
            <summary>
            No NGEN PDB generation.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SourceFile">
            <summary>
            A source file represents a source file from a PDB.  This is not just a string
            because the file has a build time path, a checksum, and it needs to be 'smart'
            to copy down the file if requested.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.GetSourceFile(System.Boolean)">
            <summary>
            This may fetch things from the source server, and thus can be very slow, which is why it is not a property. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.GetSourceFromSrcServer">
            <summary>
            Try to fetch the source file associated with 'buildTimeFilePath' from the symbol server 
            information from the PDB from 'pdbPath'.   Will return a path to the returned file (uses 
            SourceCacheDirectory associated symbol reader for context where to put the file), 
            or null if unsuccessful.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.FindTfExe">
            <summary>
            Returns the location of the tf.exe executable or 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.BuildTimeFilePath">
            <summary>
            The path of the file at the time the source file was built. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.HasChecksum">
            <summary>
            true if the PDB has a checksum for the data in the source file. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.ChecksumMatches">
            <summary>
            If GetSourceFile is called and 'requireChecksumMatch' == false then you can call this property to 
            determine if the checksum actually matched or not.   This will return true if the original
            PDB does not have a checksum (HasChecksum == false)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SourceLocation">
            <summary>
            A SourceLocation represents a point in the source code.  That is the file and the line number.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceLocation.SourceFile">
            <summary>
            The source file for the code
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceLocation.LineNumber">
            <summary>
            The line number for the code.
            </summary>
        </member>
        <member name="T:Dia2Lib.DiaLoader">
            <summary>
            The DiaLoader class knows how to load the msdia140.dll (the Debug Access Interface) (see docs at
            http://msdn.microsoft.com/en-us/library/x93ctkx8.aspx), without it being registered as a COM object.
            Basically it just called the DllGetClassObject interface directly.
            
            It has one public method 'GetDiaSourceObject' which knows how to create a IDiaDataSource object. 
            From there you can do anything you need.  
            
            In order to get IDiaDataSource3 which includes'getStreamSize' API, you need to use the 
            vctools\langapi\idl\dia2_internal.idl file from devdiv to produce Interop.Dia2Lib.dll
            
            roughly what you need to do is 
                copy vctools\langapi\idl\dia2_internal.idl .
                copy vctools\langapi\idl\dia2.idl .
                copy vctools\langapi\include\cvconst.h .
                Change dia2.idl to include interface IDiaDataSource3 inside library Dia2Lib->importlib->coclass DiaSource
                midl dia2_internal.idl /D CC_DP_CXX
                tlbimp dia2_internal.tlb
                xcopy Dia2Lib.dll Interop.Dia2Lib.dll
            </summary>
        </member>
        <member name="M:Dia2Lib.DiaLoader.GetDiaSourceObject">
            <summary>
            Load the msdia100 dll and get a IDiaDataSource from it.  This is your gateway to PDB reading.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser">
            <summary>
            A DynamicTraceEventParser is a parser that understands how to read the embedded manifests that occur in the 
            dataStream (System.Diagnostics.Tracing.EventSources do this).   
            
            See also TDHDynamicTraceEventParser which knows how to read the manifest that are registered globally with
            the machine.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.ManifestEventID">
            <summary>
            The event ID for the EventSource manifest emission event.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource)">
            <summary>
            Create a new DynamicTraceEventParser (which can parse ETW providers that dump their manifests
            to the ETW data stream) an attach it to the ETW data stream 'source'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.AddDynamicProvider(Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest,System.Boolean)">
            <summary>
            Given a manifest describing the provider add its information to the parser.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.WriteAllManifests(System.String)">
            <summary>
            Utility method that stores all the manifests known to the DynamicTraceEventParser to the directory 'directoryPath'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.ReadAllManifests(System.String)">
            <summary>
            Utility method that read all the manifests the directory 'directoryPath' into the parser.   
            Manifests must end in a .man or .manifest.xml suffix.   It will throw an error if
            the manifest is incorrect or using unsupported options.  
            </summary>        
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.GetProviderName">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.CheckForDynamicManifest(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Called on unhandled events to look for manifests.    Returns true if we added a new manifest (which may have updated the lookup table)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.EnumerateTemplates(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Override 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.DynamicProviders">
            <summary>
            Returns a list of providers (their manifest) that this TraceParser knows about.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.IsStatic">
            <summary>
            Override.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.DynamicProviderAdded">
            <summary>
            This event, will be fired any time a new Provider is added to the table
            of ETW providers known to this DynamicTraceEventParser.   This includes
            when the EventSource manifest events are encountered as well as any
            explicit calls to AddDynamicProvider.  (including ReadAllManifests).
            
            The Parser will filter out duplicate manifest events, however if an
            old version of a provider's manifest is encountered, and later a newer
            version is encountered, you can receive this event more than once for
            a single provider.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData">
            <summary>
            DynamicTraceEventData is an event that knows how to take runtime information to parse event fields (and payload)
            
            This meta-data is distilled down to a array of field names and an array of PayloadFetches which contain enough
            information to find the field data in the payload blob.   This meta-data is used in the 
            DynamicTraceEventData.PayloadNames and DynamicTraceEventData.PayloadValue methods.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.Dispatch">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadValue(System.Int32)">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadString(System.Int32,System.IFormatProvider)">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.GetCountForArray(Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch,Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetchArrayInfo,System.Int32@)">
            <summary>
            Returns the count of elements for the array represented by 'arrayInfo'
            It also will adjust 'offset' so that it points at the beginning of the
            array data (skips past the count). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadNames">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.Target">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.FormattedMessage">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.StructValue">
            <summary>
             Used by PayloadValue to represent a structure.   It is basically a IDictionary with a ToString() that 
             returns the value as JSON. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.StructValue.Quote(System.Text.StringBuilder,System.String)">
            <summary>
             Uses C style conventions to quote a string 'value' and append to the string builder 'sb'.
             Thus all \ are turned into \\ and all " into \"
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.#ctor(System.UInt16,System.UInt16,System.Type,System.Collections.Generic.IDictionary{System.Int64,System.String})">
            <summary>
            Constructor for normal types, (int, string) ...)   Also handles Enums (which are ints with a map)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.#ctor(System.UInt16,Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhInputType,System.Int32)">
            <summary>
            Initialized a PayloadFetch for a given inType.  REturns Size = DynamicTraceEventData.UNKNOWN_SIZE
            if the type is unknown.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.ArrayPayloadFetch(System.UInt16,Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch,System.UInt16)">
            <summary>
            Returns a payload fetch for a Array.   If you know the count, then you can give it. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.Offset">
            <summary>
            Offset from the beginning of the struct.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.LazyMap">
            <summary>
            LazyMap allow out to set a function that returns a map 
            instead of the map itself.   This will be evaluated when the map
            is fetched (which gives time for the map table to be populated.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicManifestTraceEventData">
            <summary>
            This class is only used to pretty-print the manifest event itself.   It is pretty special purpose
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParserState">
            <summary>
            DynamicTraceEventParserState represents the state of a  DynamicTraceEventParser that needs to be
            serialized to a log file.  It does NOT include information about what events are chosen but DOES contain
            any other necessary information that came from the ETL data file.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest">
            <summary>
            A ProviderManifest represents the XML manifest associated with the provider.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Read a ProviderManifest from a stream
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.#ctor(System.String)">
            <summary>
            Read a ProviderManifest from a file. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ValidateManifest">
            <summary>
            Normally ProviderManifest will fail silently if there is a problem with the manifest.  If
            you want to see this error you can all this method to force it explicitly  It will
            throw if there is a problem parsing the manifest.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.WriteToStream(System.IO.Stream)">
            <summary>
            Writes the manifest to 'outputStream' (as UTF8 XML text)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.WriteToFile(System.String)">
            <summary>
            Writes the manifest to a file 'filePath' (as a UTF8 XML)
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ToString">
            <summary>
            For debugging
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ParseProviderEvents(System.Func{Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Boolean)">
            <summary>
            Call 'callback the the parsed templates for this provider.  If 'callback' returns RejectProvider, bail early
            Note that the DynamicTraceEventData passed to the delegate needs to be cloned if you use subscribe to it.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.GetTypeForManifestTypeName(System.String)">
            <summary>
            Returns the .NET type corresponding to the manifest type 'manifestTypeName'
            Returns null if it could not be found. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Init">
            <summary>
            Initialize the provider.  This means to advance the instance variable 'reader' until it it is at the 'provider' node
            in the XML.   It also has the side effect of setting the name and guid.  The rest waits until events are registered. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ISDynamic">
            <summary>
             Set if this manifest came from the ETL data stream file.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Name">
            <summary>
            The name of the ETW provider
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Guid">
            <summary>
            The GUID that uniquey identifies the ETW provider
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Version">
            <summary>
            The version is defined as the sum of all the version numbers of event version numbers + the number of events defined. 
            This has the property that if you follow correct versioning protocol (all versions for a linear sequence where a new  
            versions is only modifies is predecessor by adding new events or INCREASEING the version numbers of existing events) 
            then the version number defined below will always strictly increase.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Manifest">
            <summary>
            Retrieve manifest as one big string.  Mostly for debugging
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ManifestReader">
            <summary>
            Retrieve the manifest as XML
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource">
            <summary>
            A ETWTraceEventSource represents the stream of events that was collected from a
            TraceEventSession (eg the ETL moduleFile, or the live session event stream). Like all
            TraceEventSource, it logically represents a stream of TraceEvent s. Like all
            TraceEventDispathers it supports a callback model where Parsers attach themselves to this
            sources, and user callbacks defined on the parsers are called when the 'Process' method is called.
            
            * See also TraceEventDispatcher
            * See also TraceEvent
            * See also #ETWTraceEventSourceInternals
            * See also #ETWTraceEventSourceFields
            </summary>    
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.String)">
            <summary>
            Open a ETW event trace moduleFile (ETL moduleFile) for processing.  
            </summary>
            <param name="fileName">The ETL data moduleFile to open</param>` 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.String,Microsoft.Diagnostics.Tracing.TraceEventSourceType)">
            <summary>
            Open a ETW event source for processing.  This can either be a moduleFile or a real time ETW session
            </summary>
            <param name="fileOrSessionName">
            If type == ModuleFile this is the name of the moduleFile to open.
            If type == Session this is the name of real time session to open.</param>
            <param name="type"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Process all the files in 'fileNames' in order (that is all the events in the first
            file are processed, then the second ...).   Intended for parsing the 'Multi-File' collection mode. 
            </summary>
            <param name="fileNames">The list of files path names to process (in that order)</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Process">
            <summary>
            Processes all the events in the data source, issuing callbacks that were subscribed to.  See
            #Introduction for more
            </summary>
            <returns>false If StopProcesing was called</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ReprocessEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Reprocess a pre-constructed event which this processor has presumably created. Helpful to re-examine
            "unknown" events, perhaps after a manifest has been received from the ETW stream.
            Note when queuing events to reprocess you must <see cref="M:Microsoft.Diagnostics.Tracing.TraceEvent.Clone">Clone</see> them first
            or certain internal data may no longer be available and you may receive memory access violations.
            </summary>
            <param name="ev">Event to re-process.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.SynchronizeClock">
            <summary>
            This routine is only useful/valid for real-time sessions.  
            
            TraceEvent.TimeStamp internally is stored using a high resolution clock called the Query Performance Counter (QPC).
            This clock is INDEPENDENT of the system clock used by DateTime.   These two clocks are synchronized to within 2 msec at 
            session startup but they can drift from there (typically 2msec / min == 3 seconds / day).   Thus if you have long
            running real time session it becomes problematic to compare the timestamps with those in another session or something
            timestamped with the system clock.   SynchronizeClock will synchronize the TraceEvent.Timestamp clock with the system
            clock again.   If you do this right before you start another session, then the two sessions will be within 2 msec of
            each other, and their timestamps will correlate.     Doing it periodically (e.g. hourly), will keep things reasonably close.  
            
            TODO: we can achieve perfect synchronization by exposing the QPC tick sync point so we could read the sync point 
            from one session and set that exact sync point for another session.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.GetModulesNeedingSymbols(System.String,Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions)">
            <summary>
            Given an ETL file, returns a list of the full paths to DLLs that were loaded in the trace that need symbolic 
            information (PDBs) so that the stack traces and CPU samples can be properly resolved.   By default this only
            returns NGEN images since these are the ones that need to be resolved and generated at collection time.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Dispose(System.Boolean)">
            <summary>
            see Dispose pattern
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Finalize">
            <summary>
            see Dispose pattern
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.lockObj">
            <summary>
            Used by real time TraceLog on Windows7.   
            If we have several real time sources we have them coming in on several threads, but we want the illusion that they
            are one source (thus being processed one at a time).  Thus we want a lock that is taken on every dispatch.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.LogFileName">
            <summary> 
            The log moduleFile that is being processed (if present)
            TODO: what does this do for Real time sessions?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.SessionName">
            <summary>
            The name of the session that generated the data. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Size">
            <summary>
            The size of the log, will return 0 if it does not know. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.EventsLost">
            <summary>
            returns the number of events that have been lost in this session.    Note that this value is NOT updated
            for real time sessions (it is a snapshot).  Instead you need to use the TraceEventSession.EventsLost property. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.CanReset">
            <summary>
            Returns true if the Process can be called multiple times (if the Data source is from a
            moduleFile, not a real time stream.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions">
            <summary>
            Options that can be passed to GetModulesNeedingSymbols
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions.OnlyNGENImages">
            <summary>
            This is the default, where only NGEN images are included (since these are the only images whose PDBS typically
            need to be resolved agressively AT COLLECTION TIME)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions.IncludeUnmanagedModules">
            <summary>
            If set, this option indicates that non-NGEN images should also be included in the list of returned modules
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions.IncludeModulesWithOutSamples">
            <summary>
            Normally only modules what have a CPU or stack sample are included in the list of assemblies (thus you don't 
            unnecessarily have to generate NGEN PDBS for modules that will never be looked up).  However if there are 
            events that have addresses that need resolving that this routine does not recognise, this option can be
            set to insure that any module that was event LOADED is included.   This is inefficient, but guarenteed to
            be complete
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ImageData">
            <summary>
            Image data is a trivial record for image data, where it is keyed by the base address, processID and name.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.QPCTime">
            <summary>
            This is a little helper class that maps QueryPerformanceCounter (QPC) ticks to DateTime.  There is an error of
            a few msec, but as long as every one uses the same one, we probably don't care.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventSourceType">
            <summary>
            The kinds of data sources that can be opened (see ETWTraceEventSource)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventSourceType.MergeAll">
            <summary>
            Look for any files like *.etl or *.*.etl (the later holds things like *.kernel.etl or *.clrRundown.etl ...)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventSourceType.FileOnly">
            <summary>
            Look for a ETL moduleFile *.etl as the event data source 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventSourceType.Session">
            <summary>
            Use a real time session as the event data source.
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ManifestEnvelope">
            <summary>
            Used to send the rawManifest into the event stream as a series of events.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkNodeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkNodeValues 
            points the the data in BulkNodeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkNodeValues">
            <summary>
            This structure just POINTS at the data in the BulkNodeTraceData.  It can only be used as long as
            the BulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkAttributeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkAttributeValues 
            points the the data in BulkAttributeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkAttributeValues">
            <summary>
            This structure just POINTS at the data in the BulkAttributeTraceData.  It can only be used as long as
            the BulkAttributeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkEdgeValues 
            points the the data in BulkEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkEdgeValues">
            <summary>
            This structure just POINTS at the data in the BulkNodeTraceData.  It can only be used as long as
            the BulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="T:PEFile.PEFile">
            <summary>
            PEFile is a reader for the information in a Portable Exectable (PE) FILE.   This is what EXEs and DLLs are.  
            
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:PEFile.PEFile.#ctor(System.String)">
            <summary>
            Create a new PEFile header reader that inspects the 
            </summary>
        </member>
        <member name="M:PEFile.PEFile.GetPdbSignature(System.String@,System.Guid@,System.Int32@,System.Boolean)">
            <summary>
            Looks up the debug signature information in the EXE.   Returns true and sets the parameters if it is found. 
            
            If 'first' is true then the first entry is returned, otherwise (by default) the last entry is used 
            (this is what debuggers do today).   Thus NGEN images put the IL PDB last (which means debuggers 
            pick up that one), but we can set it to 'first' if we want the NGEN PDB.
            </summary>
        </member>
        <member name="M:PEFile.PEFile.GetFileVersionInfo">
            <summary>
            Gets the File Version Information that is stored as a resource in the PE file.  (This is what the
            version tab a file's property page is populated with).  
            </summary>
        </member>
        <member name="M:PEFile.PEFile.GetSxSManfest">
            <summary>
            For side by side dlls, the manifest that decribes the binding information is stored as the RT_MANIFEST resource, and it
            is an XML string.   This routine returns this.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:PEFile.PEFile.Dispose">
            <summary>
            Closes any file handles and cleans up resources.  
            </summary>
        </member>
        <member name="P:PEFile.PEFile.Header">
            <summary>
            The Header for the PE file.  This contains the infor in a link /dump /headers 
            </summary>
        </member>
        <member name="T:PEFile.PEHeader">
            <summary>
            A PEHeader is a reader of the data at the beginning of a PEFile.    If the header bytes of a 
            PEFile are read or mapped into memory, this class can parse it when given a poitner to it. 
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.#ctor(System.Void*)">
            <summary>
            Returns a PEHeader for void* pointer in memory.  It does NO validity checking. 
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.VirtualAddressToRva(System.Void*)">
            <summary>
            Given a virtual address to data in a mapped PE file, return the relative virtual address (displacement from start of the image)
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.RvaToVirtualAddress(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return the virtual address to data in a mapped PE file
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.RvaToFileOffset(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return a offset in the file data for that data.  
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.Directory(System.Int32)">
            <summary>
            Returns the data directory (virtual address an blob, of a data directory with index 'idx'.   14 are currently defined.
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.PEHeaderSize">
            <summary>
            The total s,ize of the header,  including section array of the the PE header.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.IsPE64">
            <summary>
            Returns true if this is PE file for a 64 bit architecture.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.IsManaged">
            <summary>
            Returns true if this file contains managed code (might also contain native code). 
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Signature">
            <summary>   
            Returns the 'Signature' of the PE HEader PE\0\0 = 0x4550, used for sanity checking.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Machine">
            <summary>
            The machine this PE file is intended to run on 
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.NumberOfSections">
            <summary>
            PE files have a number of sections that represent regions of memory with the access permisions.  This is the nubmer of such sections.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.TimeDateStampSec">
            <summary>
            The the PE file was created represented as the number of seconds since Jan 1 1970 
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.TimeDateStamp">
            <summary>
            The the PE file was created represented as a DateTime object
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.PointerToSymbolTable">
            <summary>
            PointerToSymbolTable (see IMAGE_FILE_HEADER in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.NumberOfSymbols">
            <summary>
            NumberOfSymbols (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfOptionalHeader">
            <summary>
            SizeOfOptionalHeader (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Characteristics">
            <summary>
            Characteristics (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Magic">
            <summary>
            Magic (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorLinkerVersion">
            <summary>
            MajorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorLinkerVersion">
            <summary>
            MinorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfCode">
            <summary>
            SizeOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfInitializedData">
            <summary>
            SizeOfInitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfUninitializedData">
            <summary>
            SizeOfUninitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.AddressOfEntryPoint">
            <summary>
            AddressOfEntryPoint (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.BaseOfCode">
            <summary>
            BaseOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ImageBase">
            <summary>
            ImageBase (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SectionAlignment">
            <summary>
            SectionAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.FileAlignment">
            <summary>
            FileAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorOperatingSystemVersion">
            <summary>
            MajorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorOperatingSystemVersion">
            <summary>
            MinorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorImageVersion">
            <summary>
            MajorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorImageVersion">
            <summary>
            MinorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorSubsystemVersion">
            <summary>
            MajorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorSubsystemVersion">
            <summary>
            MinorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Win32VersionValue">
            <summary>
            Win32VersionValue (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfImage">
            <summary>
            SizeOfImage (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfHeaders">
            <summary>
            SizeOfHeaders (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.CheckSum">
            <summary>
            CheckSum (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Subsystem">
            <summary>
            Subsystem (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.DllCharacteristics">
            <summary>
            DllCharacteristics (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfStackReserve">
            <summary>
            SizeOfStackReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfStackCommit">
            <summary>
            SizeOfStackCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfHeapReserve">
            <summary>
            SizeOfHeapReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfHeapCommit">
            <summary>
            SizeOfHeapCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.LoaderFlags">
            <summary>
            LoaderFlags (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.NumberOfRvaAndSizes">
            <summary>
            NumberOfRvaAndSizes (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ExportDirectory">
            <summary>
            Returns the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ImportDirectory">
            <summary>
            Returns the data directory for DLL Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ResourceDirectory">
            <summary>
            Returns the data directory for DLL Resources see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ExceptionDirectory">
            <summary>
            Returns the data directory for DLL Exceptions see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.CertificatesDirectory">
            <summary>
            Returns the data directory for DLL securiy certificates (Authenticode) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.BaseRelocationDirectory">
            <summary>
            Returns the data directory Image Base Relocations (RELOCS) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.DebugDirectory">
            <summary>
            Returns the data directory for Debug information see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ArchitectureDirectory">
            <summary>
            Returns the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.GlobalPointerDirectory">
            <summary>
            Returns the data directory for GlobalPointer (IA64) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ThreadStorageDirectory">
            <summary>
            Returns the data directory for THread local storage see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.LoadConfigurationDirectory">
            <summary>
            Returns the data directory for Load Configuration see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.BoundImportDirectory">
            <summary>
            Returns the data directory for Bound Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ImportAddressTableDirectory">
            <summary>
            Returns the data directory for the DLL Import Address Table (IAT) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.DelayImportDirectory">
            <summary>
            Returns the data directory for Delayed Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ComDescriptorDirectory">
            <summary>
             see PE file spec for more .NET Runtime infomration.  
            </summary>
        </member>
        <member name="T:PEFile.MachineType">
            <summary>
            The Machine types supported by the portable executable (PE) File format
            </summary>
        </member>
        <member name="F:PEFile.MachineType.Native">
            <summary>
            Unknown machine type
            </summary>
        </member>
        <member name="F:PEFile.MachineType.X86">
            <summary>
            Intel X86 CPU 
            </summary>
        </member>
        <member name="F:PEFile.MachineType.ia64">
            <summary>
            Intel IA64 
            </summary>
        </member>
        <member name="F:PEFile.MachineType.ARM">
            <summary>
            ARM 32 bit 
            </summary>
        </member>
        <member name="F:PEFile.MachineType.Amd64">
            <summary>
            Arm 64 bit 
            </summary>
        </member>
        <member name="T:PEFile.IMAGE_DATA_DIRECTORY">
            <summary>
            Represents a Portable Executable (PE) Data directory.  This is just a well known optional 'Blob' of memory (has a starting point and size)
            </summary>
        </member>
        <member name="F:PEFile.IMAGE_DATA_DIRECTORY.VirtualAddress">
            <summary>
            The start of the data blob when the file is mapped into memory
            </summary>
        </member>
        <member name="F:PEFile.IMAGE_DATA_DIRECTORY.Size">
            <summary>
            The length of the data blob.  
            </summary>
        </member>
        <member name="T:PEFile.FileVersionInfo">
            <summary>
            FileVersionInfo represents the extended version formation that is optionally placed in the PE file resource area. 
            </summary>
        </member>
        <member name="P:PEFile.FileVersionInfo.FileVersion">
            <summary>
            The verison string 
            </summary>
        </member>
        <member name="T:PEFile.PEBuffer">
            <summary>
            A PEBuffer represents a buffer (efficient) scanner of the 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTree">
            <summary>
            SampleInfos of a set of stackSource by eventToStack.  This represents the entire call tree.   You create an empty one in using
            the default constructor and use 'AddSample' to add stackSource to it.   You traverse it by 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.#ctor(Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind)">
            <summary>
            Creates an empty call tree, indicating the scaling policy of the metric.   You populate it by assigning a StackSOurce to the tree.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.CallerCallee(System.String)">
            <summary>
            Get a CallerCalleeNode for the nodes in the call tree named 'nodeName'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ByIDSortedExclusiveMetric">
            <summary>
            Returns the list returned by the ByID property sorted by exclusive metric.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.FoldNodesUnder(System.Single,System.Boolean)">
            <summary>
            If there are any nodes that have strictly less than to 'minInclusiveMetric'
            then remove the node, placing its samples into its parent (thus the parent's
            exclusive metric goes up).  
            
            If useWholeTraceMetric is true, nodes are only folded if their inclusive metric
            OVER THE WHOLE TRACE is less than 'minInclusiveMetric'.  If false, then a node
            is folded if THAT NODE has less than the 'minInclusiveMetric'  
            
            Thus if 'useWholeTraceMetric' == false then after calling this routine no
            node will have less than minInclusiveMetric.  
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.Sort(System.Comparison{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            Cause the children of each CallTreeNode in the CallTree to be sorted (accending) based on comparer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.SortInclusiveMetricDecending">
            <summary>
            Sorting by InclusiveMetric Decending is so common, provide a shortcut.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.FreeMemory">
            <summary>
            Break all links in the call tree to free as much memory as possible.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ToXml(System.IO.TextWriter)">
            <summary>
            Write an XML representtaion of the CallTree to 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ToString">
            <summary>
            An XML representtaion of the CallTree (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.AccumulateSumByID(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Collections.Generic.Dictionary{System.Int32,Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase})">
            <summary>
            Traverse the subtree of 'treeNode' into the m_sumByID dictionary.   We don't want to
            double-count inclusive times, so we have to keep track of all callers currently on the
            stack and we only add inclusive times for nodes that are not already on the stack.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.StackSource">
            <summary>
            A CallTree is generated from a StackSource.  Setting the StackSource causes the tree to become populated.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.PercentageBasis">
            <summary>
            When calculating percentages, the PercentageBasis do we use as 100%.  By default we use the
            Inclusive time for the root, but that can be changed here.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.Root">
            <summary>
            Returns the root node of the call tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.NodeIndexLimit">
            <summary>
            An upper bound for the node indexes in the call tree.  (All indexes
            are strictly less than this number)   Thus ASSSUMING YOU DON'T ADD
            NEW NODES, an array of this size can be used to index the nodes (and 
            thus lookup nodes by index or to store additional information about a node).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ByID">
            <summary>
            Returns a list of nodes that have statistics rolled up by treeNode by ID.  It is not
            sorted by anything in particular.   Note that ID is not quite the same thing as the 
            name.  You can have two nodes that have different IDs but the same Name.  These 
            will show up as two distinct entries in the resulting list.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ScalingPolicy">
            <summary>
            When converting the InclusiveMetricByTime to a InclusiveMetricByTimeString you have to decide 
            how to scale the samples to the digits displayed in the string.  This enum indicates this policy
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.TimeHistogramController">
            <summary>
            The nodes in the calltree have histograms in time, all of these histograms share a controller that
            contains sharable information.   This propertly returns that TimeHistogramController
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ScenarioHistogram">
            <summary>
            The nodes in the calltree have histograms indexed by scenario (which is user defiend), 
            all of these histograms share a controller that contains sharable information.   
            This propertly returns that ScenarioHistogramController
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.DisableParallelism">
            <summary>
            Turns off logic for computing call trees in parallel.   Safer but slower.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind">
            <summary>
            ScalingPolicyKind represents the desired way to scale the metric in the samples.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind.ScaleToData">
            <summary>
            This is the default.  In this policy, 100% is chosen so that the histogram is scaled as best it can.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind.TimeMetric">
            <summary>
            It assumes that the metric represents time 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeIndex">
            <summary>
            Represents a unique ID for a node in a call tree.  Can be used to look up a call tree node easily.  
            It is a dense value (from 0 up to a maximum).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeIndex.Invalid">
            <summary>
            An Invalid Node Index.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase">
            <summary>
            A  CallTreeNodeBase is the inforation in a CallTreeNode without parent or child relationships.  
            ByName nodes and Caller-Callee nodes need this because they either don't have or need different 
            parent-child relationships. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase)">
            <summary>
            Create a CallTreeNodeBase (a CallTreeNode without children) which is a copy of another one.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.GetSamples(System.Boolean,System.Func{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,System.Boolean})">
            <summary>
            Returns all the original stack samples in this node.  If exclusive==true then just he
            sample exclusively in this node are returned, otherwise it is the inclusive samples.   
            
            If the original stack source that was used to create this CodeTreeNode was a FilterStackSource
            then that filtering is removed in the returned Samples.  
            
            Returns the total number of samples (the number of times 'callback' is called)
            
            If the callback returns false, the iteration over samples stops. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.GetTrees(System.Action{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            While 'GetSamples' can return all the samples in the tree, this is a relatively
            inefficient way of representing the samples.   Instead you can return a list of
            trees whose samples represent all the samples.   This is what GetTrees does.
            It calls 'callback' on a set of trees that taken as a whole have all the samples
            in 'node'.  
            
            Note you ave to be careful when using this for inclusive summation of byname nodes because 
            you will get trees that 'overlap' (bname nodes might refer into the 'middle' of another
            call tree).   This can be avoided pretty easily by simply stopping inclusive traversal 
            whenever a tree node with that ID occurs (see GetSamples for an example). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ToXmlAttribs(System.IO.TextWriter)">
            <summary>
            Returns a string representing the set of XML attributes that can be added to another XML element.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ToString">
            <summary>
            An XML representation of the CallTreeNodeBase (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.FreeMemory">
            <summary>
            The GUI sadly holds on to Call things in the model in its cache, and call tree nodes have linkes to whole
            call tree.  To avoid the GUI cache from holding on to the ENTIRE MODEL, we neuter the nodes when we are
            done with them so that even if they are pointed to by the GUI cache it does not hold onto most of the 
            (dead) model.    FreeMemory does this neutering.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.CombineByIdSamples(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Combines the 'this' node with 'otherNode'.   If 'newOnStack' is true, then the inclusive
            metrics are also updated.  
            
            Note that I DON'T accumulate other.m_samples into this.m_samples.   This is because we want to share
            samples as much a possible.  Thus nodes remember their samples by pointing at other call trees
            and you fetch the samples by an inclusive walk of the tree.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.GetSamplesForTreeNode(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Boolean,System.Func{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,System.Boolean},Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            To avoid double-counting for byname nodes, with we can be told to exclude any children with a particular ID 
            (the ID of the ByName node itself) if are doing the inclusive case.   The goal is to count every reachable
            tree exactly once.  We do this by conceptually 'marking' each node with ID at the top level (when they are 
            enumerated as children of the Byname node), and thus any node with that excludeChildrenWithID is conceptually
            marked if you encounter it as a child in the tree itself (so you should exclude it).  The result is that 
            every node is visited exactly once (without the expense of having a 'visited' bit).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.Index">
            <summary>
            Returns a unique small, dense number (suitable for looking up in an array) that represents 
            this call tree node (unlike the ID, which more like the name of the frame of the node), so you
            can have many nodes with the same name, but only one with the same index.    See CallTree.GetNodeIndexLimit.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.Name">
            <summary>
            The Frame name that this tree node represents.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.DisplayName">
            <summary>
            Currently the same as Name, but could contain additional info.  
            Suitable for display but not for programmatic comparison.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ID">
             <summary>
             The ID represents a most fine grained uniqueness associated with this node.   It can represent
             a method, but for sources that support 'goto source' functionality these IDs actually represent
             particular lines (or more precisely program counter locations), within the method.    Thus it is 
             very likely that there are call tree nodes that have the same name but different IDs.  
             
             This can be StackSourceFrameIndex.Invalid for Caller-callee nodes (which have names, but no useful ID) 
            
             If ID != Invalid, and the IDs are the same then the names are guaranteed to be the same.  
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetric">
            <summary>
            The sum of the metric of all samples that are in this node or any child of this node (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.AverageInclusiveMetric">
            <summary>
            The average metric of all samples that are in this node or any child of this node (recursively).
            This is simply InclusiveMetric / InclusiveCount.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveMetric">
            <summary>
            The sum of the metric of all samples that are in this node 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveFoldedMetric">
            <summary>
            The sum of the metric of all samples in this node that are there because they were folded (inlined).   It is alwasy less than or equal to ExclusiveMetric.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveCount">
            <summary>
            The sum of the count of all samples that are in this node or any child of this node (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveCount">
            <summary>
            The sum of the count of all samples that are in this node 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveFoldedCount">
            <summary>
            The sum of the count of all samples in this node that are there because they were folded (inlined).   It is alwasy less than or equal to ExclusiveCount.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricPercent">
            <summary>
            The inclusive metric, normalized to the total metric for the entire tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveMetricPercent">
            <summary>
            The exclusive metric, normalized to the total metric for the entire tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveFoldedMetricPercent">
            <summary>
            The exclusive folded metric, normalized to the total metric for the entire tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.FirstTimeRelativeMSec">
            <summary>
            The time of the first sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.FirstTimeRelMSec">
            <summary>
            The time of the first sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.LastTimeRelativeMSec">
            <summary>
            The time of the last sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.LastTimeRelMSec">
            <summary>
            The time of the last sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.DurationMSec">
            <summary>
            The difference between the first and last sample (in MSec).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.CallTree">
            <summary>
            The call tree that contains this node.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByTime">
            <summary>
            Returns the histogram that groups of samples associated with this node or any of its children by time buckets
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByTimeString">
            <summary>
            Returns a string that represents the InclusiveMetricByTime Histogram by using character for every bucket (like PerfView)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByScenario">
            <summary>
            Returns the histogram that groups of samples associated with this node or any of its children by scenario buckets
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByScenarioString">
            <summary>
            Returns a string that represents the InclusiveMetricByScenario Histogram by using character for every bucket (like PerfView)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode">
            <summary>
            Represents a single treeNode in a CallTree 
            
            Each node keeps all the sample with the same path to the root.  
            Each node also remembers its parent (caller) and children (callees).
            The nodes also keeps the IDs of all its samples (so no information
            is lost, just sorted by stack).   You get at this through the
            CallTreeNodeBase.GetSamples method.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.ToXml(System.IO.TextWriter,System.String)">
            <summary>
            Writes an XML representation of the call tree Node  it 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.ToString">
            <summary>
            Returns an XML representation of the call tree Node (for debugging);
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.GetBrokenStackCount">
            <summary>
            Adds up the counts of all nodes called 'BROKEN' nodes in a particular tree node
            
            This is a utility function.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.IndentString(System.Boolean)">
            <summary>
            Creates a string that has spaces | and + signs that represent the indentation level 
            for the tree node.  (Called from XAML)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.FreeMemory">
            <summary>
            Implements CallTreeNodesBase interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.SortAll(System.Comparison{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            Sort the childre of every node in the te
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.GetCallees">
            <summary>
            Some calltrees already fill in their children, others do so lazily, in which case they 
            override this method.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.FoldNodesUnder(System.Single,System.Collections.Generic.Dictionary{System.Int32,Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase})">
            <summary>
            Fold away any nodes having less than 'minInclusiveMetric'.  If 'sumByID' is non-null then the 
            only nodes that have a less then the minInclusiveMetric for the whole trace are folded. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.Caller">
            <summary>
            The caller (parent) of this node
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.Callees">
            <summary>
            The nodes this node calls (its children). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.IsLeaf">
            <summary>
            Returns true if Callees is empty.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.AllCallees">
            <summary>
            AllCallees is an extension of CallTreesNodes to support graphs (e.g. memory heaps).   
            It always starts with the 'normal' Callees, however in addition if we are
            displaying a Graph, it will also children that were 'pruned' when the graph was 
            transformed into a tree.  (by using StackSource.GetRefs).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.HasChildren">
            <summary>
            Returns true if AllCallees is non-empty.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.IsGraphNode">
            <summary>
            Returns true if the call trees came from a graph (thus AllCallees may be strictly larger than Callees)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode">
            <summary>
            A CallerCalleeNode gives statistics that focus on a NAME.  (unlike calltrees that use ID)
            It takes all stackSource that have callStacks that include that treeNode and compute the metrics for
            all the callers and all the callees for that treeNode.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.#ctor(System.String,Microsoft.Diagnostics.Tracing.Stacks.CallTree)">
            <summary>
            Given a complete call tree, and a Name within that call tree to focus on, create a
            CallerCalleeNode that represents the single Caller-Callee view for that treeNode. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.ToXml(System.IO.TextWriter,System.String)">
            <summary>
            wrtites an XML representation of the call tree Node  it 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.ToString">
            <summary>
            Returns an XML representation of the CallerCalleeNode (for debugging);
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.FreeMemory">
            <summary>
            Implements CallTreeNodesBase interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.AccumlateSamplesForNode(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Int32,Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase@,System.Double@,System.Boolean@)">
            <summary>
            A caller callee view is a summation which centers around one 'focus' node which is represented by the CallerCalleeNode.
            This node has a caller and callee list, and these nodes (as well as the CallerCalleNode itself) represent the aggregation
            over the entire tree.
            
            AccumlateSamplesForNode is the routine that takes a part of a aggregated call tree (represented by 'treeNode' and adds
            in the statistics for that call tree into the CallerCalleeNode aggregations (and its caller and callee lists).  
            
            'recursionsCount' is the number of times the focus node name has occurred in the path from 'treeNode' to the root.   In 
            addition to setting the CallerCalleeNode aggregation, it also returns a 'weightedSummary' inclusive aggregation 
            FOR JUST treeNode (the CallerCalleNode is an aggregation over the entire call tree accumulated so far).  
            
            The key problem for this routine to avoid is double counting of inclusive samples in the face of recursive functions. 
            Thus all samples are weighted by the recursion count before being included in 'weightedSummaryRet (as well as in
            the CallerCalleeNode and its Callers and Callees).    
            
            An important optimization is the ability to NOT create (but rather reuse) CallTreeNodes when returning weightedSummaryRet.
            To accomplish this the weightedSummaryScaleRet is needed.  To get the correct numerical value for weightedSummaryRet, you 
            actually have to scale values by weightedSummaryScaleRet before use.   This allows us to represent weights of 0 (subtree has 
            no calls to the focus node), or cases where the subtree is completely uniform in its weighting (the subtree does not contain
            any additional focus nodes), by simply returning the tree node itself and scaling it by the recursion count).  
            
            isUniformRet is set to false if anyplace in 'treeNode' does not have the scaling factor weightedSummaryScaleRet.  This
            means the the caller cannot simply scale 'treeNode' by a weight to get weightedSummaryRet.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.Find(System.Collections.Generic.Dictionary{System.String,Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase}@,System.String)">
            <summary>
            Find the Caller-Callee treeNode in 'elems' with name 'frameName'.  Always succeeds because it
            creates one if necessary. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.Callers">
            <summary>
            The list of CallTreeNodeBase nodes that called the method represented by this CallerCalleeNode
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.Callees">
            <summary>
            The list of CallTreeNodeBase nodes that where called by the method represented by this CallerCalleeNode
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode">
            <summary>
            AggregateCallTreeNode supports a multi-level caller-callee view.   
            
            It does this by allow you to take any 'focus' node (typically a byname node)
            and compute a tree of its callers and a tree of its callees.   You do this
            by passing the node of interested to either the 'CallerTree' or 'CalleeTrees'.
            
            The AggregateCallTreeNode remembers if if is a caller or callee node and its
            'Callees' method returns the children (which may in fact be Callers). 
            
            What is nice about 'AggregateCallTreeNode is that it is lazy, and you only 
            form the part of the tree you actually explore.     A classic 'caller-callee' 
            view is simply the caller and callee trees only explored to depth 1.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.CallerTree(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase)">
            <summary>
            Given any node (typically a byName node, but it works on any node), Create a 
            tree rooted at 'node' that represents the callers of that node.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.CalleeTree(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase)">
            <summary>
            Given any node (typically a byName node, but it works on any node), Create a 
            tree rooted at 'node' that represents the callees of that node.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.GetTrees(System.Action{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            Calls 'callback' for each distinct call tree in this node.  Note that the same
            trees can overlap (in the case of recursive functions), so you need a mechanism
            for visiting a tree only once.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.ToString">
            <summary>
            Returns an XML representation of the AggregateCallTreeNode (for debugging);
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.FreeMemory">
            <summary>
            Implementation of CallTreeNodeBase interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.GetCallees">
            <summary>
            Implementation of CallTreeNode interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.MergeCaller(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode},System.Int32)">
            <summary>
            See m_callerOffset and MergeCallee for more.
            
            The 'this' node is a AggregateCallTree representing the 'callers' nodes.  Like 
            MergeCallee the aggregate node represents a list of CallTreeNodes.   However unlike
            MergeCallee, the list of CallTreeNodes each represent a sample (a complete call stack)
            and 'callerOffset' indicates how far 'up' that stack is the node of interest.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.MergeCallee(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            An aggregateCallTreeNode is exactly that, the sum of several callTrees
            (each of which represent a number of individual samples).    Thus we had to 
            take each sample (which is 'treenode' and merge it into the aggregate.
            We do this one at a time.   Thus we call MergeCallee for each calltree 
            in our list and we find the 'callees' of each of those nodes, and create 
            aggregates for the children (which is in calleeList).   
            
            This routine is not recursive and does not touch most of the tree but
            it does call SubtractOutTrees which is recursive and may look at a lot
            of the tree (although we try to minimize this)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.SubtractOutTrees(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode)">
            <summary>
            Traverse 'treeCallee' and subtract out the inclusive time for any tree that matches 'idToExclude' from the node 'statsRet'.
            This is needed in AggregateCallTrees because the same trees from the focus node are in the list to aggregate, but are also
            in the subtree's in various places (and thus are counted twice).   We solve this by walking this subtree (in this routine)
            and subtracting out any nodes that match 'idToExclude'.   
            
            As an optimization this routine also sets the m_recurision bit 'statsRet' if anywhere in 'treeCallee' we do find an id to 
            exclude.  That way in a common case (where there is no instances of 'idToExclude') we don't have to actualy walk the
            tree the second time (we simply know that there is no adjustment necessary.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.m_trees">
            <summary>
            An AggregateCallTree remembers all its samples by maintaining a list of call trees 
            that actually contain the samples that the Aggregate represents.  m_trees hold this.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.m_callerOffset">
            <summary>
            AggregateCallTreeNode can represent either a 'callers' tree or a 'callees' tree.   For 
            the 'callers' tree case the node represented by the aggregate does NOT have same ID as
            the tree in the m_trees list.   Instead the aggreegate is some node 'up the chain' toward 
            the caller.  m_callerOffset keeps track of this (it is the same number for all elements 
            in m_trees).   
            
            For callee nodes, this number is not needed.   Thus we use a illegal value (-1) to 
            represent that fact that the node is a callee node rather than a caller node.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.Histogram">
            <summary>
            A Histogram is logically an array of floating point values.  Often they
            represent frequency, but it can be some other metric.  The X axis can 
            represent different things (time, scenario).  It is the HisogramContoller
            which understands what the X axis is.   Histograms know their HistogramController
            but not the reverse.  
            
            Often Histograms are sparse (most array elements are zero), so the represnetation
            is designed to optimzed for this case (an array of non-zero index, value pairs). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.#ctor(Microsoft.Diagnostics.Tracing.Stacks.HistogramController)">
            <summary>
            Create a new histogram.  Every histogram needs a controller but these controllers 
            can be shared among many histograms.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to this histogram.
            </summary>
            <param name="sample">The sample to add.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddMetric(System.Single,System.Int32)">
            <summary>
            Add an amount to a bucket in this histogram.
            </summary>
            <param name="metric">The amount to add to the bucket.</param>
            <param name="bucket">The bucket to add to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddScaled(Microsoft.Diagnostics.Tracing.Stacks.Histogram,System.Double)">
            <summary>
            Computes this = this + histogram * weight in place (this is updated).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Clone">
            <summary>
            Make a copy of this histogram.
            </summary>
            <returns>An independent copy of this histogram.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.ToString">
            <summary>
            A string representation (for debugging)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.#ctor(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Create a histogram that is a copy of another histogram.
            </summary>
            <param name="other">The histogram to copy.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.GetEnumerator">
            <summary>
            Implementes IEnumerable interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementes IEnumerable interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.GetEnumerable">
            <summary>
            Get an IEnumerable that can be used to enumerate the metrics stored in the buckets of this Histogram.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.Histogram.m_controller">
            <summary>
            The controller for this histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Count">
            <summary>
            The number of buckets in this histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Controller">
            <summary>
            The <see cref="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramController"/> that controls this histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Item(System.Int32)">
            <summary>
            Get the metric contained in a bucket.
            </summary>
            <param name="index">The bucket to retrieve.</param>
            <returns>The metric contained in that bucket.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramController">
             <summary>
             A Histogram is conceputually an array of floating point values.   A Histogram Controller
             contains all the information besides the values themselves need to understand the array
             of floating point value.   There are alot of Histograms, however they all tend to share
             the same histogram controller.   Thus Histograms know their Histogram controller, but not
             the reverse.  
             
             Thus HistogramContoller is a abstract class (we have one for time, and one for scenarios).  
            
             HistogramControllers are responsible for:
             
             - Adding a sample to the histogram for a node (see <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)"/>)
             - Converting a histogram to its string representation see (<see cref="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)"/>)
             - Managing the size and scale of histograms and their corresponding display strings
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.InvalidateScale">
            <summary>
            Force recalculation of the scale parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to the histogram for a node.
            </summary>
            <param name="histogram">The histogram to add this sample to. Must be controlled by this HistogramController.</param>
            <param name="sample">The sample to add.</param>
            <remarks>
            Overriding classes are responsible for extracting the metric, scaling the metric,
            determining the appropriate bucket or buckets, and adding the metric to the histogram using <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddMetric(System.Single,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.GetInfoForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Gets human-readable information about a range of histogram characters.
            </summary>
            <param name="start">The start character index (inclusive).</param>
            <param name="end">The end character index (exclusive).</param>
            <param name="histogram">The histogram.</param>
            <returns>A string containing information about the contents of that character range.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Convert a histogram into its display string.
            </summary>
            <param name="histogram">The histogram to convert to a string.</param>
            <returns>A string suitable for GUI display.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.HistogramString(System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Double,System.Int32)">
            <summary>
            A utility function that turns an array of floats into a ASCII character graph.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.HistogramString(System.Single[],System.Double,System.Int32)">
            <summary>
            A utility function that turns an array of floats into a ASCII character graph.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTree)">
            <summary>
            Initialize a new HistogramController.
            </summary>
            <param name="tree">The CallTree that this HistogramController controls.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.CalculateScale">
            <summary>
            Calculate the scale factor for this histogram.
            </summary>
            <returns>The scale factor for this histogram.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.CalculateAverageScale(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Calculates an average scale factor for a histogram.
            </summary>
            <param name="hist">The root histogram to calculate against.</param>
            <returns>A scale factor that will normalize the maximum value to 200%.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.m_scale">
            <summary>
            The scale parameter. 0.0 if uncalculated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.Scale">
            <summary>
            The scale factor for histograms controlled by this HistogramController.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.BucketCount">
            <summary>
            The number of buckets in each histogram controlled by this HistogramController.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.CharacterCount">
            <summary>
            The number of characters in the display string for histograms controlled by this HistogramController.
            Buckets are a logial concept, where CharacterCount is a visual concept (how many you can see on the 
            screen right now).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.Tree">
            <summary>
            The CallTree managed by this HistogramController.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex">
            <summary>
            An enum representing a displayed histogram bucket (one character in a histogram string).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex.Invalid">
            <summary>
            A HistogramCharacterIndex can be used to represent error conditions 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController">
            <summary>
            A <see cref="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramController"/> that groups histograms by scenarios.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTree,System.Int32[],System.Int32,System.String[])">
            <summary>
            Initialize a new ScenarioHistogramController.
            </summary>
            <param name="tree">The CallTree to manage.</param>
            <param name="scenarios">An ordered array of scenario IDs to display.</param>
            <param name="totalScenarios">The total number of possible scenarios that can be supplied by the underlying StackSource.
            This number might be larger than the highest number in <paramref name="scenarios"/>.</param>
            <param name="scenarioNames">The names of the scenarios (for UI use).</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetScenariosForCharacterIndex(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex)">
            <summary>
            Get a list of scenarios contained in a given bucket.
            </summary>
            <param name="bucket">The bucket to look up.</param>
            <returns>The scenarios contained in that bucket.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetScenariosForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex)">
            <summary>
            Get a list of scenarios contained in a given bucket range.
            </summary>
            <param name="start">The start of the bucket range (inclusive).</param>
            <param name="end">The end of the bucket range (exclusive).</param>
            <returns>The scenarios contained in that range of buckets.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to a histogram controlled by this HistogramController.
            </summary>
            <param name="histogram">The histogram to add the sample to.</param>
            <param name="sample">The sample to add.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetNameForScenario(System.Int32)">
            <summary>
            Get the human-readable name for a scenario.
            </summary>
            <param name="scenario">The ID of the scenario to look up.</param>
            <returns>The human-readable name for that scenario.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetInfoForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Get the human-readable names for all scenarios contained in a range of histogram characters.
            </summary>
            <param name="start">The (inclusive) start index of the range.</param>
            <param name="end">The (exclusive) end index of the range.</param>
            <param name="histogram">The histogram.</param>
            <returns>A comma-separated list of scenario names contained in that range.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Convert a histogram into a string suitable for UI display.
            </summary>
            <param name="histogram">The histogram to convert.</param>
            <returns>A string representing the histogram that is suitable for UI display.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.CalculateScale">
            <summary>
            Calculate the scale factor for all histograms controlled by this ScenarioHistogramController.
            </summary>
            <returns>
            In the current implementation, returns a scale that normalizes 100% to half of the maximum value at the root.
            </returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.m_characterFromScenario">
            <summary>
            An array mapping each scenario to a bucket.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.m_scenariosFromCharacter">
            <summary>
            An array mapping each bucket to a list of scenarios.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.m_scenarioNames">
            <summary>
            An array mapping each scenario to its name.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController">
            <summary>
            A HistogramController holds all the information to understand the buckets of a histogram
            (basically everything except the array of metrics itself.   For time this is the
            start and end time  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTree,System.Double,System.Double)">
            <summary>
            Create a new TimeHistogramController.
            </summary>
            <param name="tree">The CallTree to control with this controller.</param>
            <param name="start">The start time of the histogram.</param>
            <param name="end">The end time of the histogram.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.GetStartTimeForBucket(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex)">
            <summary>
            Gets the start time for the histogram bucket represented by a character.
            </summary>
            <param name="bucket">The index of the character to look up.</param>
            <returns>The start time of the bucket represented by the character.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.CalculateScale">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.GetInfoForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.Start">
            <summary>
            The start time of the histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.End">
            <summary>
            The end time of the histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.BucketDuration">
            <summary>
            The duration of time represented by each bucket.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.RefDirection">
            <summary>
            RefDirection represents the direction of the references in a heap graph.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.RefDirection.From">
            <summary>
            Indicates that you are interested in referneces FROM the node of interest
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.RefDirection.To">
            <summary>
            Indicates that you are interested in referneces TO the node of interest
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample">
            <summary>
            StackSourceSample represents a single sample that has a stack.   It has a number of predefined data items assoicate with it
            including a stack, a metric and a time as well as other optional fields.  Note that all its properties are read-write.  
            It is basically a named tuple. 
            
            StackSource.ProductSamples push these.  
            
            In general StackSourceSample are NOT immutable but expected to be overwritted frequently.  Thus you need to copy 
            the sample if you want to keep a refernece to it.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.ToString">
            <summary>
            Returns an XML string representing the sample
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.ToString(Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Returns an XML string representing the sample, howevever this one can actually expand the stack because it is given the source
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Create a StackSourceSample which is associated with 'source'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Copy a StackSourceSample from 'template'
            </summary>
            <param name="template"></param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.StackIndex">
            <summary>
            The Stack associated with the sample 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.Metric">
            <summary>
            The metric (cost) associated with the sample 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.SampleIndex">
            <summary>
            If the source supports fetching samples by some ID, then SampleIndex returns this ID for the sample and 
            GetSampleByIndex is the API that converts this index into a sample again.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.TimeRelativeMSec">
            <summary>
            The time associated with the sample.  (can be left 0)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.TimeRelMSec">
            <summary>
            The time associated with the sample.  (can be left 0)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.Count">
            <summary>
            Normally the count of a sample is 1, however when you take a statistical sample, and you also have 
            other constraints (like you do when you are going a sample of heap memory),  you may need to have the
            count adjusted to something else.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.Scenario">
            <summary>
            A scenario is simply a integer that represents some group the sample belongs to. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex">
            <summary>
            Identifies a particular sample from the sample source, it allows 3rd parties to attach additional
            information to the sample by creating an array indexed by sampleIndex.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex.Invalid">
            <summary>
            Returned when no appropriate Sample exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex">
            <summary>
            An opaque handle that are 1-1 with a complete call stack
            
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Start">
            <summary>
            The first real call stack index (after the pseudo-ones before this)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Invalid">
            <summary>
            Returned when no appropriate CallStack exists.   (Top of stack)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex">
            <summary>
            Identifies a particular frame within a stack   It represents a particular instruction pointer (IP) location 
            in the code or a group of such locations.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Root">
            <summary>
            Pseduo-node representing the root of all stacks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Broken">
            <summary>
            Pseduo-frame that represents the caller of all broken stacks. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Unknown">
            <summary>
            Unknown what to do (Must be before the 'special ones below')  // Non negative represents normal m_frames (e.g. names of methods)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Overhead">
            <summary>
             Profiling overhead (rundown)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Start">
            <summary>
            The first real call stack index (after the pseudo-ones before this)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Invalid">
            <summary>
            Should not happen (uninitialized) (also means completely folded away)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Discard">
            <summary>
            Sample has been filtered out (useful for filtering stack sources)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex">
            <summary>
            A StackSourceModuleIndex uniquely identifies a module to the stack source.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex.Start">
            <summary>
            Start is where 'ordinary' module indexes start. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex.Invalid">
            <summary>
            Invalid is a module index that is never used and can be used to signal error conditions. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource">
            <summary>
            This stack source takes another and copies out all its events.   This allows you to 'replay' the source 
            efficiently when the original source only does this inefficiently.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.#ctor">
            <summary>
            Create a CopyStackSource that has no samples in it.  It can never have samples so it is only useful as a placeholder.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Create a CopyStackSource that you can add samples which use indexes that 'sourceStacks' can decode.   All samples
            added to the stack source must only refer to this StackSourceStacks
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.AddSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to stack source.  it will clone 'sample' so sample can be overwritten after this method returns.  
            It is an error if 'sample' does not used the StackSourceStacks passed to the CopyStackSource at construction. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.Clone(Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Create a clone of the given stack soruce.  
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SourceStacks">
            <summary>
            Returns the StackSourceStacks that can interpret indexes for this stack source.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SampleIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SamplesImmutable">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.CallStackIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource">
            <summary>
            Like CopyStackSource InternStackSource copies the samples. however unlike CopyStackSource
            InternStackSource copies all the information in the stacks too (mapping stack indexes to names)
            Thus it never refers to the original source again).   It also interns the stacks making for 
            an efficient representation of the data.   This is useful when the original source is expensive 
            to iterate over.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.Diff(Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Compute the difference between two sources of stacks.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.Diff(Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks,Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Compute only the delta of source from the baseline.  This variation allows you to specify
            the unfiltered names (the sourceStacks and baselineStacks) but otherwise keep the filtering.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Create a new stack source that can create things out of nothing.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.#ctor">
            <summary>
            Create a new InternStackSource
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.InternFullStackFromSource(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks,System.Int32)">
            <summary>
            InternFullStackFromSource will take a call stack 'baseCallStackIndex' from the source 'source' and completely copy it into
            the intern stack source (interning along the way of course).   Logically baseCallStackIndex has NOTHING to do with any of the
            call stack indexes in the intern stack source.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.Interner">
            <summary>
            Returns the Interner, which is the class that holds the name->index mappings that that every
            name has a unique index.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.CallStackIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner">
            <summary>
            StackSourceInterner is a helper class that knows how to intern module, frame and call stacks. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.#ctor(System.Int32,System.Int32,System.Int32,Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex)">
            <summary>
            Create a new StackSourceInterner.  Optionally supply estimates on how many items you need and where the frame, callstack and module indexes start.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.DoneInterning">
            <summary>
            As an optimization, if you are done adding new nodes, then you can call this routine can abandon
            some tables only needed during the interning phase.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Given a StackSourceCallStackIndex return the StackSourceCallStackIndex of the caller
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Given a StackSourceCallStackIndex return the StackSourceFrameIndex for the Frame associated
            with the top call stack
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Get a name from a frame index.  If the frame index is a 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetModuleIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Given a StackSourceFrameIndex return the StackSourceModuleIndex associated with the frame 
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.ModuleIntern(System.String)">
            <summary>
            Lookup or create a StackSourceModuleIndex for moduleName
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameIntern(System.String,Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex)">
            <summary>
            Lookup or create a StackSourceFrameIndex for frame with the name frameName and the module identified by moduleIndex
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.UpdateFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.String)">
            <summary>
             Allows an existing frame to be updated in place (thus all references to the old name go to the new name).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameIntern(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.String)">
            <summary>
            You can also create frames out of other frames using this method.  Given an existing frame, and
            a suffix 'frameSuffix' 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.CallStackIntern(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Lookup or create a StackSourceCallStackIndex for a call stack with the frame identified frameIndex and caller identified by callerIndex
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.CallStackStartIndex">
            <summary>
            The CallStackStartIndex value passed to the constructor
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameStartIndex">
            <summary>
            The FrameStartIndex value passed to the constructor
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameNameLookup">
            <summary>
            If you intern frames as derived frames, when GetFrameName is called the interner needs to know
            how to look up the derived frame from its index.  This is the function that is called.  
            
            It is called with the frame index and a boolean which indicates whether the full path of the module 
            should be specified, and returns the frame string. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameCount">
            <summary>
            The current number of unique frames that have been interned so far
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.CallStackCount">
            <summary>
            The current number of unique call stacks that have been interned so far
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser">
            <summary>
            Kernel traces have information about images that are loaded, however they don't have enough information
            in the events themselves to unambigously look up PDBs without looking at the data inside the images.
            This means that symbols can't be resolved unless you are on the same machine on which you gathered the data.
            
            XPERF solves this problem by adding new 'synthetic' events that it creates by looking at the trace and then
            opening each DLL mentioned and extracting the information needed to look PDBS up on a symbol server (this 
            includes the PE file's TimeDateStamp as well as a PDB Guid, and 'pdbAge' that can be found in the DLLs header.
            
            These new events are added when XPERF runs the 'merge' command (or -d flag is passed).  It is also exposed 
            through the KernelTraceControl.dll!CreateMergedTraceFile API.   
            
            SymbolTraceEventParser is a parser for extra events.   
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageIDDbgID_RSDS">
            <summary>
             The DbgIDRSDS event is added by XPERF for every Image load.  It contains the 'PDB signature' for the DLL, 
             which is enough to unambiguously look the image's PDB up on a symbol server.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageID">
            <summary>
            Every DLL has a Timestamp in the PE file itself that indicates when it is built.  This event dumps this timestamp.
            This timestamp is used to be as the 'signature' of the image and is used as a key to find the symbols, however 
            this has mostly be superseded by the DbgID/RSDS event. 
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageIDFileVersion">
            <summary>
            The FileVersion event contains information from the file version resource that most DLLs have that indicated
            detailed information about the exact version of the DLL.  (What is in the File->Properties->Version property
            page)
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageIDNone">
            <summary>
            I don't really care about this one, but I need a definition in order to exclude it because it
            has the same timestamp as a imageLoad event, and two events with the same timestamp confuse the 
            association between a stack and the event for the stack.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.MetaDataEventInfo">
            <summary>
            This event has a TRACE_EVENT_INFO as its payload, and allows you to decode an event
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.MetaDataEventMapInfo">
            <summary>
            The event describes a Map (bitmap or ValueMap), and has a payload as follows   
            
                GUID            ProviderId;  
                EVENT_MAP_INFO EventMapInfo;  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData.#ctor(System.Action{Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData},System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String)">
            <summary>
            Construct a TraceEvent template which has one string payload field with the given metadata and action
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData.Dispatch">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData.Xml">
            <summary>
            The value of the one string payload property.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatConfigTraceData.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolPath">
            <summary>
            SymPath is a class that knows how to parse _NT_SYMBOL_PATH syntax.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.CleanSymbolPath">
            <summary>
            This 'cleans up' a symbol path.  In particular
            Empty ones are replaced with good defaults (symweb or msdl)
            All symbol server specs have local caches (%Temp%\symbols if nothing else is specified).  
            
            Note that this routine does NOT update _NT_SYMBOL_PATH.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.#ctor">
            <summary>
            Create an empty symbol path
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.#ctor(System.String)">
            <summary>
            Create a symbol that represents 'path' (the standard semicolon separated list of locations)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Add(System.String)">
            <summary>
            Append all the elements in the semicolon separated list, 'path', to the symbol path represented by 'this'. 
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Add(Microsoft.Diagnostics.Symbols.SymbolPathElement)">
            <summary>
            append a new symbol path element to the beginning of the symbol path represented by 'this'.
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Insert(System.String)">
            <summary>
            insert all the elements in the semicolon separated list, 'path' to the beginning of the symbol path represented by 'this'.
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Insert(Microsoft.Diagnostics.Symbols.SymbolPathElement)">
            <summary>
            insert a new symbol path element to the beginning of the symbol path represented by 'this'.
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.DefaultSymbolCache(System.Boolean)">
            <summary>
            If you need to cache files locally, put them here.  It is defined
            to be the first local path of a SRV* qualification or %TEMP%\symbols
            if not is present.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.InsureHasCache(System.String)">
            <summary>
            People can use symbol servers without a local cache.  This is bad, add one if necessary. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.LocalOnly">
            <summary>
            Removes all references to remote paths.  This insures that network issues don't cause grief.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.CacheFirst">
            <summary>
            Create a new symbol path which first search all machine local locations (either explicit location or symbol server cache locations)
            followed by all non-local symbol server.   This produces better behavior (If you can find it locally it will be fast)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.ToString">
            <summary>
            Returns the string representation (semicolon separated) for the symbol path.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.ToXml(System.IO.TextWriter,System.String)">
            <summary>
            Writes an XML representation of the symbol path to 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.ComputerNameExists(System.String,System.Int32)">
            <summary>
            Checks to see 'computerName' exists (there is a Domain Names Service (DNS) reply to it)
            This routine times out relative quickly (after 700 msec) if there is a problem reaching 
            the computer, and returns false.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPath.SymbolPathFromEnvironment">
            <summary>
            This allows you to set the _NT_SYMBOL_PATH as a from the windows environment.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPath.MicrosoftSymbolServerPath">
            <summary>
            Returns the string representing a symbol path for the 'standard' Microsoft symbol servers.   
            This returns the public msdl.microsoft.com server if outside Microsoft.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPath.Elements">
            <summary>
            Returns the List of elements in the symbol path. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolPathElement">
            <summary>
            SymPathElement represents the text between the semicolons in a symbol path.  It can be a symbol server specification or a simple directory path. 
            
            SymPathElement follows functional conventions.  After construction everything is read-only. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPathElement.ToString">
            <summary>
            Returns the string repsentation for the symbol server path element (e.g. SRV*c:\temp*\\symbols\symbols)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPathElement.Equals(System.Object)">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPathElement.GetHashCode">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.IsSymServer">
            <summary>
            Returns true if this element of the symbol server path a symbol server specification
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.Cache">
            <summary>
            Returns the local cache for a symbol server specification.  returns null if not specified
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.Target">
            <summary>
            Returns location to look for symbols.  This is either a directory specification or an URL (for symbol servers)
            This can be null if it is not specified (for cache-only paths).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.IsRemote">
            <summary>
            IsRemote returns true if it looks like the target is not on the local machine.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser">
            <summary>
            The KernelTraceEventParser is a class that knows how to decode the 'standard' kernel events.
            It exposes an event for each event of interest that users can subscribe to.
            
            see TraceEventParser for more 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.KernelSessionName">
            <summary>
            The special name for the Kernel session
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.NonOSKeywords">
            <summary>
            These keywords are can't be passed to the OS, they are defined by KernelTraceEventParser
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ProcessStartGroup">
            <summary>
            Registers both ProcessStart and ProcessDCStart
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ProcessEndGroup">
            <summary>
            Registers both ProcessEnd and ProcessDCStop
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ThreadStartGroup">
            <summary>
            Registers both ThreadStart and ThreadDCStart
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ThreadEndGroup">
            <summary>
            Registers both ThreadEnd and ThreadDCStop
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ImageLoadGroup">
            <summary>
            Registers both ImageLoad and ImageDCStart
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ImageUnloadGroup">
            <summary>
            Registers both ImageUnload and ImageDCStop
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.SysConfigVolumeMapping">
            <summary>
            File names in ETW are the Kernel names, which need to be mapped to the drive specification users see. 
            This event indicates this mapping. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords">
            <summary>
            This is passed to TraceEventSession.EnableKernelProvider to enable particular sets of
            events.  See http://msdn.microsoft.com/en-us/library/aa363784(VS.85).aspx for more information on them 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.None">
            <summary>
            Logs nothing
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskFileIO">
            <summary>
            Logs the mapping of file IDs to actual (kernel) file names. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskIO">
            <summary>
            Loads the completion of Physical disk activity. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ImageLoad">
            <summary>
            Logs native modules loads (LoadLibrary), and unloads
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.MemoryHardFaults">
            <summary>
            Logs all page faults that must fetch the data from the disk (hard faults)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.NetworkTCPIP">
            <summary>
            Logs TCP/IP network send and receive events. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Process">
            <summary>
            Logs process starts and stops.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ProcessCounters">
            <summary>
            Logs process performance counters (TODO When?) (Vista+ only)
            see KernelTraceEventParser.ProcessPerfCtr, ProcessPerfCtrTraceData
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Profile">
            <summary>
            Sampled based profiling (every msec) (Vista+ only) (expect 1K events per proc per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Thread">
            <summary>
            Logs threads starts and stops
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ContextSwitch">
            <summary>
            log thread context switches (Vista only) (can be > 10K events per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskIOInit">
            <summary>
            log Disk operations (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second) (Stacks associated with this)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Dispatcher">
            <summary>
            Thread Dispatcher (ReadyThread) (Vista+ only) (can be > 10K events per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.FileIO">
            <summary>
            log file operations when they complete (even ones that do not actually cause Disk I/O).  (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second) (No stacks associated with these)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.FileIOInit">
            <summary>
            log the start of the File I/O operation as well as the end. (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Memory">
            <summary>
            Logs all page faults (hard or soft)
            Can be pretty volumous (> 1K per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Registry">
            <summary>
            Logs activity to the windows registry. 
            Can be pretty volumous (> 1K per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.SystemCall">
            <summary>
            log calls to the OS (Vista+ only)
            This is VERY volumous (can be > 100K events per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.VirtualAlloc">
            <summary>
            Log Virtual Alloc calls and VirtualFree.   (Vista+ Only)
            Generally not TOO volumous (typically less than 1K per second)
            </summary> 
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.VAMap">
            <summary>
            Log mapping of files into memmory (Win8 and above Only)
            Generally low volume.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.AdvancedLocalProcedureCalls">
            <summary>
            Logs Advanced Local Procedure call events. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DeferedProcedureCalls">
            <summary>
            log defered procedure calls (an Kernel mechanism for having work done asynchronously) (Vista+ only)
            </summary> 
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Driver">
            <summary>
            Device Driver logging (Vista+ only)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Interrupt">
            <summary>
            log hardware interrupts. (Vista+ only)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.SplitIO">
            <summary>
            Disk I/O that was split (eg because of mirroring requirements) (Vista+ only)
            </summary> 
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Default">
            <summary>
            Good default kernel flags.  (TODO more detail)
            </summary>  
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Verbose">
            <summary>
            These events are too verbose for normal use, but this give you a quick way of turing on 'interesting' events
            This does not include SystemCall because it is 'too verbose'
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ThreadTime">
            <summary>
            Use this if you care about blocked time.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.OS">
            <summary>
            You mostly don't care about these unless you are dealing with OS internals.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.All">
            <summary>
            All legal kernel events
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.PMCProfile">
            <summary>
            Turn on PMC (Precise Machine Counter) events.   Only Win 8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ReferenceSet">
            <summary>
            Kernel reference set events (like XPERF ReferenceSet).   Fully works only on Win 8.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ThreadPriority">
            <summary>
            Events when thread priorities change.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.IOQueue">
            <summary>
            Events when queuing and dequeuing from the I/O completion ports.    
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Handle">
            <summary>
            Handle creation and closing (for handle leaks) 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ParserTrackingOptions">
            <summary>
            What his parser should track by default.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParserState">
            <summary>
            KernelTraceEventParserState holds all information that is shared among all events that is
            needed to decode kernel events.   This class is registered with the source so that it will be
            persisted.  Things in here include
            
                * FileID to FileName mapping, 
                * ThreadID to ProcessID mapping
                * Kernel file name to user file name mapping 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParserState.FileIDToName(System.UInt64,System.UInt64,System.Int64)">
            <summary>
            If you have a file object (per-open-file) in addition to a fileKey, try using both 
            to look up the file name.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParserState.threadIDtoProcessIDRundown">
            <summary>
            This is for the circular buffer case.  In that case we may not have thread starts (and thus we don't
            have entries in threadIDtoProcessID).   Because HistoryTable finds the FIRST entry GREATER than the
            given threadID we NEGATE all times before we place it in this table.
            
            Also, because circular buffering is not the common case, we only add entries to this table if needed
            (if we could not find the thread ID using threadIDtoProcessID).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelToUserDriveMapping">
            <summary>
            Keeps track of the mapping from kernel names to file system names (drives)  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.KernelToUserDriveMapping.#ctor">
            <summary>
            Create a new KernelToUserDriveMapping that can look up kernel names for drives and map them to windows drive letters. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.KernelToUserDriveMapping.Item(System.String)">
            <summary>
            Returns the string representing the windows drive letter for the kernel drive name 'kernelName'
            </summary>
            <param name="kernelName"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.EventTraceHeaderTraceData.UTCOffsetMinutes">
            <summary>
            This is the number of minutes between the local time where the data was collected and UTC time. 
            It does NOT take Daylight savings time into account.   
            It is positive if your time zone is WEST of Greenwich.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.ThreadTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that StartAddr and Win32StartAddr are a code addresses that needs symbolic information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.CSwitchTraceData.NewThreadID">
            <summary>
            We report a context switch from from the new thread.  Thus NewThreadID == ThreadID.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.Irp">
            <summary>
            The I/O Response Packet address.  This represents the 'identity' of this particular I/O
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.HighResResponseTime">
            <summary>
            This is the time since the I/O was initiated, in source.PerfFreq (QPC) ticks.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.DiskServiceTimeMSec">
            <summary>
            This is the actual time the disk spent servicing this IO.   Same as elapsed time for real time providers.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.ElapsedTimeMSec">
            <summary>
            The time since the I/O was initiated.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOFlushBuffersTraceData.HighResResponseTime">
            <summary>
            This is the time since the I/O was initiated, in source.PerfFreq (QPC) ticks.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOFlushBuffersTraceData.ElapsedTimeMSec">
            <summary>
            The time since the I/O was initiated.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIONameTraceData.FileKey">
            <summary>
            This is a handle that represents a file NAME (not an open file).   
            In the MSDN does this field is called FileObject.  However in other events FileObject is something
            returned from Create file and is different.  Events have have both (and some do) use FileKey.  Thus
            I use FileKey uniformly to avoid confusion.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIODirEnumTraceData.FileObject">
            <summary>
            The FileObject is the object for the Directory (used by CreateFile to open and passed to Close to close)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIODirEnumTraceData.FileKey">
            <summary>
            The FileKey is the object that represents the name of the directory.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.ImageLoadTraceData.BuildTime">
            <summary>
            This is the TimeDateStamp converted to a DateTime
            TODO: daylight savings time seems to mess this up.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageFaultTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that ProgramCounter is a code address that needs symbolic information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryHardFaultTraceData.ElapsedTimeMSec">
            <summary>
            The time spent during the page fault.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageAccessTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData">
            <summary>
            This event is emitted by the Microsoft-Windows-Kernel-Memory with Keyword 0x40  KERNEL_MEM_KEYWORD_MEMINFO_EX every .5 seconds
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned MemoryProcessMemInfoValues 
            points the the data in MemoryProcessMemInfoTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData.PayloadValue(System.Int32)">
            <summary>
            The fields after 'Count' are the first value in the array of working sets.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoValues">
            <summary>
            This structure just POINTS at the data in the MemoryProcessMemInfoTraceData.  It can only be used as long as
            the MemoryProcessMemInfoTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.ExecutingDPC">
            <summary>
            Are we currently executing a Deferred Procedure Call (a mechanism the kernel uses to
            'steal' a thread to run its own work).  If this is true, the CPU time is really 
            not logically related to the process (it is kernel time).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.ExecutingISR">
            <summary>
            Are we currently executing a Interrupt Service Routine?   Like ExecutingDPC if this
            is true the thread is really doing Kernel work, not work for the process.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.NonProcess">
            <summary>
            NonProcess is true if ExecutingDPC or ExecutingISR is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.Priority">
            <summary>
            The thread's current priority (higher is more likely to run).   A normal thread with a normal base 
            priority is 8.   
            see http://msdn.microsoft.com/en-us/library/windows/desktop/ms685100(v=vs.85).aspx for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.Rank">
            <summary>
            Your scheduling If the thread is not part of a scheduling group, this is 0 (see callout.c) 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.PMCCounterProfTraceData">
            <summary>
            PMC (Precise Machine Counter) events are fired when a CPU counter trips.  The the ProfileSource identifies
            which counter it is.   The PerfInfoCollectionStart events will tell you the count that was configured to trip
            the event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.PMCCounterProfTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SysCallEnterTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that SystemCallAddress is a code address that needs symbolic information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData">
            <summary>
            Collects the call callStacks for some other event.  
            
            (TODO: always for the event that preceded it on the same thread)?  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete stack).  
            </summary>
            <param name="index">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.FixupData">
            <summary>
            StackWalkTraceData does not set Thread and process ID fields properly.  if that.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.EventTimeStampQPC">
            <summary>
            The timestamp of the event which caused this stack walk using QueryPerformaceCounter
            cycles as the tick.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.EventTimeStampRelativeMSec">
            <summary>
            Converts this to a time relative to the start of the trace in msec. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.FrameCount">
            <summary>
            The total number of eventToStack frames collected.  The Windows OS currently has a maximum of 96 frames. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData">
            <summary>
            To save space, stack walks in Win8 can be complressed.  The stack walk event only has a 
            reference to a stack Key which is then looked up by StackWalkDefTraceData. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.FixupData">
            <summary>
            StackWalkTraceData does not set Thread and process ID fields properly.  if that.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.EventTimeStampQPC">
            <summary>
            The timestamp of the event which caused this stack walk using QueryPerformaceCounter
            cycles as the tick.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.EventTimeStampRelativeMSec">
            <summary>
            Converts this to a time relative to the start of the trace in msec. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.StackKey">
            <summary>
            Returns a key that can be used to look up the stack in KeyDelete or KeyRundown events 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData">
            <summary>
            This event defines a stack and gives it a unique id (the StackKey), which StackWalkRefTraceData can point at.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete complete).  
            </summary>
            <param name="index">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.StackKey">
            <summary>
            Returns a key that can be used to look up the stack in KeyDelete or KeyRundown events 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.FrameCount">
            <summary>
            The total number of eventToStack frames collected.  The Windows OS currently has a maximum of 96 frames. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SystemPathsTraceData.SystemDirectory">
            <summary>
            e.g. c:\windows\system32
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SystemPathsTraceData.SystemWindowsDirectory">
            <summary>
            .e.g c:\windows
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser">
            <summary>
            RegisteredTraceEventParser uses the standard windows provider database (TDH, what gets registered with wevtutil)
            to find the names of events and fields of the events).   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser">
            <summary>
            ExternalTraceEventParser is an abstract class that acts as a parser for any 'External' resolution
            This include the TDH (RegisteredTraceEventParser) as well as the WPPTraceEventParser.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.Boolean)">
            <summary>
            Create a new ExternalTraceEventParser and attach it to the given TraceEventSource
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.GetProviderName">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.HasDefinitionForTemplate(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Returns true if the RegisteredTraceEventParser would return 'template' in EnumerateTemplates
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.EnumerateTemplates(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.OnNewEventDefintion(Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData,System.Boolean)">
            <summary>
            Register 'template' so that if there are any subscriptions to template they get registered with the source.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.IsStatic">
            <summary>
            Override.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TraceLoggingMarker">
            <summary>
            Events that have this special special marker in their channel indicate that the 
            data format is the new self-describing TraceLogging style 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.Boolean)">
            <summary>
            Create a new RegisteredTraceEventParser and attach it to the given TraceEventSource
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.GetManifestForRegisteredProvider(System.String)">
            <summary>
            Given a provider name that has been registered with the operating system, get
            a string representing the ETW manifest for that provider.    Note that this
            manifest is not as rich as the original source manifest because some information
            is not actually compiled into the binary manifest that is registered with the OS.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.GetManifestForRegisteredProvider(System.Guid)">
            <summary>
            Given a provider GUID that has been registered with the operating system, get
            a string representing the ETW manifest for that provider.    Note that this
            manifest is not as rich as the original source manifest because some information
            is not actually compiled into the binary manifest that is registered with the OS.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.GetKeywordStr(System.Collections.Generic.SortedDictionary{System.UInt64,System.String},System.UInt64)">
            <summary>
            Generates a space separated list of set of keywords 'keywordSet' using the table 'keywords'
            It will generate new keyword names if needed and add them to 'keywords' if they are not present.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TryLookupWorker(Microsoft.Diagnostics.Tracing.TraceEvent,System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Parsers.MapKey,System.Collections.Generic.IDictionary{System.Int64,System.String}})">
            <summary>
            Try to look up 'unknonwEvent using TDH or the TraceLogging mechanism.   if 'mapTable' is non-null it will be used
            look up the string names for fields that have bitsets or enumerated values.   This is only need for the KernelTraceControl
            case where the map information is logged as special events and can't be looked up with TDH APIs.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.CheckForTraceLoggingEventDefinition(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Given a TraceLogging event 'data' (which has Channel == 11), then parse it adding the
            definition to lookup logic if necessary.   Returns true if a new definition was added
            (which means you need to retry lookup).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TaskInfo">
            <summary>
            Class used to accumulate information about Tasks in the implementation of GetManifestForRegisteredProvider
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TraceLoggingFieldParser">
            <summary>
            A helper class that knows how to parse fields with nested types.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TraceLoggingFieldParser.ParseFields(System.String[]@,Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch[]@,System.UInt16,System.Int32)">
            <summary>
            Parses at most 'maxFields' fields starting at the current position.  
            Will return the parse fields in 'payloadNamesRet' and 'payloadFetchesRet'
            Will return true if successful, false means an error occurred.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser">
            <summary>
            TdhEvenParser takes the Trace Diagnostics Helper (TDH) TRACE_EVENT_INFO structure and
            (passed as a byte*) and converts it to a DynamicTraceEventData which which 
            can be used to parse events of that type.   You first create TdhEventParser and then
            call ParseEventMetaData to do the parsing.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser.#ctor(System.Byte*,Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD*,System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Parsers.MapKey,System.Collections.Generic.IDictionary{System.Int64,System.String}})">
            <summary>
            Creates a new parser from the TRACE_EVENT_INFO held in 'buffer'.  Use
            ParseEventMetaData to then parse it into a DynamicTraceEventData structure.
             EventRecord can be null and mapTable if present allow the parser to resolve maps (enums), and can be null.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser.ParseEventMetaData">
            <summary>
            Actually performs the parsing of the TRACE_EVENT_INFO passed in the constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser.ParseFields(System.Int32,System.Int32)">
            <summary>
            Parses at most 'maxFields' fields starting at the current position.  
            Will return the parse fields in 'payloadNamesRet' and 'payloadFetchesRet'
            Will return true if successful, false means an error occurred.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.MapKey">
            <summary>
            Used to look up Enums (provider x enumName);  Very boring class.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState">
            <summary>
            TDHDynamicTraceEventParserState represents the state of a  TDHDynamicTraceEventParser that needs to be
            serialized to a log file.  It does NOT include information about what events are chosen but DOES contain
            any other necessary information that came from the ETL data file or the OS TDH APIs.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState.ToStream(FastSerialization.Serializer)">
            <summary>
            Implements IFastSerializable interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState.FromStream(FastSerialization.Deserializer)">
            <summary>
            Implements IFastSerializable interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState.TraceEventComparer">
            <summary>
            This defines what it means to be the same event.   For manifest events it means provider and event ID
            for classic, it means that taskGuid and opcode match.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventID">
            <summary>
            Individual event providers can supply many different types of events.  These are distinguished from each
            other by a TraceEventID, which is just a 16 bit number.  Its meaning is provider-specific.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventID.Illegal">
            <summary>
            Illegal is a EventID that is not used by a normal event.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventChannel">
            <summary>
            Providers can define different audiences or Channels for an event (eg Admin, Developer ...).
            It is only used for Windows Event log support.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventChannel.Default">
            <summary>
            The default channel.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventOpcode">
            <summary>
            There are certain classes of events (like start and stop) which are common across a broad variety of
            event providers for which it is useful to treat uniformly (for example, determining the elapsed time
            between a start and stop event).  To facilitate this, event can have opcode which defines these
            common operations.  Below are the standard ones but providers can define additional ones.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Info">
            <summary>
            Generic opcode that does not have specific semantics associated with it. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Start">
            <summary>
            The entity (process, thread, ...) is starting
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Stop">
            <summary>
            The entity (process, thread, ...) is stoping (ending)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.DataCollectionStart">
            <summary>
            The entity (process, thread, ...) did not terminate before data collection ended, so indicate
            this at data collection termination time.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.DataCollectionStop">
            <summary>
            The entity (process, thread, ...) did not terminate before data collection ended, so indicate
            this at data collection termination time. This is mostly for 'flight recorder' scenarios where
            you only have the 'tail' of the data and would like to know about everything that existed. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Extension">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Reply">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Resume">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Suspend">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Transfer">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventLevel">
            <summary>
            Indicates to a provider whether verbose events should be logged.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Always">
            <summary>
            Always log the event (It also can mean that the provider decides the verbosity)  You probably should not use it....
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Critical">
            <summary>
            Events that indicate critical conditions
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Error">
            <summary>
            Events that indicate error conditions
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Warning">
            <summary>
            Events that indicate warning conditions
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Informational">
            <summary>
            Events that indicate information
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Verbose">
            <summary>
            Events that verbose information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventKeyword">
            <summary>
            ETW defines the concept of a Keyword, which is a 64 bit bitfield. Each bit in the bitfield
            represents some provider defined 'area' that is useful for filtering. When processing the events, it
            is then possible to filter based on whether various bits in the bitfield are set.  There are some
            standard keywords, but most are provider specific. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventKeyword.None">
            <summary>
            No event groups (keywords) selected
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventKeyword.All">
            <summary>
            All event groups (keywords) selected
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventTask">
            <summary>
            Tasks are groups of related events for a given provider (for example Process, or Thread, Kernel Provider).  
            They are defined by the provider.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventTask.Default">
            <summary>
            If you don't explicitly choose a task you get the default 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventIndex">
            <summary>
            EventIdex is a unsigned integer that is unique to a particular event. EventIndex is guaranteed to be 
            unique over the whole log.  It is only used by ETLX files.  
            <para>
            Currently the event ID simply the index in the log file of the event.  We don't however guarantee ordering.
            In the future we may add new events to the log and given them IDs 'at the end' even if the events are not
            at the end chronologically.  
            </para>
            <para>
            EventIndex is a 32 bit number limits it to 4Gig events in an ETLX file.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventIndex.Invalid">
            <summary>
            Invalid is an EventIndex that will not be used by a normal event. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventFilterResponse">
            <summary>
            EventFilterResponse is the set of responses  a user-defined filtering routine, might return.  This is used in the TraceEventParser.AddCallbackForProviderEvents method.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventFilterResponse.RejectEvent">
            <summary>
            Not an interesting event, but other events in the same provider may be
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventFilterResponse.RejectProvider">
            <summary>
            No event in the provider will be accepted
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventFilterResponse.AcceptEvent">
            <summary>
             An interesting event
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EmptyTraceData">
            <summary>
            TraceEventParsers can use this template to define the event for the trivial case where the event has no user-defined payload  
            <para>This is only useful to TraceEventParsers.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.#ctor(System.Action{Microsoft.Diagnostics.Tracing.EmptyTraceData},System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String)">
            <summary>
            Construct a TraceEvent template which has no payload fields with the given metadata and action
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.Dispatch">
            <summary>
            Dispatches the event to the action associated with the template. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EmptyTraceData.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EmptyTraceData.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StringTraceData">
            <summary>
            When the event has just a single string value associated with it, you can use this shared event
            template rather than making an event-specific class.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.#ctor(System.Action{Microsoft.Diagnostics.Tracing.StringTraceData},System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String,System.Boolean)">
            <summary>
            Construct a TraceEvent template which has one string payload field with the given metadata and action
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.Dispatch">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StringTraceData.Value">
            <summary>
            The value of the one string payload property.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StringTraceData.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StringTraceData.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent">
            <summary>
            UnhandledTraceEvent is a TraceEvent when is used when no manifest information is available for the event. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.Dispatch">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.ToString">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.PrepForCallback">
            <summary>
            There is some work needed to prepare the generic unhandledTraceEvent that we defer
            late (since we often don't care about unhandled events)  
            
            TODO this is probably not worht the complexity...
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.FormattedMessage">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ObservableExtensions">
            <summary>
            ObservableExtensions defines methods on TraceEventParser that implement the IObservable protocol for implementing callbacks.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe``1(Microsoft.Diagnostics.Tracing.TraceEventParser,System.String)">
            <summary>
            Returns an IObjservable that observes all events that 'parser' knows about that  return a T.  If eventName is
            non-null, the event's name must match 'eventName', but if eventName is null, any event that returns a T is observed. 
            <para>
            This means that Observe{TraceEvent}(parser) will observe all events that the parser can parse.  
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe``1(Microsoft.Diagnostics.Tracing.TraceEventParser,System.Predicate{System.String})">
            <summary>
            Returns an IObjservable that observes all events that 'parser' knows about that return a T and whose event
            name matches the 'eventNameFilter' predicate.  
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe(Microsoft.Diagnostics.Tracing.TraceEventParser,System.String,System.String)">
            <summary>
            Observe a particular event from a particular provider.   If eventName is null, it will return every event from the provider
             
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe(Microsoft.Diagnostics.Tracing.TraceEventParser,System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse})">
            <summary>
            Given a predicate 'eventToObserve' which takes the name of a provider (which may be of the form Provider(GUID)) (first) and 
            an event name (which may be of the form EventID(NUM)) and indicates which events to observe, return an IObservable
            that observes those events. 
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  . 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.ObserveAll(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Returns an observable that observes all events from the event source 'source'
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.ObserveUnhandled(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Returns an observable that observes all events from the event source 'source' which are not handled by a callback connected to 'source'
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ObservableExtensions.TraceEventObservable`1">
            <summary>
            A TraceEventObservable is a helper class that implements the IObservable pattern for TraceEventDispatcher 
            (like ETWTraceEventDispatcher).  It is called from the TraceEventParser.Observe*{T} methods.  
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ObservableExtensions.TraceEventObservable`1.TraceEventSubscription">
            <summary>
            A TraceEventSubscription is helper class that hooks 'callback' and 'completedCallback' to the 'observable' and 
            unhooks them when 'Dispose' is called.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods">
            <summary>
            TraceEventNativeMethods contains the PINVOKE declarations needed
            to get at the Win32 TraceEvent infrastructure.  It is effectively
            a port of evntrace.h to C# declarations.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.TIME_ZONE_INFORMATION">
            <summary>
            Time zone info.  Used as one field of TRACE_EVENT_LOGFILE, below.
            Total struct size is 0xac.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.WNODE_HEADER">
            <summary>
            EventTraceHeader structure used by EVENT_TRACE_PROPERTIES
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_PROPERTIES">
            <summary>
            EVENT_TRACE_PROPERTIES is a structure used by StartTrace, ControlTrace
            however it can not be used directly in the definition of these functions
            because extra information has to be hung off the end of the structure
            before being passed.  (LofFileNameOffset, LoggerNameOffset)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_HEADER">
            <summary>
            EventTraceHeader and structure used to defined EVENT_TRACE (the main packet)
            I have simplified from the original struct definitions.  I have
            omitted alternate union-fields which we don't use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE">
            <summary>
            EVENT_TRACE is the structure that represents a single 'packet'
            of data repesenting a single event.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.TRACE_LOGFILE_HEADER">
            <summary>
            TRACE_LOGFILE_HEADER is a header used to define EVENT_TRACE_LOGFILEW.
            Total struct size is 0x110.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_LOGFILEW">
            <summary>
            EVENT_TRACE_LOGFILEW Main struct passed to OpenTrace() to be filled in.
            It represents the collection of ETW events as a whole.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_HEADER">
            <summary>
            EventTraceHeader and structure used to define EVENT_TRACE_LOGFILE (the main packet on Vista and above)
            I have simplified from the original struct definitions.  I have
            omitted alternate union-fields which we don't use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.ETW_BUFFER_CONTEXT">
            <summary>
            Provides context information about the event
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD">
            <summary>
            Defines the layout of an event that ETW delivers
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.STACK_TRACING_EVENT_ID">
            <summary>
            Used in StartKernelTrace to indicate the kernel events that should have stack traces
            collected for them.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ControllerCommand">
            <summary>
            Possible control commands (borrowed from EventSource)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ControllerCommand.Update">
            <summary>
            Standard 'update' command to send additional information to a provider
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ControllerCommand.SendManifest">
            <summary>
            Instructs an EventSource-based provider to send its manifest
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventSession">
            <summary>
            A TraceEventSession represents a single ETW Tracing Session.   A session is and event sink that 
            can enable or disable event logging from event providers).    TraceEventSessions can log their
            events either to a file, or by issuing callbacks when events arrive (a so-called 'real time' 
            session).   
            <para>
            Session are MACHINE wide and unlike most OS resources the operating system does NOT reclaim 
            them when the process that created it dies.  By default TraceEventSession tries is best to
            do this reclamation, but it is possible that for 'orphan' session to accidentally survive
            if the process is ended abruptly (e.g. by the debugger or a user explicitly killing it).  It is 
            possible to turn off TraceEventSession automatic reclamation by setting the StopOnDispose 
            property to false (its default is true).  
            </para>
            <para> 
            Kernel events have additional restrictions.   In particular there is a special API (EnableKernelProvider).  
            Before Windows 8, there was a restriction that kernel events could only be enabled from a session 
            with a special name (see KernelTraceEventParser.KernelSessionName) and thus there could only be a single
            session that could log kernel events (and that session could not log non-kernel events).  These
            restrictions were dropped in windows 8. 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.#ctor(System.String,System.String,Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions)">
            <summary>
            Create a new logging session sending the output to a given file.  
            </summary>
            <param name="sessionName">
            The name of the session. Since session can exist beyond the lifetime of the process this name is
            used to refer to the session from other processes after it is created.   By default TraceEventSessions
            do their best to close down if the TraceEventSession dies (see StopOnDispose), however if StopOnDispose
            is set to false, the session can live on after process death, and you use the name to refer to it later.  
            </param>
            <param name="fileName">
            The output moduleFile (by convention .ETL) to put the event data.  If this is null, and CircularMB is set
            to something non-zero, then it will do an in-memory circular buffer.   You can get this buffer by 
            using the 'SetFileName()' method which dumps the data in the buffer.  
            </param>
            <param name="options">Additional flags that influence behavior.  Note that the 'Create' option is implied for file mode sessions. </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.#ctor(System.String,Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions)">
            <summary>
            Open a logging session.   By default (if options is not specified) a new 'real time' session is created if
            the session already existed it is closed and reopened (thus orphans are cleaned up on next use).  By default
            sessions are closed on Dispose, but if the destructor does not run it can produce 'orphan' session that will
            live beyond the lifetime of the process.   You can use the StopOnDispose property to force sessions to live
            beyond the TraceEventSession that created them and use the TraceEventSessionOptions.Attach option to reattach
            to these sessions.
            </summary>
            <param name="sessionName"> The name of the session to open.  Should be unique across the machine.</param>
            <param name="options"> Construction options.  TraceEventSessionOptions.Attach indicates a desire to attach
            to an existing session. </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.GetActiveSession(System.String)">
            <summary>
            Looks for an existing active session named 'sessionName; and returns the TraceEventSession associated with it if it exists. 
            Returns null if the session does not exist.   You can use the GetActiveSessionNames() to get a list of names to pass to this method. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.String,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions)">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) which has a given provider name.  
            This API first checks if a published provider exists by that name, otherwise it 
            assumes it is an EventSouce and determines the provider Guid by hashing the name according to a
            well known algorithm.  Thus it will never return a failure for a incorrect spelling of the name.  
            </summary>
            <param name="providerName">
            The name of the provider.  It must either be registered with the operating system (logman query providers returns it)
            or it must be an EventSource (see GetEventSourceGuidFromName)</param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace), arguments ... </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.Guid,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions)">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) which has a given provider Guid.  
            </summary>
            <param name="providerGuid">
            The Guid that represents the event provider enable. </param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace), arguments ... </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.String,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventOptions,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) which has a given provider name.  
            This API first checks if a published provider exists by that name, otherwise it 
            assumes it is an EventSouce and determines the provider Guid by hashing the name according to a
            well known algorithm.  Thus it will never return a failure for a incorrect spelling of the name.  
            </summary>
            <param name="providerName">
            The name of the provider.  It must either be registered with the operating system (logman query providers returns it)
            or it must be an EventSource (see GetEventSourceGuidFromName)</param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace)</param>
            <param name="values">This is set of key-value strings that are passed to the provider
            for provider-specific interpretation. Can be null if no additional args are needed.  
            If the special key-value pair 'Command'='SendManifest' is provided, then the 'SendManifest'
            command will be sent (which causes EventSources to re-dump their manifest to the ETW log.  </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.Guid,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventOptions,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) represented by 'providerGuid'.
            </summary>
            <param name="providerGuid">
            The Guid that represents the event provider enable. </param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace)</param>
            <param name="values">This is set of key-value strings that are passed to the provider
            for provider-specific interpretation. Can be null if no additional args are needed.  
            If the special key-value pair 'Command'='SendManifest' is provided, then the 'SendManifest'
            command will be sent (which causes EventSources to re-dump their manifest to the ETW log.  </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProviderWithRawProviderData(System.Guid,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventOptions,System.Byte[],System.Int32)">
            <summary>
            Enable an ETW provider, passing a raw blob of data to the provider as a Filter specification.   
            
            Note that this routine is only provided to interact with old ETW providers that can interpret EVENT_FILTER_DESCRIPTOR data
            but did not conform to the key-value string conventions.   This allows this extra information to be passed to these old
            providers.   Ideally new providers follow the key-value convention and EnableProvider can be used.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.MakeDictionary(System.String[])">
            <summary>
            Helper function that is useful when using EnableProvider with key value pairs. 
            Given a list of key-value pairs, create a dictionary of the keys mapping to the values.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableKernelProvider(Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords,Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords)">
            <summary>
            Enable the kernel provider for the session. Before windows 8 this session must be called 'NT Kernel Session'.   
            This API is OK to call from one thread while Process() is being run on another
            <param name="flags">Specifies the particular kernel events of interest</param>
            <param name="stackCapture">
            Specifies which events should have their stack traces captured when an event is logged</param>
            <returns>Returns true if the session existed before and was restarted (see TraceEventSession)</returns>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableWindowsHeapProvider(System.Int32)">
            <summary>
            Turn on windows heap logging (stack for allocation) for a particular existing process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableWindowsHeapProvider(System.String)">
            <summary>
            Turn on windows heap logging for a particular EXE file name (just the file name, no directory, but it DOES include the .exe extension)
            This API is OK to call from one thread while Process() is being run on another
            </summary>
            <param name="exeFileName"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.DisableProvider(System.Guid)">
            <summary>
            Disables a provider with the given provider ID completely
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.DisableProvider(System.String)">
            <summary>
            Disables a provider with the given name completely
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Stop(System.Boolean)">
            <summary>
            Once started, event sessions will persist even after the process that created them dies.  They will also be
            implicitly stopped when the TraceEventSession is closed unless the StopOnDispose property is set to false.  
            This API is OK to call from one thread while Process() is being run on another
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Dispose">
            <summary>
            CLose the session and clean up any resources associated with the session.     It is OK to call this more than once.  
            This API is OK to call from one thread while Process() is being run on another.   Calling Dispose is on 
            a real time session is the way you can force a real time session to stop in a timely manner.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Flush">
            <summary>
            Asks all providers to flush events to the session
            This API is OK to call from one thread while Process() is being run on another
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetFileName(System.String)">
            <summary>
            For either session create with a file name this method can be used to redirect the data to a
            new file (so the previous one can be uploaded or processed offline), 
            
            It can also be used for a in-memory circular buffer session (FileName == null and CircularMB != 0)
            but its semantics is that simply writes the snapshot to the file (and closes it).  It does not
            actually make the FileName property become non-null because it only flushes the data, it does
            not cause persistent redirection of the data stream.  (it is like it auto-reverts).  
            
            It is an error to call this on a real time session.  (FileName == null and CircularMB == 0)
            </summary>
            <param name="newName">The path to the file to write the data to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CaptureState(System.Guid,System.UInt64,System.Int32,System.Object)">
            <summary>
            Sends the CAPTURE_STATE command to the provider.  This instructs the provider to log any events that are needed to
            reconstruct important state that was set up before the session started.  What is actually done is provider specific.  
            EventSources will re-dump their manifest on this command. 
            This API is OK to call from one thread while Process() is being run on another
            <para>
            This routine only works Win7 and above, since previous versions don't have this concept.   The providers also has 
            to support it.  
            </para>
            </summary>
            <param name="providerGuid">The GUID that identifies the provider to send the CaptureState command to</param>
            <param name="matchAnyKeywords">The Keywords to send as part of the command (can influence what is sent back)</param>
            <param name="filterType">if non-zero, this is passed along to the provider as type of the filter data.</param>
            <param name="data">If non-null this is either an int, or a byte array and is passed along as filter data.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.GetActiveSessionNames">
            <summary>
            ETW trace sessions survive process shutdown. Thus you can attach to existing active sessions.
            GetActiveSessionNames() returns a list of currently existing session names.  These can be passed
            to the TraceEventSession constructor to open it.   
            </summary>
            <returns>A enumeration of strings, each of which is a name of a session</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Merge(System.String[],System.String,Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions)">
            <summary>
            It is sometimes useful to merge the contents of several ETL files into a single 
            output ETL file.   This routine does that.  It also will attach additional 
            information that will allow correct file name and symbolic lookup if the 
            ETL file is used on a machine other than the one that the data was collected on.
            If you wish to transport the file to another machine you need to merge them, even 
            if you have only one file so that this extra information get incorporated.  
            </summary>
            <param name="inputETLFileNames">The input ETL files to merge</param>
            <param name="outputETLFileName">The output ETL file to produce.</param>
            <param name="options">Optional Additional options for the Merge (seeTraceEventMergeOptions) </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.MergeInPlace(System.String,System.IO.TextWriter)">
            <summary>
            This variation of the Merge command takes the 'primary' etl file name (X.etl)
            and will merge in any files that match .clr*.etl .user*.etl. and .kernel.etl.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsElevated">
            <summary>
            Is the current process Elevated (allowed to turn on a ETW provider).   This is useful because
            you need to be elevated to enable providers on a TraceEventSession.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetDebugPrivilege">
            <summary>
            Set the Windows Debug Privilege.   Useful because some event providers require this privilege, and 
            and it must be enabled explicitly (even if the process is elevated). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Finalize">
            <summary>
            The 'properties' field is only the header information.  There is 'tail' that is 
            required.  'ToUnmangedBuffer' fills in this tail properly. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ComputeEventIds(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_FILTER_DESCRIPTOR*,System.Byte*,System.Int32,System.Collections.Generic.IList{System.Int32},System.Boolean,System.Int32)">
            <summary>
            sets up the EVENT_FILTER_DESCRIPTOR descr to represent the Event Ids in 'eventIds'.   You are given the buffer 
            necessary for this (precomputed) for the EVENT_FILTER_EVENT_ID structure.   'enable' is true if this is to enable
            (otherwise disable) the events, and descrType indicates the descriptor type (either EVENT_FILTER_TYPE_EVENT_ID or
            EVENT_FILTER_TYPE_STACKWALK)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ComputeEventIdsBufferSize(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Computes the number of bytes needed for the EVENT_FILTER_EVENT_ID structure to represent 'eventIds'
            return 0 if there is not need for the filter at all.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.StartKernelTrace(System.UInt64@,Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_PROPERTIES*,Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.STACK_TRACING_EVENT_ID*,System.Int32)">
            <summary>
            We wrap this because sadly the PMC support is private, so we have to do it a different way if that is present.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SaveExtensions(System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ExtensionItem},Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_PROPERTIES*,System.UInt32)">
            <summary>
            Saves the given extensions to the Properties structure.  'properties' and returns the length that it emitted.
            You can pass null for properties and writeLocation, in which case it computes the length needed.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.PutStacksIntoExtensions(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.STACK_TRACING_EVENT_ID*,System.Int32)">
            <summary>
            The internal API does not use GUIDS but small integer values to represnet the stack hooks.   Do the convesion here. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ResetWindowsHeapTracingFlags(System.Boolean)">
            <summary>
            Resets any windows heap tracing flags that might be set.   Called during Stop.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetImageTracingFlags(System.String,System.Boolean)">
            <summary>
            Helper function used to implement EnableWindowsHeapProvider
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CleanFilterDataForEtwSession">
            <summary>
            Cleans out all provider data associated with this session.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetFilterDataForEtwSession(System.String,System.Byte[],System.Boolean)">
            <summary>
            SetDataForSession sets the filter data for an ETW session by storing it in the registry.
            This is basically a work-around for the fact that filter data does not get transmitted to
            the provider if the provider is not alive at the time the controller issues the EnableProvider 
            call.   We store in the registry and EventSource looks there for it if it is not present.  
            
            Note that we support up to 'maxSession' etw sessions simultaneously active (having different 
            filter data).   The function return a sessionIndex that indicates which of the 'slots' 
            was used to store the data.   This routine also 'garbage collects' data for sessions that
            have died without cleaning up their filter data.  
            
            If 'data' is null, then it indicates that no data should be stored and the registry entry
            is removed.
            
            If 'allSesions' is true it means that you want 'old style' data filtering that affaects all ETW sessions
            This is present only used for compatibilty 
            </summary>
            <returns>the session index that will be used for this session.  Returns -1 if an entry could not be found </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetStackTraceIds(Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords,Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.STACK_TRACING_EVENT_ID*,System.Int32)">
            <summary>
            Given a mask of kernel flags, set the array stackTracingIds of size stackTracingIdsMax to match.
            It returns the number of entries in stackTracingIds that were filled in.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.GetProperties(System.Byte*)">
            <summary>
            Get a EVENT_TRACE_PROPERTIES structure suitable for passing the the ETW out of a 'buffer' which must be PropertiesSize bytes
            in size.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CaptureStateOnSetFileName">
            <summary>
            If set, whenever a SetFileName is called (causing a new ETL file to be created), force 
            a capture state for every provider that is currently turned on.    This way the file
            will be self-contained (will contain all the capture state information needed to decode events)
            This setting is true by default.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProviderTimeoutMSec">
            <summary>
            When you issue a EnableProvider command, on windows 7 and above it can be done synchronously (that is you know that because 
            the EnableProvider returned that the provider actually got the command).   However synchronous behavior means that
            you may wait forever.   This is the time EnableProvider waits until it gives up.   Setting this
            to 0 means asynchronous (fire and forget).   The default is 10000 (wait 10 seconds) 
            Before windows 7 EnableProvider is always asynchronous.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.StopOnDispose">
            <summary>
            If set then Stop() will be called automatically when this object is Disposed or Finalized by the GC.  
            This is true BY DEFAULT, so if you want your session to survive past the end of the process
            you must set this to false.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CircularBufferMB">
            <summary>
            Cause the log to be a circular buffer.  The buffer size (in MegaBytes) is the value of this property.
            Setting this to 0 will cause it to revert to non-circular mode.  
            The setter can only be called BEFORE any provider is enabled.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.MultiFileMB">
            <summary>
            Cause the as a set of files with a given maximum size.   The file name must end in .ETL and the
            output is then a series of files of the form *NNN.ETL (That is it adds a number just before the
            .etl suffix).   If you make your file name *.user.etl then the output will be *.user1.etl, *.user2.etl ...
            And the MergeInPlace command below will merge them all nicely.  
            
            You can have more control over this by using a normal sequential file but use the SetFileName()
            method to redirect the data to new files as needed.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.BufferSizeMB">
            <summary>
            Sets the size of the buffer the operating system should reserve to avoid lost packets.   Starts out 
            as a very generous 64MB for files.  If events are lost, this can be increased, but keep in mind that
            no value will help if the average incoming rate is faster than the processing rate.  
            The setter can only be called BEFORE any provider is enabled.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.BufferQuantumKB">
            <summary>
            This is the unit in which data is flushed in Kilobytes.   By default it is 64 (KB).  
            By default a TraceEventSession will flush every second, and this amount of space will be transferred
            to the file.   Ideally it is smaller than the number data bytes you expect in a second from any
            particular processor.  It can't be less than 1K per processor on the machine.   However if you make 
            it less than 64 (K) you will limit the size of the event that the process can send 
            (they will simply be discarded).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CpuSampleIntervalMSec">
            <summary>
            The rate at which CPU samples are collected.  By default this is 1 (once a millisecond per CPU).
            There is a lower bound on this (typically .125 Msec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.StackCompression">
            <summary>
            Indicate that this session should use compress the stacks to save space.  
            Must be set before any providers are enabled.  Currently only works for kernel events.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SessionName">
            <summary>
            The name of the session that can be used by other threads to attach to the session. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.FileName">
            <summary>
            The name of the moduleFile that events are logged to.  Null means the session is real time
            or is a circular in-memory buffer.    See also SetFileName() method. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Source">
            <summary>
            If this is a real time session you can fetch the source associated with the session to start receiving events.  
            Currently does not work on file based sources (we expect you to wait until the file is complete).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsActive">
            <summary>
            Creating a TraceEventSession does not actually interact with the operating system until a
            provider is enabled. At that point the session is considered active (OS state that survives a
            process exit has been modified). IsActive returns true if the session is active. 
            
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EventsLost">
            <summary>
            Returns the number of events that should have been delivered to this session but were lost 
            (typically because the incoming rate was too high).   This value is up-to-date for real time
            sessions.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsCircular">
            <summary>
            Returns true if the session is logging to a circular buffer.  This may be in-memory (FileName == null)
            or to a file (FileName != null)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsRealTime">
            <summary>
            Returns true if the session is Real Time.  This means it is not to a file, and not circular.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsInMemoryCircular">
            <summary>
            Returns true if this is a in-memory circular buffer (it is circular without an output file).  
            Use SetFileName() to dump the in-memory buffer to a file.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ProviderNameToGuid">
            <summary>
            Returns a sorted dictionary of  names and Guids for every provider registered on the system.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions">
            <summary>
            Used in the TraceEventSession.Merge method 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions.None">
            <summary>
            No special options 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions.Compress">
            <summary>
            Compress the resulting file.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions">
            <summary>
            TraceEventProviderOptions represents all the optional arguments that can be passed to EnableProvider command.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.#ctor">
            <summary>
            Create new options object with no options set
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.#ctor(System.String[])">
            <summary>
            Create new options object with a set of given provider arguments key-value pairs.  There must be a even number
            of strings provided and each pair forms a key-value pair that is passed to the AddArgument() operator.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.AddArgument(System.String,System.String)">
            <summary>
            As a convenience, the 'Arguments' property can be modified by calling AddArgument that adds another Key-Value pair
            to it.   If 'Arguments' is not a IDictionary, it is replaced with an IDictionary with the same key-value pairs before
            the new pair is added.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.Clone">
            <summary>
            Make a deep copy of options and return it.  
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.Arguments">
            <summary>
            Arguments are a set of key-value strings that are passed uninterpreted to the EventSource.   These can be accessed
            from the EventSource's command callback.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.RawArguments">
            <summary>
            For EventSources, you pass arguments to the EventSource by using key value pairs (this 'Arguments' property). 
            However other ETW providers may expect arguments using another convention.  RawArguments give a way of passing
            raw bytes to the provider as arguments.   This is only meant for compatibility with old providers.   Setting
            this property will cause the 'Arguments' property to be ignored.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.StacksEnabled">
            <summary>
            Setting StackEnabled to true will cause all events in the provider to collect stacks when event are fired. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.ProcessIDFilter">
            <summary>
            Setting ProcessIDFilter will limit the providers that receive the EnableCommand to those that match on of
            the given Process IDs.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.ProcessNameFilter">
            <summary>
            Setting ProcessNameFilter will limit the providers that receive the EnableCommand to those that match on of
            the given Process names (a process name is the name of the EXE with a path or extension).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDsToEnable">
            <summary>
            Setting EventIDs to Enable will enable a particular event of a provider by EventID (in addition to those 
            enabled by keywords). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDStacksToEnable">
            <summary>
            Setting EventIDs to Enable will enable the collection of stacks for  a event of a provider by EventID 
            (Has no effect if StacksEnabled is also set since that enable stacks for all events IDs)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDsToDisable">
            <summary>
            Setting EventIDsToDisable to Enable will disable the event of a provider by EventID 
            This happens after keywords have been processed, so disabling overrides enabling.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDStacksToDisable">
            <summary>
            Setting EventIDs to Enable will disable the collection of stacks for a event of a provider by EventID 
            Has no effect unless StacksEnabled is also set (since otherwise stack collection is off).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.FilteringSupported">
            <summary>
            This return true on OS version beyond 8.1 (windows Version 6.3).   It means most of the
            per-event filtering is supported.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions">
            <summary>
            TraceEventSessionOptions indicates special handling when creating a TraceEventSession.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions.Create">
            <summary>
            Create a new session, fail if the session already exists.  This is the default.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions.Attach">
            <summary>
            Attach to an existing session, fail if the session does NOT already exist.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions.NoRestartOnCreate">
            <summary>
            Normally if you create a session it will stop and restart it if it exists already.  Setting
            this flat will disable the 'stop and restart' behavior.   This is useful if only a single
            monitoring process is intended. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders">
            <summary>
            TraceEventProviders returns information about providers on the system.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderGuidByName(System.String)">
            <summary>
            Given the friendly name of a provider (e.g. Microsoft-Windows-DotNETRuntimeStress) return the
            GUID for the provider.   It does this by looking at all the PUBLISHED providers on the system
            (that is those registered with wevtutuil).   EventSources in particular do not register themselves
            in this way (see GetEventSourceGuidFromName).  Names are case insensitive.   
            It also checks to see if the name is an actual GUID and if so returns that.  
            Returns Guid.Empty on failure.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetEventSourceGuidFromName(System.String)">
            <summary>
            EventSources have a convention for converting its name to a GUID.  Use this convention to 
            convert 'name' to a GUID.   In this way you can get the provider GUID for a EventSource
            however it can't check for misspellings.   Names are case insensitive.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderName(System.Guid)">
            <summary>
            Finds the friendly name for 'providerGuid'  Returns the Guid as a string if can't be found.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.MaybeAnEventSource(System.Guid)">
            <summary>
            Returns true if 'providerGuid' can be an eventSource.   If it says true, there is a 1/16 chance it is not.  
            However if it returns false, it is definitely not following EventSource Guid generation conventions.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetPublishedProviders">
            <summary>
            Returns the Guid of every event provider that published its manifest on the machine.  This is the 
            same list that the 'logman query providers' command will generate.  It is pretty long (&gt; 1000 entries)
            <para>
            A event provider publishes a manifest by compiling its manifest into a special binary form and calling
            the wevtutil utility.   Typically EventSource do NOT publish their manifest but most operating
            system provider do publish their manifest.   
            </para>
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetRegisteredOrEnabledProviders">
            <summary>
            Returns the GUID of all event provider that either has has register itself in a running process (that is
            it CAN be enabled) or that a session has enabled (even if no instances of the provider exist in any process).  
            <para>
            This is a relatively small list (less than 1000), unlike GetPublishedProviders. 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetRegisteredProvidersInProcess(System.Int32)">
            <summary>
            Returns a list of provider GUIDs that are registered in a process with 'processID'.   Useful for discovering
            what providers are available for enabling for a particular process.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderKeywords(System.Guid)">
            <summary>
            Returns a description of the keywords a particular provider provides.  Only works if the provider has 
            published its manifest to the operating system.  
            Throws an exception if providerGuid is not found
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.SessionInfosForProvider(System.Guid,System.Int32)">
            <summary>
            Returns a list of TRACE_ENABLE_INFO structures that tell about each session (what keywords and level they are
            set to, for the provider associated with 'providerGuid'.  If 'processId != 0, then only providers in that process
            are returned.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem">
            <summary>
            A list of these is returned by GetProviderKeywords
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.Name">
            <summary>
            The name of the provider keyword. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.Description">
            <summary>
            The description for the keyword for the provider 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.Value">
            <summary>
            the value (bitvector) for the keyword.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.ToString">
            <summary>
            and XML representation for the ProviderDataItem (for debugging)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventProfileSources">
            <summary>
            TraceEventProfileSources is the interface for the Windows processor CPU counter support
            (e.g. causing a stack to be taken every N dcache misses, or branch mispredicts etc)
            <para>
            Note that the interface to these is machine global (That is when you set these you 
            cause any session with the kernel PMCProfile keyword active to start emitting
            PMCCounterProf events for each ProfileSouce that is enabled.  
            </para>
            /// </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProfileSources.GetInfo">
            <summary>
            Returns a dictionary of keyed by name of ProfileSourceInfo structures for all the CPU counters available on the machine. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProfileSources.Set(System.Int32[],System.Int32[])">
            <summary>
            Sets the Profile Sources (CPU machine counters) that will be used if PMC (Precise Machine Counters)
            are turned on.   Each CPU counter is given a id (the profileSourceID) and has an interval 
            (the number of counts you skip for each event you log).   You can get the human name for 
            all the supported CPU counters by calling GetProfileSourceInfo.  Then choose the ones you want
            and configure them here (the first array indicating the CPU counters to enable, and the second
            array indicating the interval.  The second array can be shorter then the first, in which case
            the existing interval is used (it persists and has a default on boot).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo">
            <summary>
            Returned by GetProfileSourceInfo, describing the CPU counter (ProfileSource) available on the machine. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.Name">
            <summary>
            Human readable name of the CPU performance counter (eg BranchInstructions, TotalIssues ...)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.ID">
            <summary>
            The ID that can be passed to SetProfileSources
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.Interval">
            <summary>
            This many events are skipped for each sample that is actually recorded
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.MinInterval">
            <summary>
            The smallest Interval can be (typically 4K)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.MaxInterval">
            <summary>
            The largest Interval can be (typically maxInt).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventOptions">
            <summary>
            These are options to EnableProvider
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventOptions.None">
            <summary>
            No options
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventOptions.Stacks">
            <summary>
            Take a stack trace with the event
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLog">
            <summary>
            The data model for an Event trace log (ETL) file is simply a stream of events.     More sophisticated 
            analysis typically needs a a richer data model then ETL files can provide, and this is the 
            motivation for the ETLX (Event Trace Log eXtended) file format.   In particular any 
            analysis that needs non-sequential access to the events or manipulates stack traces associated 
            with events needs the additional support that the ETLX format provides.   See the TraceEventProgrammers guide
            for more on the capabilities of ETLX.  
            <para>
            The TraceLog class is the programmatic representation of an ETLX file.   It represents the ETLX file as a whole.
            </para><para>
            ETLX files are typically created from ETL files using the TraceLog.OpenOrCreate method or more explicitly 
            by the TraceLog.CreateFromEventTraceLogFile. 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromEventTraceLogFile(System.String,System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Given the path to an ETW trace log file (ETL) file, create an ETLX file for the data. 
            <para>If etlxFilePath is null the output name is derived from etlFilePath by changing its file extension to .ETLX.</para>
            <returns>The name of the ETLX file that was generated.</returns>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.OpenOrConvert(System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Open an ETLX or ETL file as a ETLX file. 
            <para>
            This routine assumes that you follow normal conventions of naming ETL files with the .ETL file extension 
            and ETLX files with the .ETLX file extension.  It further assumes the ETLX file for a given ETL file 
            should be in a file named the same as the ETL file with the file extension changed.  
            </para><para>
            etlOrEtlxFilePath can be either the name of the ETL or ETLX file.   If the ETLX file does not
            exist or if it older than the corresponding ETL file then the ETLX file is regenerated with
            the given options.   However if an up-to-date ETLX file exists the conversion step is skipped.  
            </para><para>
            Ultimately the ETLX file is opened and the resulting TraceLog instance is returned.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromTraceEventSession(Microsoft.Diagnostics.Tracing.Session.TraceEventSession)">
            <summary>
            From a TraceEventSession, create a real time TraceLog Event Source.   Like a ETWTraceEventSource a TraceLogEventSource
            will deliver events in real time.   However an TraceLogEventSource has an underlying Tracelog (which you can access with
            the .Log Property) which lets you get at aggregated information (Processes, threads, images loaded, and perhaps most
            importantly TraceEvent.CallStack() will work.  Thus you can get real time stacks from events).  
            
            Note that in order for native stacks to resolve symbolically, you need to have some Kernel events turned on (Image, and Process)
            and only windows 8 has a session that allows both kernel and user mode events simultaneously.   Thus this is most useful
            on Win 8 systems.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.#ctor(System.String)">
            <summary>
            Opens an existing Extended Trace Event log file (ETLX) file.  See also TraceLog.OpenOrCreate. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackForEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            If the event has a call stack associated with it, retrieve it.   Returns null if there is not call stack associated with the event.
            <para>If you are retrieving many call stacks consider using GetCallStackIndexForEvent, as it is more efficient.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackIndexForEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            If the event has a call stack associated with it, retrieve CallStackIndex.   Returns CallStackIndex.Invalid if there is not call stack associated with the event.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetEvent(Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Given an eventIndex, get the event.  This is relatively expensive because we need to create a
            copy of the event that will not be reused by the TraceLog.   Ideally you would not use this API
            but rather use iterate over event using TraceEvents
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CurrentMachineIsCollectionMachine">
            <summary>
            Returns true if the  machine running this code is the same as the machine where the trace data was collected.   
            <para>
            If this returns false, the path names references in the trace cannot be inspected (since they are on a different machine).  
            </para> 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.ToString">
            <summary>
            An XML fragment that gives useful summary information about the trace as a whole.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.#ctor(Microsoft.Diagnostics.Tracing.Session.TraceEventSession)">
            <summary>
            Create a new real time session called 'sessionName' and connect a TraceLog to it and return that TraceLog.
            Functionality of TraceLog that does not depend on either remembering past EVENTS or require future 
            knowledge (e.g. stacks of kernel events), will 'just work'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.RemoveAllButLastEntries``1(System.Collections.Generic.GrowableArray{``0}@,System.Int32)">
            <summary>
            Removes all but the last 'keepCount' entries in 'growableArray' by sliding them down. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.DispatchClonedEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Forwards an event that was saved (cloned) to the dispatcher associated with the real time source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FlushRealTimeEvents(System.Object)">
            <summary>
            Flushes any event that has waited around long enough 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCodeAddressIndexAtEvent(System.UInt64,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Given a process's virtual address 'address' and an event which acts as a 
            context (determines which process and what time in that process), return 
            a CodeAddressIndex (which represents a particular location in a particular
            method in a particular DLL). It is possible that different addresses will
            go to the same code address for the same address (in different contexts).
            This is because DLLS where loaded in different places in different processes.
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCodeAddressAtEvent(System.UInt64,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            If an event has a field of type 'Address' the address can be converted to a symbolic value (a
            TraceCodeAddress) by calling this function.   C
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackIndexForEventIndex(Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Given an EventIndex for an event, retrieve the call stack associated with it
            (that can be given to TraceCallStacks). Many events may not have associated
            call stack in which case CallSTackIndex.Invalid is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackIndexForCSwitchBlockingEventIndex(Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Given a eventIndex for a CSWTICH event, return the call stack index for the thread
            that LOST the processor (the normal callStack is for the thread that GOT the CPU)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromTraceEventSource(Microsoft.Diagnostics.Tracing.TraceEventDispatcher,System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Given a source of events 'source' generated a ETLX file representing these events from them. This
            file can then be opened with the TraceLog constructor. 'options' can be null.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.SetupCallbacks(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            SetupCallbacks installs all the needed callbacks for TraceLog Processing (stacks, process, thread, summaries etc)
            on the TraceEventSource rawEvents.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CopyRawEvents(Microsoft.Diagnostics.Tracing.TraceEventDispatcher,FastSerialization.IStreamWriter)">
            <summary>
             Copies the events from the 'rawEvents' dispatcher to the output stream 'IStreamWriter'.  It
             also creates auxiliary data structures associated with the raw events (eg, processes, threads,
             modules, address lookup maps...  Basically any information that needs to be determined by
             scanning over the events during TraceLog creation should hook in here.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.AddAddressToCodeAddressMap(Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64)">
            <summary>
            This is a helper routine that adds the address 'address' in the event 'data' to the map from events
            to this list of addresses.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GenerateMemInfoRecordsPerProcess(Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData,FastSerialization.IStreamWriter)">
            <summary>
            Special logic to form MemInfoWSTraceData.   We take the single event (which has 
            The working sets for every process in the system, an split them out into N events
            each of which has the processID for the event set properly, and only has the
            information for that process.    The first 3 processes in the list are -1, -2, and -3
            that have special meaning.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetIncompleteStackForStackEvent(Microsoft.Diagnostics.Tracing.TraceEvent,System.Int64)">
            <summary>
            Given just the stack event and the timestamp for the event the stack event is to attach to, find
            the IncompleteStack for the event.   If the event to attach to cannot be this will return null
            but otherwise it will make an IncompleteStack entry if one does not already exist or it.   
            
            As part of allocating an Incomplete stack, it will increment the stack counts for target event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EmitStackOnExitFromKernel(Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack@,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack)">
            <summary>
            Do the processing necessary to attach the user mode stack 'userModeStack' to any of the stacks in listOfIncompleteKernelStacks.
            It then clears this list.   While doing this processing it will check to see if the target stack 'target' is in that list and
            it will return true if it was.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EmitStackOnExitFromKernel(Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack@,System.UInt64,Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack)">
            <summary>
            Do the processing necessary to attach the user mode stack 'userModeStack' to any of the stacks in listOfIncompleteKernelStacks.
            It then clears this list.   While doing this processing it will check to see if the target stack 'target' is in that list and
            it will return true if it was.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.LogStackDefinition(Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData)">
            <summary>
            Called when we get a definition event (for either a user mode or kernel mode stack fragment). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CategorizeThread(Microsoft.Diagnostics.Tracing.TraceEvent,System.String)">
            <summary>
            Put the thread that owns 'data' in to the category 'category.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.ProcessExtendedData(Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt16,Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts)">
            <summary>
            Process any extended data (like Win7 style stack traces) associated with 'data'
            returns true if the event should be considered a bookkeeping event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.SeekToTimeOnPage(FastSerialization.PinnedStreamReader,System.Int64,System.Int32,System.Int32@,FastSerialization.StreamLabel[])">
            <summary>
            Advance 'reader' until it point at a event that occurs on or after 'timeQPC'.  on page
            'pageIndex'.  If 'positions' is non-null, fill in that array.  Also return the index in
            'positions' for the entry that was found.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.AllocLookup">
            <summary>
            We need a TraceEventDispatcher in the Enumerators for TraceLog that know how to LOOKUP an event 
            We don't actually dispatch through it.  We do mutate the templates (to point a particular data
            record), but once we are done with it we can reuse this TraceEventDispatcher again an again
            (it is only concurrent access that is a problem).  Thus we have an Allocate and Free pattern
            to reuse them in the common case of sequential access.  
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.cswitchBlockingEventsToStacks">
            <summary>
            The context switch event gives the stack of the thread GETTING the CPU, but it is also very useful
            to have this stack at the point of blocking.   cswitchBlockingEventsToStacks gives this stack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.AddStackToEvent(Microsoft.Diagnostics.Tracing.EventIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Add a new entry that associates the stack 'stackIndex' with the event with index 'eventIndex'
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Events">
            <summary>
            All the events in the ETLX file. The returned TraceEvents instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to further filter the evens before enumerating over them.  
            
            Note that the TraceEvent returned from this IEnumerable may only be used for one iteration of the foreach.
            (it is reused for the next event).  If you need more lifetime than that you must call Clone() (see 'Lifetime
            Constraints' in the programmers guide for more).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Processes">
            <summary>
            All the Processes that logged an event in the ETLX file.  The returned TraceProcesses instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to select particular a particular process.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Threads">
            <summary>
            All the Threads that logged an event in the ETLX file.  The returned TraceThreads instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to select particular thread.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.ModuleFiles">
            <summary>
            All the module files (DLLs) that were loaded by some process in the ETLX file.  The returned TraceModuleFiles instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to select particular module file.  
            </summary>  
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CallStacks">
            <summary>
            All the call stacks in the ETLX file.  Normally you don't enumerate over these, but use you use other methods on TraceCallStacks 
            information about code addresses using CallStackIndexes. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CodeAddresses">
            <summary>
            All the code addresses in the ETLX file.  Normally you don't enumerate over these, but use you use other methods on TraceCodeAddresses 
            information about code addresses using CodeAddressIndexes. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Stats">
            <summary>
            Summary statistics on the events in the ETX file.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.MaxEventIndex">
            <summary>
            Events are given an Index (ID) that are unique across the whole TraceLog.   They are not guaranteed
            to be sequential, but they are guaranteed to be between 0 and MaxEventIndex.  Ids can be used to
            allow clients to associate additional information with event (with a side lookup table).   See
            TraceEvent.EventIndex and EventIndex for more 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EventCount">
            <summary>
            The total number of events in the log.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Size">
            <summary>
            The size of the log file in bytes.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EventsLost">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FilePath">
            <summary>
            The file path for the ETLX file associated with this TraceLog instance.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.MachineName">
            <summary>
            The machine on which the log was collected.  Returns empty string if unknown. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.OSName">
            <summary>
            The name of the Operating system.  Returns empty string if unknown.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.OSBuild">
            <summary>
            The build number information for the OS.  Returns empty string if unknown.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.BootTime">
            <summary>
            The time the machine was booted.   Returns DateTime.MinValue if it is unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.UTCOffsetMinutes">
            <summary>
            This is the number of minutes between the local time where the data was collected and UTC time.  
            It is negative if your time zone is WEST of Greenwich.  This DOES take Daylights savings time into account
            but might be a daylight savings time transition happens inside the trace.  
            May be unknown, in which case it returns null.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.HasPdbInfo">
            <summary>
            When an ETL file is 'merged', for every DLL in the trace information is added that allows the symbol
            information (PDBS) to be identified unambiguously on a symbol server.   This property returns true
            if the ETLX file was created from an ETL file with this added information.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.MemorySizeMeg">
            <summary>
            The size of the main memory (RAM) on the collection machine.  Will return 0 if memory size is unknown 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.HasCallStacks">
            <summary>
            Are there any event in trace that has a call stack associated with it. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.SampleProfileInterval">
            <summary>
            If Kernel CPU sampling events are turned on, CPU samples are taken at regular intervals (by default every MSec).
            <para>This property returns the time interval between samples.  
            </para><para>
            If the sampling interval was changed over the course of the trace, this property does not reflect that.  It
            returns the first value it had in the trace.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Truncated">
            <summary>
            There is a size limit for ETLX files.  Thus  it is possible that the data from the original ETL file was truncated.  
            This property returns true if this happened.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Parsers">
            <summary>
            Returns all the TraceEventParsers associated with this log.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack">
            <summary>
            Holds information about stacks associated with an event.  This is a transient structure.  We only need it 
            until all the information is collected for a particular event, at which point we can create a 
            CallStackIndex for the stack and eventsToStacks table.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.Clear">
            <summary>
            Clear clears entires that typically don't get set when we only have 1 frame fragment
            We can recycle the entries without setting these in that case.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.Initialize(Microsoft.Diagnostics.Tracing.EventIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Clear all entries that can potentially change every time.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.LogKernelStackFragment(System.Void*,System.Int32,System.Int32,System.Int64,Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Log the Kernel Stack fragment.  We simply remember all the frames (converted to CodeAddressIndexes).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.LogKernelStackFragment(System.UInt64,Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Log the kernel stack fragment.  Returns true if all the pieces of the stack fragment are collected
            (we don't have to log something on the thread).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.LogUserStackFragment(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.EmitStackForEventIfReady(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Determine if 'stackInfo' is complete and if so emit it to the 'eventsToStacks' array.  If 'force' is true 
            then force what information there is out even if it is not complete (there is nothing else coming). 
            
            Returns true if it was able to emit the stack
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.IsDead">
            <summary>
            returns true if the IncompleteStack is dead (just waiting to be reused).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.BlockingEventIndex">
            <summary>
            We track the stacks for when CSwitches block, this is the CSWITCH event where that blocking happened.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfo">
            <summary>
            We need to remember the the EventIndexes of the events that were 'just before' this event so we can
            associate eventToStack traces with the event that actually caused them.  PastEventInfo does this.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfo.GetPreviousEventIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfoIndex,System.Int32,System.Boolean,Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Returns the previous Event on the 'threadID'.  Events with -1 thread IDs are also always returned.   
            Returns PastEventInfoIndex.Invalid if there are not more events to consider.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfo.GetBestEventForQPC(System.Int64,System.Int32)">
            <summary>
            Find the event event on thread threadID to the given QPC timestamp
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource">
            <summary>
            Represents a source for a TraceLog file (or real time stream).  It is basically a TraceEventDispatcher
            (TraceEventSource) but you can also get at the TraceLog for it as well.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.Process">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.Dispose(System.Boolean)">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.TraceLog">
            <summary>
            Returns the TraceLog associated with this TraceLogEventSource. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.CurrentEventIndex">
            <summary>
            Returns the event Index of the 'current' event (we post increment it so it is always one less)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.EventsLost">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats">
            <summary>
            TraceEventStats represents the summary statistics (counts) of all the events in the log.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats.ToString">
            <summary>
            An XML representation of the TraceEventStats (for Debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats.GetEventCounts(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Given an event 'data' look up the statistics for events that type.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats.Count">
            <summary>
            The total number of distinct event types (there will be a TraceEventCounts for each distinct event Type)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts">
            <summary>
            TraceEventCount holds number of events (Counts) and the number of events with call stacks associated with them (StackCounts) for a particular event type.   
            <para>It also has properties for looking up the event and provider names, but this information can only be complete if all the TraceEventParsers needed
            were associated with the TraceLog instance.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.ToString">
            <summary>
            An XML representation  of the top level statistics of the TraceEventCounts. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.ProviderName">
            <summary>
            Returns a provider name for events in this TraceEventCounts.   It may return a string with a GUID or even
            UnknownProvider for classic ETW if the event is unknown to the TraceLog.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.EventName">
            <summary>
            Returns a name for events in this TraceEventCounts.   If the event is unknown to the Tracelog 
            it will return EventID(XXX) (for manifest based events) or Task(XXX)/Opcode(XXX) (for classic events)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.PayloadNames">
            <summary>
            Returns the payload names associated with this Event type.   Returns null if the payload names are unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.IsClassic">
            <summary>
            Returns true the provider associated with this TraceEventCouts is a classic (not manifest based) ETW provider.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.ProviderGuid">
            <summary>
            Returns the provider GUID of the events in this TraceEventCounts.  Returns Guid.Empty if IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.EventID">
            <summary>
            Returns the event ID of the events in this TraceEventCounts.  Returns TraceEventID.Illegal if IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.TaskGuid">
            <summary>
            Returns the Task GUID of the events in this TraceEventCounts.  Returns Guid.Empty if not IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.Opcode">
            <summary>
            Returns the Opcode of the events in the TraceEventCounts.  Returns TraceEventOpcode.Info if not IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.AveragePayloadSize">
            <summary>
            Returns the average size of the event specific payload data (not the whole event) for all events in the TraceEventsCounts.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.Count">
            <summary>
            Returns the number of events in the TraceEventCounts.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.StackCount">
            <summary>
            Returns the number of events in the TraceEventCounts that have stack traces associated with them.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.FullName">
            <summary>
            Returns the full name of the event (ProviderName/EventName)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents">
            <summary>
            A TraceEvents represents a list of TraceEvent instances.  It is IEnumerable&lt;TraceEvent&gt; but 
            also has additional useful ways of filtering the list.  
            
            Note that the TraceEvent returned from this IEnumerable may only be used for one iteration of the foreach.
            (it is reused for the next event).  If you need more lifetime than that you must call Clone() (see 'Lifetime
            Constraints' in the programmers guide for more).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.ByEventType``1">
            <summary>
            Returns a list of events in the TraceEvents that return a payload of type T.   Thus
            ByEventType &lt; TraceEvent &gt; returns all events.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.GetSource">
            <summary>
            Returns a TraceEventDispatcher (a push model object on which you can register
            callbacks for particular events) that will push all the vents in the TraceEvents.  
            
            Note that the TraceEvent returned from this callback may only be used for the duration of the callback.
            If you need more lifetime than that you must call Clone() (see 'Lifetime Constraints' in the programmers guide for more).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.Backwards">
            <summary>
            Returns a new list which is the same as the TraceEvents but the events are
            delivered from last to first.  This allows you to search backwards in the
            event stream.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.FilterByTime(System.DateTime,System.DateTime)">
            <summary>
            Filter the events by time.  Both starTime and endTime are inclusive. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.FilterByTime(System.Double,System.Double)">
            <summary>
            Filter the events by time.  StartTimeRelativeMSec and endTimeRelativeMSec are relative to the SessionStartTime and are inclusive.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.Filter(System.Predicate{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Create new list of Events that has all the events in the current TraceEvents
            that pass the given predicate.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.Log">
            <summary>
            Returns the TraceLog associated with the events in the TraceEvents
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.StartTime">
            <summary>
            Returns a time that is guaranteed  to be before the first event in the TraceEvents list.  
            It is returned as DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.StartTimeRelativeMSec">
            <summary>
            Returns a time that is guaranteed to be before the first event in the TraceEvents list.  
            It is returned as floating point number of MSec since the start of the TraceLog
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.EndTime">
            <summary>
            Returns a time that is guaranteed to be after the last event in the TraceEvents list.  
            It is returned as DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.EndTimeRelativeMSec">
            <summary>
            Returns a time that is guaranteed to be after the last event in the TraceEvents list.  
            It is returned as floating point number of MSec since the start of the TraceLog
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex">
            <summary>
            Each process is given a unique index from 0 to TraceProcesses.Count-1 and unlike 
            the OS Process ID, is  unambiguous (The OS process ID can be reused after a
            process dies).  ProcessIndex represents this index.   By using an enum rather than an int
            it allows stronger typing and reduces the potential for errors.  
            <para>
            It is expected that users of this library might keep arrays of size TraceProcesses.Count to store
            additional data associated with a process in the trace.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex.Invalid">
            <summary>
            Returned when no appropriate Process exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses">
            <summary>
            A TraceProcesses instance represents the list of processes in the Event log.  
            
            TraceProcesses are IEnumerable, and will return the processes in order of creation time.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.GetProcess(System.Int32,System.Double)">
            <summary>
            Given an OS process ID and a time, return the last TraceProcess that has the same process ID,
            and whose process start time is less than 'timeRelativeMSec'. 
            <para>
            If 'timeRelativeMSec' is during the processes's lifetime this is guaranteed to be the correct process. 
            for the given process ID since process IDs are unique during the lifetime of the process.  
            </para><para>
            If timeRelativeMSec == TraceLog.SessionDuration this method will return the last process with 
            the given process ID, even if it had died during the trace.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.LastProcessWithID(System.Int32)">
            <summary>
            Returns the last process in the log with the given process ID.  Useful when the logging session
            was stopped just after the processes completed (a common scenario).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.FirstProcessWithName(System.String,System.Double)">
            <summary>
            Find the first process in the trace that has the process name 'processName' and whose process
            start time is after the given point in time.  
            <para>A process's name is the file name of the EXE without the extension.</para>
            <para>Processes that began before the trace started have a start time of 0,  Thus 
            specifying 0 for the time will include processes that began before the trace started.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.LastProcessWithName(System.String,System.Double)">
            <summary>
            Find the last process in the trace that has the process name 'processName' and whose process
            start time is after the given point in time.  
            <para>A process's name is the file name of the EXE without the extension.</para>
            <para>Processes that began before the trace started have a start time of 0,  Thus 
            specifying 0 for the time will include processes that began before the trace started.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.ToString">
            <summary>
            An XML representation of the TraceEventProcesses (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.System#Collections#Generic#IEnumerable{Microsoft#Diagnostics#Tracing#Etlx#TraceProcess}#GetEnumerator">
            <summary>
            Enumerate all the processes that occurred in the trace log, ordered by creation time.   
            </summary> 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.GetProcess(System.Int32,System.Int64)">
            <summary>
            Given an OS process ID and a time, return the last TraceProcess that has the same process ID,
            and whose offset start time is less than 'timeQPC'. If 'timeQPC' is during the thread's lifetime this
            is guaranteed to be the correct process. Using timeQPC = TraceLog.sessionEndTimeQPC will return the
            last process with the given PID, even if it had died.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            TraceProcesses represents the entire ETL moduleFile log.   At the node level it is organized by threads.  
            
            The TraceProcesses also is where we put various caches that are independent of the process involved. 
            These include a cache for TraceModuleFile that represent native images that can be loaded into a
            process, as well as the process lookup tables and a cache that remembers the last calls to
            GetNameForAddress(). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.Log">
            <summary>
            The log associated with this collection of processes. 
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.Count">
            <summary>
            The count of the number of TraceProcess instances in the TraceProcesses list. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.Item(Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex)">
            <summary>
            Each process that occurs in the log is given a unique index (which unlike the PID is unique), that
            ranges from 0 to Count - 1.   Return the TraceProcess for the given index.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess">
            <summary>
            A TraceProcess represents a process in the trace. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ToString">
            <summary>
            An XML representation of the TraceEventProcess (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.#ctor(System.Int32,Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex)">
            <summary>
            Create a new TraceProcess.  It should only be done by log.CreateTraceProcess because
            only TraceLog is responsible for generating a new ProcessIndex which we need.   'processIndex'
            is a index that is unique for the whole log file (where as processID can be reused).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.codeAddressesInProcess">
            <summary>
            This table allows us to intern codeAddress so we only at most one distinct address per process.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.unresolvedCodeAddresses">
            <summary>
            We also keep track of those code addresses that are NOT yet resolved to at least a File (for JIT compiled 
            things this would be to a method 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.jitMethods">
            <summary>
            This table has a entry for each JIT compiled method that remembers its range.   It is actually only needed
            for the real time case, as the non-real time case you resolve code addresses on method unload/rundown and thus
            don't need to remember the information.   This table is NOT persisted in the ETLX file since is only needed
            to convert raw addresses into TraceMethods.  
            
            It is a array of arrays to make insertion efficient.  Most of the time JIT methods will be added in 
            contiguous memory (thus will be in order), however from time to time things will 'jump around' to a new 
            segment.   By having a list of lists, (which are in order in both lists) you can efficiently (log(N)) search
            as well as insert.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.scheduledActivityIdToActivityIndex">
            <summary>
            Maps a newly scheduled "user" activity ID to the ActivityIndex of the
            Activity. This keeps track of currently created/scheduled activities
            that have not started yet, and for multi-trigger events, created/scheduled
            activities that have not conclusively "died" (e.g. by having their "user" 
            activity ID reused by another activity).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ProcessID">
            <summary>
            The OS process ID associated with the process. It is NOT unique across the whole log.  Use
            ProcessIndex for that. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ProcessIndex">
            <summary>
            The index into the logical array of TraceProcesses for this process. Unlike ProcessID (which
            may be reused after the process dies, the process index is unique in the log. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Name">
            <summary>
            This is a short name for the process.  It is the image file name without the path or suffix.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.CommandLine">
            <summary>
            The command line that started the process (may be empty string if unknown)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ImageFileName">
            <summary>
            The path name of the EXE that started the process (may be empty string if unknown)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.StartTime">
            <summary>
            The time when the process started.  Returns the time the trace started if the process existed when the trace started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.StartTimeRelativeMsec">
            <summary>
            The time when the process started.  Returns the time the trace started if the process existed when the trace started.  
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EndTime">
            <summary>
            The time when the process ended.  Returns the time the trace ended if the process existed when the trace ended.  
            Returned as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EndTimeRelativeMsec">
            <summary>
            The time when the process ended.  Returns the time the trace ended if the process existed when the trace ended. 
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ParentID">
            <summary>
            The process ID of the parent process 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Parent">
            <summary>
            The process that started this process.  Returns null if unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ExitStatus">
            <summary>
            If the process exited, the exit status of the process.  Otherwise null. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.CPUMSec">
            <summary>
            The amount of CPU time spent in this process based on the kernel CPU sampling events.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Is64Bit">
            <summary>
            Returns true if the process is a 64 bit process
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Log">
            <summary>
            The log file associated with the process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Threads">
            <summary>
            A list of all the threads that occurred in this process.  
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.LoadedModules">
            <summary>
            Returns the list of modules that were loaded by the process.  The modules may be managed or
            native, and include native modules that were loaded event before the trace started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EventsInProcess">
            <summary>
            Filters events to only those for a particular process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EventsDuringProcess">
            <summary>
            Filters events to only that occurred during the time the process was alive. 
            </summary>
            
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.MethodLookupInfo">
            <summary>
            This is all the information needed to remember about at JIT compiled method (used in the jitMethods variable)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex">
            <summary>
            Each thread is given a unique index from 0 to TraceThreads.Count-1 and unlike 
            the OS Thread ID, is  unambiguous (The OS thread ID can be reused after a
            thread dies).  ThreadIndex represents this index.   By using an enum rather than an int
            it allows stronger typing and reduces the potential for errors.  
            <para>
            It is expected that users of this library might keep arrays of size TraceThreads.Count to store
            additional data associated with a process in the trace.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex.Invalid">
            <summary>
            Returned when no appropriate Thread exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads">
            <summary>
            A TraceThreads represents the list of threads in a process. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.System#Collections#Generic#IEnumerable{Microsoft#Diagnostics#Tracing#Etlx#TraceThread}#GetEnumerator">
            <summary>
            Enumerate all the threads that occurred in the trace log. It does so in order of their thread
            offset events in the log.  
            </summary> 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.GetThread(System.Int32,System.Double)">
            <summary>
            Given an OS thread ID and a time, return the last TraceThread that has the same thread ID,
            and whose start time is less than 'timeRelativeMSec'. If 'timeRelativeMSec' is during the thread's lifetime this
            is guaranteed to be the correct thread. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.ToString">
            <summary>
            An XML representation of the TraceThreads (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            TraceThreads   represents the collection of threads in a process. 
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.GetOrCreateThread(System.Int32,System.Int64,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.Boolean)">
            <summary>
            Get the thread for threadID and timeQPC.   Create if necessary.  If 'isThreadCreateEvent' is true, 
            then force  the creation of a new thread EVEN if the thread exist since we KNOW it is a new thread 
            (and somehow we missed the threadEnd event).   Process is the process associated with the thread.  
            It can be null if you really don't know the process ID.  We will try to fill it in on another event
            where we DO know the process id (ThreadEnd event).     
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.Count">
            <summary>
            The count of the number of TraceThreads in the trace log. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.Item(Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex)">
            <summary>
            Each thread that occurs in the log is given a unique index (which unlike the PID is unique), that
            ranges from 0 to Count - 1.   Return the TraceThread for the given index.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceThread">
            <summary>
            A TraceThread represents a thread of execution in a process.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.GetActivityIndex(System.Double)">
            <summary>
            REturns the activity this thread was working on at the time instant 'relativeMsec' 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ToString">
            <summary>
            An XML representation of the TraceThread (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.#ctor(System.Int32,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex)">
            <summary>
            Create a new TraceProcess.  It should only be done by log.CreateTraceProcess because
            only TraceLog is responsible for generating a new ProcessIndex which we need.   'processIndex'
            is a index that is unique for the whole log file (where as processID can be reused).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.activityIds">
            <summary>
            This is a list of the activities (snippet of threads) that have run on this
            thread.   They are ordered by time so you can binary search for your activity based
            on timestamp.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.lastBlockingCSwitchEventIndex">
            <summary>
            We want to have the stack for when CSwtichs BLOCK as well as when they unblock.
            this variable keeps track of the last blocking CSWITCH on this thread so that we can
            compute this.   It is only used during generation of a TraceLog file.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ThreadID">
            <summary>
            The OS process ID associated with the process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ThreadIndex">
            <summary>
            The index into the logical array of TraceThreads for this process.  Unlike ThreadId (which
            may be reused after the thread dies) the T index is unique over the log.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.Process">
            <summary>
            The process associated with the thread. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.StartTime">
            <summary>
            The time when the thread started.  Returns the time the trace started if the thread existed when the trace started.  
            Returned as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.StartTimeRelativeMSec">
            <summary>
            The time when the thread started.  Returns the time the trace started if the thread existed when the trace started.  
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EndTime">
            <summary>
            The time when the thread ended.  Returns the time the trace ended if the thread existed when the trace ended.  
            Returned as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EndTimeRelativeMSec">
            <summary>
            The time when the thread ended.  Returns the time the trace ended if the thread existed when the trace ended. 
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.CPUMSec">
            <summary>
            The amount of CPU time spent on this thread based on the kernel CPU sampling events.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EventsInThread">
            <summary>
            Filters events to only those for a particular thread. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EventsDuringThread">
            <summary>
            Filters events to only those that occurred during the time a the thread was alive. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.DefaultActivityIndex">
            <summary>
            Represents the "default" activity for the thread, the activity that no one has set
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ThreadInfo">
            <summary>
            ThreadInfo is a string that identifies the thread symbolically.   (e.g. .NET Threadpool, .NET GC)  It may return null if there is no useful symbolic name.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.VerboseThreadName">
            <summary>
            VerboseThreadName is a name for the thread including the ThreadInfo and the CPU time used.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.UserStackBase">
            <summary>
            The base of the thread's stack.  This is just past highest address in memory that is part of the stack
            (we don't really know the lower bound (userStackLimit is this lower bound at the time the thread was created
            which is not very useful).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules">
            <summary>
            TraceLoadedModules represents the collection of modules (loaded DLLs or EXEs) in a 
            particular process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetModuleContainingAddress(System.UInt64,System.Double)">
            <summary>
            Returns the module which was mapped into memory at at 'timeRelativeMSec' and includes the address 'address' 
            <para> Note that Jit compiled code is placed into memory that is not associated with the module and thus will not
            be found by this method.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetLoadedModule(System.String,System.Double)">
            <summary>
            Returns the module representing the unmanaged load of a particular fiele at a given time. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.ToString">
            <summary>
            An XML representation of the TraceLoadedModules (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetEnumerator">
            <summary>
            Returns all modules in the process.  Note that managed modules may appear twice 
            (once for the managed load and once for an unmanaged (LoadLibrary) load.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetLoadedModule(System.String,System.Int64)">
            <summary>
            This function will find the module associated with 'address' at 'timeQPC' however it will only
            find modules that are mapped in memory (module associated with JIT compiled methods will not be found).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.FindManagedModuleAndIndex(System.Int64,System.Int64,System.Int32@)">
            <summary>
            Finds the index and module for an a given managed module ID.  If not found, new module
            should be inserted at index + 1;
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.FindModuleAndIndexContainingAddress(System.UInt64,System.Int64,System.Int32@)">
            <summary>
            Finds the index and module for an address that lives within the image.  If the module
            did not match the new entry should go at index+1.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.Process">
            <summary>
            The process in which this Module is loaded.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule">
            <summary>
            A TraceLoadedModule represents a module (DLL or EXE) that was loaded into a process.  It represents
            the time that this module was mapped into the processes address space.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ToString">
            <summary>
            An XML representation of the TraceLoadedModule (used for debugging)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.FastSerialization#IFastSerializable#ToStream(FastSerialization.Serializer)">
            <summary>
            See IFastSerializable.ToStream.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.FastSerialization#IFastSerializable#FromStream(FastSerialization.Deserializer)">
            <summary>
            See IFastSerializable.FromStream.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ImageBase">
            <summary>
            The address where the DLL or EXE was loaded.   Will return 0 for managed modules without NGEN images.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.LoadTime">
            <summary>
            The load time is the time the LoadLibrary was done if it was loaded from a file, otherwise is the
            time the CLR loaded the module.  Expressed as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.LoadTimeRelativeMSec">
            <summary>
            The load time is the time the LoadLibrary was done if it was loaded from a file, otherwise is the
            time the CLR loaded the module.  Expressed as as MSec from the beginning of the trace.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.UnloadTime">
            <summary>
            The load time is the time the FreeLibrary was done if it was unmanaged, otherwise is the
            time the CLR unloaded the module.  Expressed as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.UnloadTimeRelativeMSec">
            <summary>
            The load time is the time the FreeLibrary was done if it was unmanaged, otherwise is the
            time the CLR unloaded the module.  Expressed as MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.Process">
            <summary>
            The process that loaded this module
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ModuleID">
            <summary>
            An ID that uniquely identifies the module in within the process.  Works for both the managed and unmanaged case.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ModuleFile">
            <summary>
            If this managedModule was a file that was mapped into memory (eg LoadLibary), then ModuleFile points at
            it.  If a managed module does not have a file associated with it, this can be null.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.FilePath">
            <summary>
            Shortcut for ModuleFile.FilePath, but returns the empty string if ModuleFile is null
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.Name">
            <summary>
            Shortcut for ModuleFile.Name, but returns the empty string if ModuleFile is null
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ManagedModule">
            <summary>
            Because .NET applications have AppDomains, a module that is loaded once from a process 
            perspective, might be loaded several times (once for each AppDomain) from a .NET perspective 
            <para> This property returns the loadedModule record for the first such managed module
            load associated with this load.   
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule">
            <summary>
            A TraceManagedModule represents the loading of a .NET module into .NET AppDomain.
            It represents the time that that module an be used in the AppDomain.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.ToString">
            <summary>
            An XML representation of the TraceManagedModule (used for debugging)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.ModuleID">
            <summary>
            The module ID that the .NET Runtime uses to identify the file (module) associated with this managed module
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.AssmeblyID">
            <summary>
            The Assembly ID that the .NET Runtime uses to identify the assembly associated with this managed module. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.IsAppDomainNeutral">
            <summary>
            Returns true if the managed module was loaded AppDOmain Neutral (its code can be shared by all appdomains in the process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.NativeModule">
            <summary>
            If the managed module is an IL module that has an NGEN image, return it. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex">
            <summary>
            CallStackIndex uniquely identifies a callstack within the log.  Valid values are between 0 and
            TraceCallStacks.Count-1. Thus, an array can be used to 'attach' data to a call stack.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex.Invalid">
            <summary>
            Returned when no appropriate CallStack exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks">
            <summary>
            Call stacks are so common in most traces, that having a .NET object (a TraceEventCallStack) for
            each one is often too expensive.   As optimization, TraceLog also assigns a call stack index
            to every call stack and this index uniquely identifies the call stack in a very light weight fashion.
            <para>
            To be useful, however you need to be able to ask questions about a call stack index without creating
            a TraceEventCallStack.   This is the primary purpose of a TraceCallStacks (accessible from TraceLog.CallStacks).   
            It has a set of 
            methods that take a CallStackIndex and return properties of the call stack (like its caller or 
            its code address).  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.CodeAddressIndex(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, return the code address index representing the top most frame associated with it
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Caller(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, look up the call stack  index for caller.  Returns CallStackIndex.Invalid at top of stack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Depth(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns the number of callers for the call stack 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.ThreadIndex(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns the ThreadIndex which represents the thread for the call stack
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Thread(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns the TraceThread which represents the thread for the call stack
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.ToString">
            <summary>
            An XML representation of the TraceCallStacks (used for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.GetEnumerator">
            <summary>
            IEnumerable Support
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.SetSize(System.Int32)">
            <summary>
            Used to 'undo' the effects of adding a eventToStack that you no longer want.  This happens when we find
            out that a eventToStack is actually got more callers in it (when a eventToStack is split).  
            </summary>
            <param name="origSize"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.GetRootForThread(Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex)">
            <summary>
            Returns an index that represents the 'threads' of the stack.  It encodes the thread which owns this stack into this. 
            We encode this as -ThreadIndex - 2 (since -1 is the Invalid node)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Count">
            <summary>
            Returns the count of call stack indexes (all Call Stack indexes are strictly less than this).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Item(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns a TraceCallStack for it.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.CodeAddresses">
            <summary>
            Returns the TraceCodeAddresses instance that can resolve CodeAddressIndexes in the TraceLog 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack">
            <summary>
            A TraceCallStack is a structure that represents a call stack as a linked list. Each TraceCallStack 
            contains two properties, the CodeAddress for the current frame, and the TraceCallStack of the
            caller of this frame.   The Caller property will return null at the thread start frame.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.ToString">
            <summary>
            An XML representation of the TraceCallStack (used for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.ToString(System.Text.StringBuilder)">
            <summary>
            Writes an XML representation of the TraceCallStack to the stringbuilder 'sb'
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.CallStackIndex">
            <summary>
             Return the CallStackIndex that uniquely identifies this call stack in the TraceLog.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.CodeAddress">
            <summary>
            Returns the TraceCodeAddress for the current method frame in the linked list of frames.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.Caller">
            <summary>
            The TraceCallStack for the caller of of the method represented by this call stack.  Returns null at the end of the list. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.Depth">
            <summary>
            The depth (count of callers) of this call stack.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex">
            <summary>
            CodeAddressIndex uniquely identifies a symbolic codeAddress within the log . 
            Valid values are between 0 and TraceCodeAddresses.Count. Thus, an array
            can be used to 'attach' data to a code address.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex.Invalid">
            <summary>
            Returned when no appropriate Method exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses">
            <summary>
            Code addresses are so common in most traces, that having a .NET object (a TraceCodeAddress) for
            each one is often too expensive.   As optimization, TraceLog also assigns a code address index
            to every code address and this index uniquely identifies the code address in a very light weight fashion.
            <para>
            To be useful, however you need to be able to ask questions about a code address index without creating
            a TraceCodeAddress.   This is the primary purpose of a TraceCodeAddresses (accessible from TraceLog.CodeAddresses).   
            It has a set of 
            methods that take a CodeAddressIndex and return properties of the code address (like its method, address, and module file)
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Name(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, return the name associated with it (the method name).  It will
            have the form MODULE!METHODNAME.   If the module name is unknown a ? is used, and if the
            method name is unknown a hexadecimal number is used as the method name.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Address(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the virtual address of the code in the process.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ModuleFileIndex(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the index for the module file (representing the file's path) 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.MethodIndex(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the index for the method associated with the code address (it may return MethodIndex.Invalid 
            if no method can be found). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ModuleFile(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the module file (the DLL paths) associated with it
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ILOffset(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            If the code address is associated with managed code, return the IL offset within the method.    If the method
            is unmanaged -1 is returned.   To determine the IL offset the PDB for the NGEN image (for NGENed code) or the
            correct .NET events (for JIT compiled code) must be present.   If this information is not present -1 is returned. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.LookupSymbolsForModule(Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile)">
            <summary>
            Initially CodeAddresses for unmanaged code will have no useful name.  Calling LookupSymbolsForModule 
            lets you resolve the symbols for a particular file so that the TraceCodeAddresses for that DLL
            will have Methods (useful names) associated with them.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetSourceLine(Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            A TraceCodeAddress can contain a method name, but does not contain number information.   To 
            find line number information you must read the PDB again and fetch it.   This is what
            GetSoruceLine does.  
            <para> 
            Given a SymbolReader (which knows how to look up PDBs) and a code address index (which
            represent a particular point in execution), find a SourceLocation (which represents a
            particular line number in a particular source file associated with the code address.
            Returns null if anything goes wrong (and diagnostic information will be written to the
            log file associated with the SymbolReader.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ToString">
            <summary>
            Returns an XML representation of the TraceCodeAddresses (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.NativeMap(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            We expose ILToNativeMap internally so we can do diagnostics.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetEnumerator">
            <summary>
            IEnumerable support.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.OpenPdbForModuleFileWithCache(Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile)">
            <summary>
            Calls OpenPdbForModuleFile and caches the last entry
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.AddMethod(Microsoft.Diagnostics.Tracing.Parsers.Clr.MethodLoadUnloadVerboseTraceData)">
            <summary>
            Called when JIT CLR Rundown events are processed. It will look if there is any
            address that falls into the range of the JIT compiled method and if so log the
            symbolic information (otherwise we simply ignore it)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.AddMethod(Microsoft.Diagnostics.Tracing.Parsers.JScript.MethodLoadUnloadJSTraceData,System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Etlx.JavaScriptSourceKey,System.String})">
            <summary>
            Adds a JScript method 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ForAllUnresolvedCodeAddressesInRange(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.UInt64,System.Int32,Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ForAllCodeAddrAction)">
            <summary>
            Allows you to get a callback for each code address that is in the range from start to 
            start+length within the process 'process'.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetOrCreateCodeAddressIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.Int64,System.UInt64)">
            <summary>
            Gets the symbolic information entry for 'address' which can be any address.  If it falls in the
            range of a symbol, then that symbolic information is returned.  Regardless of whether symbolic
            information is found, however, an entry is created for it, so every unique address has an entry
            in this table.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ProcessForAddress(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.UInt64)">
            <summary>
            All processes might have kernel addresses in them, this returns the kernel process (process ID == 0) if 'address' is a kernel address.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetSortedCodeAddressIndexes">
            <summary>
            Sort from lowest address to highest address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.LookupSymbols(Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Do symbol resolution for all addresses in the log file. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.OpenPdbForModuleFile(Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile)">
            <summary>
            Look up the SymbolModule (open PDB) for a given moduleFile.   Will generate NGEN pdbs as needed.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.FindAndRemove(System.Int64,Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ILMapIndex@)">
            <summary>
            Find the ILToNativeMap for 'methodId' in process associated with 'processIndex' 
            and then remove it from the table (this is what you want to do when the method is unloaded)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Count">
            <summary>
            Returns the count of code address indexes (all code address indexes are strictly less than this).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Item(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns a TraceCodeAddress for it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Methods">
            <summary>
            Returns the TraceMethods object that can look up information from MethodIndexes 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ModuleFiles">
            <summary>
            Returns the TraceModuleFiles that can look up information about ModuleFileIndexes
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ManagedMethodRecordCount">
            <summary>
            Indicates the number of managed method records that were encountered.  This is useful to understand if symbolic information 'mostly works'.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.TotalCodeAddresses">
            <summary>
            The number of times a particular code address appears in the log.   Unlike TraceCodeAddresses.Count, which tries
            to share a code address as much as possible, TotalCodeAddresses counts the same code address in different 
            call stacks (and even if in the same stack) as distinct.    This makes TotalCodeAddresses a better measure of
            the 'popularity' of a particular address (which can factor into decisions about whether to call LookupSymbolsForModule)
            <para>
            The sum of ModuleFile.CodeAddressesInModule for all modules should sum to this number.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.UnsafePDBMatching">
            <summary>
            If set to true, will only use the name of the module and not the PDB GUID to confirm that a PDB is correct
            for a given DLL.   Setting this value is dangerous because it is easy for the PDB to be for a different
            version of the DLL and thus give inaccurate method names.   Nevertheless, if a log file has no PDB GUID
            information associated with it, unsafe PDB matching is the only way to get at least some symbolic information. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo">
            <summary>
            A CodeAddressInfo is the actual data stored in the ETLX file that represents a 
            TraceCodeAddress.     It knows its Address in the process and it knows the 
            TraceModuleFile (which knows its base address), so it also knows its relative
            address in the TraceModuleFile (which is what is needed to look up the value 
            in the PDB.  
            
            Note that by the time that the CodeAddressInfo is persisted in the ETLX file
            it no longer knows the process it originated from (thus separate processes 
            with the same address and same DLL file loaded at the same address can share
            the same CodeAddressInfo.  This is actually reasonably common, since OS tend
            to load at their preferred base address.  
            
            We also have to handle the managed case, in which case the CodeAddressInfo may
            also know about the TraceMethod or the ILMapIndex (which remembers both the
            method and the line numbers for managed code. 
            
            However when the CodeAddressInfo is first created, we don't know the TraceModuleFile
            so we also need to remember the Process
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.GetProcessIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses)">
            <summary>
            This is only valid until MethodIndex or ModuleFileIndex is set.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.GetMethodIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses)">
            <summary>
            Only for managed code.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.GetModuleFileIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses)">
            <summary>
            Only for unmanaged code.   TODO, this can be folded into methodOrProcessIlMap index and save a DWORD.  
            since if the method or IlMap is present then you can get the ModuelFile index from there.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.InclusiveCount">
            <summary>
            This is a count of how many times this code address appears in any stack in the trace.  
            It is a measure of what popular the code address is (whether we should look up its symbols).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress">
             <summary>
             Conceptually a TraceCodeAddress represents a particular point of execution within a particular 
             line of code in some source code.    As a practical matter, they are represented two ways
             depending on whether the code is managed or not.
             <para>* For native code (or NGened code), it is represented as a virtual address along with the loaded native
             module that includes that address along with its load address.  A code address does NOT 
             know its process because they can be shared among all processes that load a particular module
             at a particular location.   These code addresses will not have methods associated with them
             unless symbols information (PDBS) are loaded for the module using the LookupSymbolsForModule.  
             </para>
             <para> * For JIT compiled managed code, the address in a process is eagerly resolved into a method, module
             and an IL offset and that is stored in the TraceCodeAddress.  
             </para>
            <para> Sometimes it is impossible to even determine the module associated with a virtual
            address in a process.   These are represented as simply the virtual address.  
            </para>
            <para>
            Because code addresses are so numerous, consider using CodeAddressIndex instead of TraceCodeAddress
            to represent a code address.   Methods on TraceLog.CodeAddresses can access all the information
            that would be in a TraceCodeAddress from a CodeAddressIndex without the overhead of creating
            a TraceCodeAddress object. 
            </para>
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.GetSourceLine(Microsoft.Diagnostics.Symbols.SymbolReader)">
            <summary>
            A TraceCodeAddress can contain a method name, but does not contain number information.   To 
            find line number information you must read the PDB again and fetch it.   This is what
            GetSoruceLine does.  
            <para> 
            Given a SymbolReader (which knows how to look up PDBs) find a SourceLocation (which represents a
            particular line number in a particular source file associated with the current TraceCodeAddress.
            Returns null if anything goes wrong (and diagnostic information will be written to the
            log file associated with the SymbolReader.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ToString">
            <summary>
            An XML representation for the CodeAddress (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ToString(System.Text.StringBuilder)">
            <summary>
            Writes an XML representation for the CodeAddress to the stringbuilder sb
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.CodeAddressIndex">
            <summary>
            The CodeAddressIndex that uniquely identifies the same code address as this TraceCodeAddress
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.Address">
            <summary>
            The Virtual address of the code address in the process.  (Note that the process is unknown by the code address to allow for sharing)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.FullMethodName">
            <summary>
            The full name (Namespace name.class name.method name) of the method associated with this code address.   
            Returns the empty string if no method is associated with the code address. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.Method">
            <summary>
            Returns the TraceMethod associated with this code address or null if there is none. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ILOffset">
            <summary>
            If the TraceCodeAddress is associated with managed code, return the IL offset within the method.    If the method
            is unmanaged -1 is returned.   To determine the IL offset the PDB for the NGEN image (for NGENed code) or the
            correct .NET events (for JIT compiled code) must be present.   If this information is not present -1 is returned. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ModuleFile">
            <summary>
            Returns the TraceModuleFile representing the DLL path associated with this code address (or null if not known)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ModuleName">
            <summary>
            ModuleName is the name of the file without path or extension. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ModuleFilePath">
            <summary>
            The full path name of the DLL associated with this code address.  Returns empty string if not known. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.CodeAddresses">
            <summary>
            The CodeAddresses container that this Code Address lives within
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.MethodIndex">
            <summary>
            MethodIndex uniquely identifies a method within the log.  Valid values are between 0 and
            TraceMethods.Count-1. Thus, an array can be used to 'attach' data to a method.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.MethodIndex.Invalid">
            <summary>
            Returned when no appropriate Method exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods">
            <summary>
            Methods are so common in most traces, that having a .NET object (a TraceMethod) for
            each one is often too expensive.   As optimization, TraceLog also assigns a method index
            to every method and this index uniquely identifies the method in a very light weight fashion.
            <para>
            To be useful, however you need to be able to ask questions about a method index without creating
            a TraceMethod.   This is the primary purpose of a TraceMethods (accessible from TraceLog.CodeAddresses.Methods).   
            It has a set of 
            methods that take a MethodIndex and return properties of the method (like its name, and module file)
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.MethodToken(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, if the method is managed return the IL meta data MethodToken (returns 0 for native code)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.MethodRva(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return the Method's RVA (offset from the base of the DLL in memory)  (returns 0 for managed code)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.MethodModuleFileIndex(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return the index for the ModuleFile associated with the Method Index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.FullMethodName(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return the Full method name (Namespace.ClassName.MethodName) associated with the Method Index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.ToString">
            <summary>
            Returns an XML representation of the TraceMethods.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.GetEnumerator">
            <summary>
            IEnumerable support
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.Count">
            <summary>
            Returns the count of method indexes.  All MethodIndexes are strictly less than this. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.Item(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return a TraceMethod that also represents the method.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod">
            <summary>
            A TraceMethod represents the symbolic information for a particular method.   To maximizes haring a TraceMethod 
            has very little state, just the module and full method name.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.ToString">
            <summary>
            A XML representation of the TraceMethod. (Used for debugging)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.ToString(System.Text.StringBuilder)">
            <summary>
            Writes an XML representation of the TraceMethod to the stringbuilder 'sb'
            </summary>
            <param name="sb"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodIndex">
            <summary>
            Each Method in the TraceLog is given an index that uniquely identifies it.  This return this index for this TraceMethod
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.FullMethodName">
            <summary>
            The full name of the method (Namespace.ClassName.MethodName). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodToken">
            <summary>
            .Net runtime methods have a token (32 bit number) that uniquely identifies it in the meta data of the managed DLL.  
            This property returns this token. Returns 0 for unmanaged code or method not found. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodRva">
            <summary>
            For native code the RVA (relative virtual address, which is the offset from the base of the file in memory)
            for the method in the file. Returns 0 for managed code or method not found;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodModuleFileIndex">
            <summary>
            Returns the index for the DLL ModuleFile (which represents its file path) associated with this method
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodModuleFile">
            <summary>
            Returns the ModuleFile (which represents its file path) associated with this method
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ModuleFileIndex">
            <summary>
            A ModuleFileIndex represents a particular file path on the disk.   It is a number
            from 0 to MaxModuleFileIndex, which means that you can create a side array to hold
            information about module files.
            
            You can look up information about the ModuleFile from the ModuleFiles type.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ModuleFileIndex.Invalid">
            <summary>
            Returned when no appropriate ModuleFile exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles">
            <summary>
            TraceModuleFiles is the list of all the ModuleFiles in the trace.   It is an IEnumerable.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.ToString">
            <summary>
            Returns an XML representation of the TraceModuleFiles
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.System#Collections#Generic#IEnumerable{Microsoft#Diagnostics#Tracing#Etlx#TraceModuleFile}#GetEnumerator">
            <summary>
            Enumerate all the files that occurred in the trace log.  
            </summary> 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.GetOrCreateModuleFile(System.String,System.UInt64)">
            <summary>
            We cache information about a native image load in a TraceModuleFile.  Retrieve or create a new
            cache entry associated with 'nativePath' and 'moduleImageBase'.  'moduleImageBase' can be 0 for managed assemblies
            that were not loaded with LoadLibrary.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.GetModuleFile(System.String,System.UInt64)">
            <summary>
            For a given file name, get the TraceModuleFile associated with it.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.Count">
            <summary>
            Each file is given an index for quick lookup.   Count is the
            maximum such index (thus you can create an array that is 1-1 with the
            files easily).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.Item(Microsoft.Diagnostics.Tracing.Etlx.ModuleFileIndex)">
            <summary>
            Given a ModuleFileIndex, find the TraceModuleFile which also represents it
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.Log">
            <summary>
            Returns the TraceLog associated with this TraceModuleFiles
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile">
            <summary>
            The TraceModuleFile represents a executable file that can be loaded into memory (either an EXE or a
            DLL).  It represents the path on disk as well as the location in memory where it loads (or
            its ModuleID if it is a managed module), but not the load or unload time or the process in which
            it was loaded (this allows them to be shared within the trace).   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ToString">
            <summary>
            Returns an XML representation of the TraceModuleFile (for debugging) 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ModuleFileIndex">
            <summary>
            The ModuleFileIndex ID that uniquely identifies this module file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.FilePath">
            <summary>
            The moduleFile name associated with the moduleFile.  May be the empty string if the moduleFile has no moduleFile
            (dynamically generated).  For managed code, this is the IL moduleFile name.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.Name">
            <summary>
            This is the short name of the moduleFile (moduleFile name without extension). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageBase">
            <summary>
            Returns the address in memory where the dll was loaded.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageSize">
            <summary>
            Returns the size of the DLL when loaded in memory
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageEnd">
            <summary>
            Returns the address just past the memory the module uses. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.PdbName">
            <summary>
            The name of the symbol file (PDB file) associated with the DLL
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.PdbSignature">
            <summary>
            Returns the GUID that uniquely identifies the symbol file (PDB file) for this DLL
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.PdbAge">
            <summary>
            Returns the age (which is a small integer), that is also needed to look up the symbol file (PDB file) on a symbol server.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.FileVersion">
            <summary>
            Returns the file version string that is optionally embedded in the DLL's resources.   Returns the empty string if not present. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.BuildTime">
            <summary>
            Returns the time the DLL was built as a DateTime.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.CodeAddressesInModule">
            <summary>
            The number of code addresses included in this module.  This is useful for determining if 
            this module is worth having its symbolic information looked up or not.   It is not 
            otherwise a particularly interesting metric.  
            <para>
            This number is defined as the number of appearances this module has in any stack 
            or any event with a code address (If the modules appears 5 times in a stack that
            counts as 5 even though it is just one event's stack).  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ManagedModule">
            <summary>
            If the module file was a managed native image, this is the IL file associated with it.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex">
            <summary>
            A ActivityIndex uniquely identifies an Activity in the log. Valid values are between
            0 and Activities.Count-1.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex.Invalid">
            <summary>
            valid activity indexes are non-negative integers
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity">
            <summary>
            Representation of an Activity. An activity can be thought of as a unit of execution associated with
            a task or workitem; it executes on one thread, and has a start and end time. An activity keeps track
            of its "creator" or "caller" -- which is the activity that scheduled it. Using the "creator" link a
            user can determine the chain of activities that led up to the current one.
            
            Given an event you can get the Activity for the event using the Activity() extension method.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ToString">
            <summary>
            To use mainly for debugging
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Index">
            <summary>A trace-wide unique id identifying an activity</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Creator">
            <summary>The activity that initiated or caused the current one</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ID">
            <summary>
            This return an unique string 'name' for the activity.  It is a the Index followed by 
            a - followed by the TPL index (if available).  It is a bit nicer since it gives
            more information for debugging.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Path">
            <summary>
            Computes the creator path back to root. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Thread">
            <summary>The thread on which the activity is running</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.MultiTrigger">
            <summary>True if there may be multiple activities that were initiated by caller (e.g. managed Timers)</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Name">
            <summary>A descriptive label for the activity
                TODO: eliminate and use ToString()?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.IsThreadActivity">
            <summary>
            A thread activity is the activity associate with an OS thread.   It is special because it may 
            have a region that is disjoint.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.StartTimeRelativeMSec">
            <summary>Time from beginning of trace (in msec) when activity started executing</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.EndTimeRelativeMSec">
            <summary>Time from beginning of trace (in msec) when activity completed execution.  Does not include children.</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.CreationEventIndex">
            <summary>The event index of the TraceEvent instance that created/scheduled this activity</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.CreationCallStackIndex">
            <summary>The call stack index of the TraceEvent instance that scheduled (caused the creation of) the activity</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.CreationTimeRelativeMSec">
            <summary>Time from beginning of trace (in msec) when activity was scheduled</summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind">
            <summary>
            Describes the kinds of known Activities (used for descriptive purposes alone)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.Invalid">
            <summary>Invalid</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.Initial">
            <summary>
            Default activity on a thread (when the thread does not execute any code on
            behalf of anyone else)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskScheduled">
            <summary>
            An activity that was initiated by a Task.Run
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskStarted">
            <summary>
            An activity that's a task, but for which we didn't see a "Scheduled" event
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.AwaitTaskScheduled">
            <summary>
            An activity that allows correlation between the antecedent and continuation 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.ClrThreadStart">
            <summary>A thread started with Thread.Start</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.ClrThreadPool">
            <summary>Native CLR threadpool workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.ClrIOThreadPool">
            <summary>Native CLR IO threadpool workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxThreadPool">
            <summary>Managed threadpool workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxTransfer">
            <summary>Generic managed thread transfer</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxAsyncIO">
            <summary>Managed async IO workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxWinRTDispatch">
            <summary>WinRT Dispatched workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.Implied">
            <summary>
            Used when we make up ones because we know that have to be there but we don't know enough to do more than that. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskWait">
            <summary>
            An activity that allows correlation between the antecedent and continuation 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskWaitSynchronous">
            <summary>Same as TaskWait, hwoever it auto-completes</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxTimer">
            <summary>Managed timer workitem</summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions">
            <summary>
            TraceLogOptions control the generation of a TraceLog (ETLX file) from an ETL file.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.#ctor">
            <summary>
            Creates a new object containing options for constructing a TraceLog file.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ShouldResolveSymbols">
            <summary>
            If non-null, this is a predicate that, given a file path to a dll, answers the question
            whether the PDB associated with that DLL be looked up and its symbolic information added
            to the TraceLog file as part of conversion.   Symbols can be looked up afterward when 
            the file is later opened, so the default (which is to look up no symbols during
            conversion) is typically OK. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.LocalSymbolsOnly">
            <summary>
            Resolving symbols from a symbol server can take a long time. If
            there is a DLL that always fails, it can be quite annoying because
            it will always cause delays, By specifying only local symbols it
            will only resolve the symbols if it can do so without the delay of network traffic. 
            Symbols that have been previously cached locally from a symbol
            server count as local symbols.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.AlwaysResolveSymbols">
            <summary>
            By default symbols are only resolved if there are stacks associated with the trace. 
            Setting this option forces resolution even if there are no stacks. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ConversionLogName">
            <summary>
            If ConversionLogName is set, it indicates that any messages associated with creating the TraceLog should be written here. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.KeepAllEvents">
            <summary>
            ETL files typically contain a large number of 'bookkeeping' event for resolving names of files, or methods or to indicate information
            about processes that existed when the trace was started (DCStart and DCStop events).   By default these events are stripped from
            the ETLX file because their information has already been used to do the bookkeeping as part of the conversion
            <para> 
            However sometimes it is useful to keep these events (typically for debugging TraceEvent itself) and setting this
            property to true will cause every event in the ETL file to be copied as an event to the ETLX file.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.MaxEventCount">
            <summary>
            Sometimes ETL files are too big , and you just want to look at a fraction of it to speed things up
            (or to keep file size under control).  The MaxEventCount property allows that.   10M will produce a 3-4GB ETLX file.  
            1M is a good value to keep ETLX file size under control.  Note that that the conversion still scan the entire 
            original ETL file too look for bookkeeping events, however MaxEventCount events will be transfered to the ETLX 
            file as events.
            <para>
            The default is 10M because ETLX has a restriction of 4GB in size.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.SkipMSec">
            <summary>
            If an ETL file has too many events for efficient processing the first part of the trace can be skipped by setting this
            property.   Any event which happens before 'SkipMSec' into the session will be filtered out.   This property is
            intended to be used along with the MaxEventCount property to carve out a arbitrary chunk of time from an ETL
            file as it is converted to an ETLX file.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.OnLostEvents">
            <summary>
            If this delegate is non-null, it is called if there are any lost events or if the file was truncated.
            It is passed a bool whether the ETLX file was truncated, as well as the number of lost events and the 
            total number of events in the ETLX file.  You can throw if you want to abort.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ExplicitManifestDir">
            <summary>
            If you have the manifests for particular providers, you can read them in explicitly by setting this directory.
             All files of the form *.manifest.xml will be read into the DynamicTraceEventParser's database before conversion
             starts.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ConversionLog">
            <summary>
            Writes status to this log.  Useful for debugging symbol issues.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions">
            <summary>
            The TraceEvent instances returned during the processing of a TraceLog have additional capabilities that these extension methods can access.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Process(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceProcess associated with a TraceEvent.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Thread(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceThread associated with a TraceEvent.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Log(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceLog associated with a TraceEvent.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.CallStack(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceCallStack associated with a TraceEvent.   Returns null if the event does not have callstack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.CallStackIndex(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the CallStack index associated with a TraceEvent.   Returns Invalid if the event does not have callstack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.BlockingStack(Microsoft.Diagnostics.Tracing.Parsers.Kernel.CSwitchTraceData)">
            <summary>
            Finds the CallStack index associated the blocking thread for CSwitch event
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.CallStacks(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceCallStacks associated with a TraceEvent.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Activity(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the Activity associated with a TraceEvent
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.ActivityIndex(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the ActivityIndex associated with a TraceEvent
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.ProgramCounterAddress(Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageFaultTraceData)">
            <summary>
            For a PageFaultTraceData event, gets the TraceCodeAddress associated with the ProgramCounter address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.ProgramCounterAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageFaultTraceData)">
            <summary>
            For a PageFaultTraceData event, gets the CodeAddressIndex associated with the ProgramCounter address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.IntructionPointerCodeAddress(Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData)">
            <summary>
            For a SampledProfileTraceData event, gets the TraceCodeAddress associated with the InstructionPointer address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.IntructionPointerCodeAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData)">
            <summary>
            For a SampledProfileTraceData event, gets the CodeAddressIndex associated with the InstructionPointer address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.RoutineCodeAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.ISRTraceData)">
            <summary>
            For a ISRTraceData event, gets the CodeAddressIndex associated with the Routine address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.RoutineCodeAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.DPCTraceData)">
            <summary>
            For a DPCTraceData event, gets the CodeAddressIndex associated with the Routine address. 
            </summary>
        </member>
        <member name="T:Utilities.CommandOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a 
            parameter to the constructor of a Command.  
            
            It is useful for these options be be on a separate class (rather than 
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise. 
            </summary>
        </member>
        <member name="F:Utilities.CommandOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout. 
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.Clone">
            <summary>
            Return a copy an existing set of command options
            </summary>
            <returns>The copy of the command options</returns>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoThrow">
            <summary>
            Updates the NoThrow propery and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddStart">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddUseShellExecute">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoWindow">
            <summary>
            Updates the NoWindow propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoWait">
            <summary>
            Updates the NoWait propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddElevate">
            <summary>
            Updates the Elevate propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout propery and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddInput(System.String)">
            <summary>
            Updates the Input propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of 
            environmetn variables to be passed to the sub-process and returns the 
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero 
            exit code.  NoThrow suppresses this. 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.  
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoWait">
            <summary>
            Indicates that you want don't want to wait for the command to complete.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Elevate">
            <summary>
            Indicates that the command must run at elevated Windows privledges (causes a new command window)
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout. 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.  
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have. 
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property 
            of the command.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="T:Utilities.Command">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexitity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="M:Utilities.Command.RunToConsole(System.String,Utilities.CommandOptions)">
            <summary>
            Run 'commandLine', sending the output to the console, and wait for the command to complete.
            This simulates what batch filedo when executing their commands.  It is a bit more verbose
            by default, however 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.Run(System.String,Utilities.CommandOptions)">
            <summary>
            Run 'commandLine' as a subprocess and waits for the command to complete.
            Output is captured and placed in the 'Output' property of the returned Command 
            structure. 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.#ctor(System.String,Utilities.CommandOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the restult.  It does not wait for the command to complete, however you 
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options. 
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Utilities.Command.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be true on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Utilities.Command.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal 
            Command.Run failure was the appropriate action.  
            </summary>
            <param name="message">An additional message to print in the throw (can be null)</param>
        </member>
        <member name="M:Utilities.Command.Kill">
            <summary>
            Kill the process (and any child processses (recursively) associated with the 
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however. 
            </summary>
        </member>
        <member name="M:Utilities.Command.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes.  
            </summary>
        </member>
        <member name="M:Utilities.Command.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.   
            Returns null if it was not found.   
            </summary>
        </member>
        <member name="P:Utilities.Command.StartTime">
            <summary>
            The time the process started.  
            </summary>
        </member>
        <member name="P:Utilities.Command.HasExited">
            <summary>
            Returns true if the process has exited. 
            </summary>
        </member>
        <member name="P:Utilities.Command.ExitTime">
            <summary>
            The time the processed Exited.  (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Utilities.Command.Duration">
            <summary>
            The duration of the command (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Utilities.Command.Id">
            <summary>
            The operating system ID for the subprocess.  
            </summary>
        </member>
        <member name="P:Utilities.Command.ExitCode">
            <summary>
            The process exit code for the subprocess.  (HasExited should be true before calling)
            Often this does not need to be checked because Command.Run will throw an exception 
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property 
            was set.  
            </summary>
        </member>
        <member name="P:Utilities.Command.Output">
            <summary>
            The standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is 
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time. 
            </summary>
        </member>
        <member name="P:Utilities.Command.Options">
            <summary>
            Returns that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="P:Utilities.Command.Process">
            <summary>
            Get the underlying process object.  Generally not used. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Utilities.HistoryDictionary`1">
            <summary>
            A HistoryDictionary is designed to look up 'handles' (pointer sized quantities), that might get reused
            over time (eg Process IDs, thread IDs).  Thus it takes a handle AND A TIME, and finds the value
            associated with that handle at that time.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.HistoryDictionary`1.Add(System.UInt64,System.Int64,`0,System.Boolean)">
            <summary>
            Adds the association that 'id' has the value 'value' from 'startTime100ns' ONWARD until
            it is supersede by the same id being added with a time that is after this.   Thus if
            I did Add(58, 1000, MyValue1), and add(58, 500, MyValue2) 'TryGetValue(58, 750, out val) will return
            MyValue2 (since that value is 'in force' between time 500 and 1000.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.HistoryDictionary`1.Remove(System.UInt64)">
            <summary>
            Remove all entries associated with a given key (over all time).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.WppTraceEventParser">
            <summary>
            This parser knows how to decode Windows Software Trace Preprocessor (WPP) events.  In order to decode
            the events it needs access to the TMF files that describe the events (these are created from the PDB at 
            build time). 
            <br/>
            You will generally use this for the 'FormattedMessage' property of the event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.WppTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.String)">
            <summary>
            Construct a new WPPTraceEventParser that is attached to 'source'.   Once you do this the source
            will understand WPP events. In particular you can subscribe to the  Wpp.All event to get the
            stream of WPP events in the source. For WppTraceEventParser to function, it needs the TMF
            files for the events it will decode. You should pass the directory to find these TMF files 
            in 'TMFDirectory'.  Each file should have the form of a GUID.tmf.   
            </summary>
            <param name="source"></param>
            <param name="TMFDirectory"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ZippedETLWriter">
            <summary>
            ZippedETLWriter is a helper class used to compress ETW data (ETL files)
            along with symbolic information (e.g. NGEN pdbs), as well as other optional
            metadata (e.g. collection log files), into a single archive ready for 
            transfer to another machine.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Declares the intent to write a new ZIP archive that will
            contain ETW file 'etlFilePath' in it as well as symbolic information (NGEN
            pdbs) and possibly other information.   log is a Text stream to send detailed
            information to.  
            <para>
            This routine assumes by default (unless Merge is set to false) that the ETL 
            file needs to be merged before it is archived.   It will also generate all
            the NGEN pdbs needed for the archive.   
            </para>
            <para>
            You must call the WriteArchive method before any operations actually happen. 
            Up to that point is is just remembering instructions for WriteArchive to
            follow.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.AddFile(System.String,System.String)">
            <summary>
            By default ZippedETL file will zip the ETL file itself and the NGEN pdbs associated with it.
            You can add additional files to the archive by calling AddFile.   In specififed 'archivePath' 
            is the path in the archive and defaults to just the file name of the original file path.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.WriteArchive">
            <summary>
            Actually do the work specified by the ZippedETLWriter constructors and other methods.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.GetNGenPdbs(System.String,Microsoft.Diagnostics.Symbols.SymbolReader,System.IO.TextWriter)">
            <summary>
            Returns the list of path names to the NGEN pdbs for any NGEN image in 'etlFile' that has
            any samples in it.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.ZipArchivePath">
            <summary>
            This is the name of the output archive.  By default is the same as the ETL file name 
            with a .zip' suffix added (thus it will typically be .etl.zip).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Log">
            <summary>
            If set this is where messages about progress and detailed error information goes.  
            While you dont; have to set this, it is a good idea to do so.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.SymbolReader">
            <summary>
            This is the symbol reader that is used to generate the NGEN Pdbs as needed
            If it is not specififed one is created on the fly.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Merge">
            <summary>
            By default the ETL file is merged before being added to the archive.  If
            this is not necessary, you can set this to false.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.CompressETL">
            <summary>
            Uses a compressed format for the ETL file.   Normally off.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.NGenSymbolFiles">
            <summary>
            By default the symbol files (PDBs) are included in the ZIP file.   If this
            is not desired for whatever reason, this property can be set to false.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Zip">
            <summary>
            Normally WriteArchive creates a ZIP archive.  However it is possible that you only wish
            to do the merging and NGEN symbol generation.   Setting this property to false
            will supress the final ZIP operation.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.DeleteInputFile">
            <summary>
            Normally if you ZIP you will delete the original ETL file.  Setting this to false overrides this.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ZippedETLReader">
            <summary>
            ZippedETLReader is a helper class that unpacks the ZIP files generated
            by the ZippedETLWriter class.    It can be smart about placing the 
            symbolic information in these files on the SymbolReader's path so that
            symbolic lookup 'just works'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLReader.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Declares the intent to unzip an .ETL.ZIP file that contain an compressed ETL file 
            (and NGEN pdbs) from the archive at 'zipFilePath'.   If present, messages about
            the unpacking go to 'log'.   Note that this unpacking only happens when the
            UnpackArchive() method is called.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLReader.UnpackAchive">
            <summary>
            After setting any properties to override default behavior, calling this method
            will actually do the unpacking.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.Log">
            <summary>
            If set messages about unpacking go here. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.EtlFileName">
            <summary>
            The name of hte ETL file to extract (it is an error if there is not exactly 1).  
            If not present it is derived by changing the extension of the zip archive. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.SymbolDirectory">
            <summary>
            Where to put the symbols.  
            </summary>
        </member>
    </members>
</doc>
